const l=(r,t,o,s,e)=>{const n=v(r,s.pos,e.pos),i=o*o;if(n>i)return 0;const h=(2*3)**2;if(n<h)return-1;const y=t[s.color][e.color]??0;return y===0?0:C(n,i/2,i,0,y)},C=function(r,t,o,s,e){const n=t+(o-t)/2;return r<n?p(r,t,n,s,e):p(r,n,o,e,s)},p=function(r,t,o,s,e){const n=(r-t)/(o-t)*(e-s)+s;return s<e?q(n,s,e):q(n,e,s)},q=function(r,t,o){return Math.max(Math.min(r,o),t)};class M{squares;squareByCellId;worldSize;maxAttractionRadius;constructor(t){const{worldSize:o,maxAttractionRadius:s}=t;if(o.x%s!==0||o.y%s!==0)throw new Error("Screen size is not a multiple of maxAttractionRadius");this.worldSize={...o},this.maxAttractionRadius=s,this.squareByCellId=new Map,this.squares=[];const e=s,n=o.x/e,i=o.y/e;for(let a=0;a<i;a++){this.squares.push([]);for(let h=0;h<n;h++)this.squares[a].push(new Set)}}checkCoord(t){if(t.x<0||t.x>this.worldSize.x||t.y<0||t.y>this.worldSize.y)throw new Error(`The cell at position ${t.x},${t.y} is outside of the screen ${this.worldSize.x},${this.worldSize.y} `)}getSquareCoords(t){return this.checkCoord(t),{x:Math.floor(t.x*this.squares[0].length/this.worldSize.x),y:Math.floor(t.y*this.squares.length/this.worldSize.y)}}insert(t){if(this.squareByCellId.get(t.id))throw new Error("Cell already in map");const o=this.getSquareCoords(t.pos);this.squares[o.y][o.x].add(t.id),this.squareByCellId.set(t.id,o)}updateCell(t){this.checkCoord(t.pos);const o=this.squareByCellId.get(t.id);if(!o)throw new Error("Cell not in map");this.squares[o.y][o.x].delete(t.id);const s=this.getSquareCoords(t.pos);this.squares[s.y][s.x].add(t.id),this.squareByCellId.set(t.id,s)}getNeighborsIds(t){const o=this.squareByCellId.get(t.id);if(!o)throw new Error("Cell not in map");const{x:s,y:e}=o,n=s===0?this.squares[0].length-1:s-1,i=s===this.squares[0].length-1?0:s+1,a=e===0?this.squares.length-1:e-1,h=e===this.squares.length-1?0:e+1,y=[{x:n,y:a},{x:s,y:a},{x:i,y:a},{x:n,y:e},{x:s,y:e},{x:i,y:e},{x:n,y:h},{x:s,y:h},{x:i,y:h}],d=[];for(const{x:u,y:x}of y)d.push(...this.squares[x][u]);return d}}const g=["white","red","green","blue"],w=()=>{const r=Math.floor(Math.random()*g.length);return g[r]},I=(r,t,o)=>{const s=[],e=new M({worldSize:r,maxAttractionRadius:o});for(let n=0;n<t;n++){const i={id:n,pos:{x:Math.random()*r.x,y:Math.random()*r.y},vel:{x:0,y:0},color:w()};s.push(i),e.insert(i)}return{cells:s,cellsMap:e}},b=(r,t,o)=>{let s=Math.abs(o.x-t.x);s>r.x/2&&(s=r.x-s);let e=Math.abs(o.y-t.y);return e>r.y/2&&(e=r.y-e),Math.sqrt(s*s+e*e)},v=(r,t,o)=>{let s=Math.abs(o.x-t.x);s>r.x/2&&(s=r.x-s);let e=Math.abs(o.y-t.y);return e>r.y/2&&(e=r.y-e),s*s+e*e},m=(r,t)=>{const o=Math.abs(t.x-r.x),s=Math.abs(t.y-r.y);return o*o+s*s},B=(r,t,o,s)=>{for(let e=0;e<o.length;e++){const n=o[e];n.vel={x:0,y:0};const i=s.getNeighborsIds(n);for(const h of i){if(e===h)continue;const y=o[h];let d=l(s.worldSize,r,t,n,y);m(n.pos,y.pos)>s.worldSize.y*s.worldSize.y/2&&(d*=-1);const u={x:y.pos.x-n.pos.x,y:y.pos.y-n.pos.y},x=Math.sqrt(u.x*u.x+u.y*u.y);if(x===0)continue;const c={x:u.x*(1/x),y:u.y*(1/x)},f={x:c.x*d,y:c.y*d};n.vel.x+=f.x,n.vel.y+=f.y}const a=Math.sqrt(n.vel.x*n.vel.x+n.vel.y*n.vel.y);a!==0&&(n.vel.x*=1/a,n.vel.y*=1/a,S(s.worldSize,n),s.updateCell(n))}},S=(r,t)=>{t.pos.x+=t.vel.x,t.pos.y+=t.vel.y,t.pos.x<=0?t.pos.x=r.x+t.pos.x:t.pos.x>=r.x&&(t.pos.x=t.pos.x-r.x),t.pos.y<=0?t.pos.y=r.y+t.pos.y:t.pos.y>=r.y&&(t.pos.y=t.pos.y-r.y)};export{b as d,I as g,p as l,B as u};
