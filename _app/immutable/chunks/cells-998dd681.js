var l=Object.defineProperty;var w=(e,t,s)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var c=(e,t,s)=>(w(e,typeof t!="symbol"?t+"":t,s),s);const M=(e,t,s,o,n)=>{const r=m(e,o.pos,n.pos);if(r>s)return 0;if(r<s/2)return p(r,0,s/2,-1,0);const i=t[o.color][n.color]??0;return i===0?0:v(r,s/2,s,0,i)},v=function(e,t,s,o,n){const r=t+(s-t)/2;return e<r?p(e,t,r,o,n):p(e,r,s,n,o)},p=function(e,t,s,o,n){const r=(e-t)/(s-t)*(n-o)+o;return o<n?g(r,o,n):g(r,n,o)},g=function(e,t,s){return Math.max(Math.min(e,s),t)};class S{constructor(t){c(this,"squares");c(this,"squareByCellId");c(this,"worldSize");c(this,"maxAttractionRadius");const{worldSize:s,maxAttractionRadius:o}=t;if(s.x%o!==0||s.y%o!==0)throw new Error("Screen size is not a multiple of maxAttractionRadius");this.worldSize={...s},this.maxAttractionRadius=o,this.squareByCellId=new Map,this.squares=[];const n=o,r=s.x/n,i=s.y/n;for(let a=0;a<i;a++){this.squares.push([]);for(let h=0;h<r;h++)this.squares[a].push(new Set)}}checkCoord(t){if(t.x<0||t.x>this.worldSize.x||t.y<0||t.y>this.worldSize.y)throw new Error(`The cell at position ${t.x},${t.y} is outside of the screen ${this.worldSize.x},${this.worldSize.y} `)}getSquareCoords(t){return this.checkCoord(t),{x:Math.floor(t.x*this.squares[0].length/this.worldSize.x),y:Math.floor(t.y*this.squares.length/this.worldSize.y)}}insert(t){if(this.squareByCellId.get(t.id))throw new Error("Cell already in map");const s=this.getSquareCoords(t.pos);this.squares[s.y][s.x].add(t.id),this.squareByCellId.set(t.id,s)}updateCell(t){this.checkCoord(t.pos);const s=this.squareByCellId.get(t.id);if(!s)throw new Error("Cell not in map");this.squares[s.y][s.x].delete(t.id);const o=this.getSquareCoords(t.pos);this.squares[o.y][o.x].add(t.id),this.squareByCellId.set(t.id,o)}getNeighborsIds(t){const s=this.squareByCellId.get(t.id);if(!s)throw new Error("Cell not in map");const{x:o,y:n}=s,r=o===0?this.squares[0].length-1:o-1,i=o===this.squares[0].length-1?0:o+1,a=n===0?this.squares.length-1:n-1,h=n===this.squares.length-1?0:n+1,u=[{x:r,y:a},{x:o,y:a},{x:i,y:a},{x:r,y:n},{x:o,y:n},{x:i,y:n},{x:r,y:h},{x:o,y:h},{x:i,y:h}],x=[];for(const{x:y,y:d}of u)x.push(...this.squares[d][y]);return x}}const C=["white","red","green","blue"],I=()=>{const e=Math.floor(Math.random()*C.length);return C[e]},E=(e,t,s)=>{const o=[],n=new S({worldSize:e,maxAttractionRadius:s});for(let r=0;r<t;r++){const i={id:r,pos:{x:Math.random()*e.x,y:Math.random()*e.y},vel:{x:0,y:0},color:I()};o.push(i),n.insert(i)}return{cells:o,cellsMap:n}},m=(e,t,s)=>{let o=Math.abs(s.x-t.x);o>e.x/2&&(o=e.x-o);let n=Math.abs(s.y-t.y);return n>e.y/2&&(n=e.y-n),Math.sqrt(o*o+n*n)},b=(e,t)=>{const s=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);return s*s+o*o},N=(e,t,s,o)=>{for(let n=0;n<s.length;n++){const r=s[n];r.vel={x:0,y:0};const i=o.getNeighborsIds(r);for(const h of i){if(n===h)continue;const u=s[h];let x=M(o.worldSize,e,t,r,u);b(r.pos,u.pos)>o.worldSize.y*o.worldSize.y/2&&(x*=-1);const y={x:u.pos.x-r.pos.x,y:u.pos.y-r.pos.y},d=Math.sqrt(y.x*y.x+y.y*y.y);if(d===0)continue;const f={x:y.x*(1/d),y:y.y*(1/d)},q={x:f.x*x,y:f.y*x};r.vel.x+=q.x,r.vel.y+=q.y}const a=Math.sqrt(r.vel.x*r.vel.x+r.vel.y*r.vel.y);a!==0&&(r.vel.x*=1/a,r.vel.y*=1/a,B(o.worldSize,r),o.updateCell(r))}},B=(e,t)=>{t.pos.x+=t.vel.x,t.pos.y+=t.vel.y,t.pos.x<=0?t.pos.x=e.x+t.pos.x:t.pos.x>=e.x&&(t.pos.x=t.pos.x-e.x),t.pos.y<=0?t.pos.y=e.y+t.pos.y:t.pos.y>=e.y&&(t.pos.y=t.pos.y-e.y)};export{m as d,E as g,N as u};
