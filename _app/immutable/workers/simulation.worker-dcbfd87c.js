(function(){"use strict";class T{squares;squareByCellId;worldSize;maxAttractionRadius;constructor(t){const{worldSize:e,maxAttractionRadius:s}=t;if(e.x%s!==0||e.y%s!==0)throw new Error("Screen size is not a multiple of maxAttractionRadius");this.worldSize={...e},this.maxAttractionRadius=s,this.squareByCellId=new Map,this.squares=[];const i=s,n=e.x/i,a=e.y/i;for(let h=0;h<a;h++){this.squares.push([]);for(let c=0;c<n;c++)this.squares[h].push(new Set)}}checkCoord(t){if(t.x<0||t.x>this.worldSize.x||t.y<0||t.y>this.worldSize.y)throw new Error(`The cell at position ${t.x},${t.y} is outside of the screen ${this.worldSize.x},${this.worldSize.y} `)}getSquareCoords(t){return this.checkCoord(t),{x:Math.floor(t.x*this.squares[0].length/this.worldSize.x),y:Math.floor(t.y*this.squares.length/this.worldSize.y)}}insert(t){if(this.squareByCellId.get(t.id))throw new Error("Cell already in map");const e=this.getSquareCoords(t.pos);this.squares[e.y][e.x].add(t.id),this.squareByCellId.set(t.id,e)}updateCell(t){this.checkCoord(t.pos);const e=this.squareByCellId.get(t.id);if(!e)throw new Error("Cell not in map");this.squares[e.y][e.x].delete(t.id);const s=this.getSquareCoords(t.pos);this.squares[s.y][s.x].add(t.id),this.squareByCellId.set(t.id,s)}}const z=(o,t)=>{const e=o.squareByCellId.get(t.id);if(!e)throw new Error("Cell not in map");const{x:s,y:i}=e,n=s===0?o.squares[0].length-1:s-1,a=s===o.squares[0].length-1?0:s+1,h=i===0?o.squares.length-1:i-1,c=i===o.squares.length-1?0:i+1,d=[{x:n,y:h},{x:s,y:h},{x:a,y:h},{x:n,y:i},{x:s,y:i},{x:a,y:i},{x:n,y:c},{x:s,y:c},{x:a,y:c}],r=[];for(const{x:p,y:x}of d)r.push(...o.squares[x][p]);return r},M=(o,t,e,s,i,n)=>{if(s>t)return 0;if(s<e)return-1;const a=o[i][n]??0;return a===0?0:I(s,t/2,t,0,a)},I=function(o,t,e,s,i){const n=t+(e-t)/2;return o<n?w(o,t,n,s,i):w(o,n,e,i,s)},w=function(o,t,e,s,i){const n=(o-t)/(e-t)*(i-s)+s;return s<i?q(n,s,i):q(n,i,s)},q=function(o,t,e){return Math.max(Math.min(o,e),t)},A=(o,t,e)=>{let s=Math.abs(e.x-t.x);s>o.x/2&&(s=o.x-s);let i=Math.abs(e.y-t.y);return i>o.y/2&&(i=o.y-i),s*s+i*i},B=(o,t)=>{const e=Math.abs(t.x-o.x),s=Math.abs(t.y-o.y);return e*e+s*s},E=(o,t,e,s)=>{const i=s.worldSize.x<s.worldSize.y?s.worldSize.x:s.worldSize.y,n=i*i/2,a=t*t,c=(2*3)**2;for(let d=0;d<e.length;d++){const r=e[d];r.vel={x:0,y:0};const p=z(s,r);for(const C of p){if(d===C)continue;const l=e[C],S=B(r.pos,l.pos);let _=S,b=!1;S>n&&(_=A(s.worldSize,r.pos,l.pos),b=!0);let f=M(o,a,c,_,r.color,l.color);b&&(f*=-1);const y={x:l.pos.x-r.pos.x,y:l.pos.y-r.pos.y},g=Math.sqrt(y.x*y.x+y.y*y.y);if(g===0)continue;const m={x:y.x*(1/g),y:y.y*(1/g)},v={x:m.x*f,y:m.y*f};r.vel.x+=v.x,r.vel.y+=v.y}const x=Math.sqrt(r.vel.x*r.vel.x+r.vel.y*r.vel.y);x!==0&&(r.vel.x*=1/x,r.vel.y*=1/x,R(s.worldSize,r),s.updateCell(r))}},R=(o,t)=>{t.pos.x+=t.vel.x,t.pos.y+=t.vel.y,t.pos.x<=0?t.pos.x=o.x+t.pos.x:t.pos.x>=o.x&&(t.pos.x=t.pos.x-o.x),t.pos.y<=0?t.pos.y=o.y+t.pos.y:t.pos.y>=o.y&&(t.pos.y=t.pos.y-o.y)};class D{_stepTimeout;_stepCb;_running;_cellsMap;attractionTable;worldSize;cells;constructor(t,e,s,i){this._stepTimeout=void 0,this._stepCb=console.log,this._running=!1,this.cells=t,this.attractionTable=e,this.worldSize=s,this._cellsMap=new T({worldSize:this.worldSize,maxAttractionRadius:i});for(const n of this.cells)this._cellsMap.insert(n)}async run(t){this._stepCb=t;const e=()=>{this._running&&(this.step(),this._stepCb(void 0,this.cells)),this._stepTimeout=setTimeout(e)};this._running=!0,e()}destroy(){clearTimeout(this._stepTimeout)}pause(){this._running&&(this._running=!1)}unpause(){this._running||(this._running=!0)}updateAttractionTable(t){this.attractionTable=t}step(){E(this.attractionTable,this._cellsMap.maxAttractionRadius,this.cells,this._cellsMap)}}let u;onmessage=o=>{const{msg:t}=o.data;if(t==="start"){const{cells:e,attractionTable:s,worldSize:i,maxAttractionRadius:n}=o.data;u&&u.destroy(),u=new D(e,s,i,n),u.run(N)}t==="pause"&&u.pause(),t==="unpause"&&u.unpause(),t==="updateTable"&&u.updateAttractionTable(o.data.attractionTable),t==="destroy"&&u&&u.destroy()};const N=(o,t)=>{if(o)throw o;if(!t)throw new Error("No cells in engine step cb");const e=t.map(s=>s.pos);postMessage({positions:e})}})();
