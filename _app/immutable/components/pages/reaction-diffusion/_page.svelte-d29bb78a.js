import{o as Ee,S as Q,i as J,s as ee,e as K,b as A,g as oe,t as k,d as re,f as _,h,X as ct,Y as Be,Z as yn,L as $e,w as U,x as G,y as N,_ as qe,$ as Ye,z as V,v as ie,a as q,c as Y,q as R,r as P,u as pe,B as ne,V as Sn,C as se,k as z,l as B,m as T,n as y,E as fe,F as ce,G as ue,a0 as et,D as w,a1 as En,a2 as An,a3 as Xe,T as Dn,U as Te,K as Z,Q as ke,O as ye,a4 as we,P as Ae,M as ze,a5 as je,I as it,J as Oe,N as at}from"../../../chunks/index-f5250df5.js";import{T as on,a as rn,b as Me,c as Ue}from"../../../chunks/TabPanel-ab0d47d6.js";import{b as Ze}from"../../../chunks/paths-b4419565.js";import{_ as Ie}from"../../../chunks/preload-helper-41c905a7.js";import{P as Le}from"../../../chunks/P5-3180d94f.js";import{R as Re}from"../../../chunks/regl-787a2c81.js";function zn(){const a=console.warn;console.warn=e=>{e.includes("unknown prop")||e.includes("unexpected slot")||a(e)},Ee(()=>{console.warn=a})}function ut(a,e,n){const o=a.slice();return o[18]=e[n],o}function pt(a,e,n){const o=a.slice();return o[18]=e[n],o}function mt(a,e,n){const o=a.slice();return o[10]=e[n],o}function dt(a,e,n){const o=a.slice();return o[13]=e[n],o[15]=n,o}function ht(a,e,n){const o=a.slice();return o[16]=e[n],o[15]=n,o}function vt(a,e,n){const o=a.slice();return o[7]=e[n],o}function Bn(a){let e,n,o,t;const i=[Ln,In,Tn],r=[];function s(l,f){return l[0]==="table"?0:l[0]==="list"?1:2}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,f){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function Cn(a){let e,n,o=a[1],t=[];for(let r=0;r<o.length;r+=1)t[r]=$t(vt(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&34){o=r[1];let l;for(l=0;l<o.length;l+=1){const f=vt(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=$t(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){$e(t,r),r&&h(e)}}}function Tn(a){let e,n,o;const t=[a[6]];var i=a[5][a[0]];function r(s){let l={$$slots:{default:[Fn]},$$scope:{ctx:s}};for(let f=0;f<t.length;f+=1)l=Be(l,t[f]);return{props:l}}return i&&(e=ie(i,r(a))),{c(){e&&U(e.$$.fragment),n=K()},l(s){e&&G(e.$$.fragment,s),n=K()},m(s,l){e&&N(e,s,l),A(s,n,l),o=!0},p(s,l){const f=l&64?qe(t,[Ye(s[6])]):{};if(l&8388706&&(f.$$scope={dirty:l,ctx:s}),i!==(i=s[5][s[0]])){if(e){oe();const c=e;k(c.$$.fragment,1,0,()=>{V(c,1)}),re()}i?(e=ie(i,r(s)),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}else i&&e.$set(f)},i(s){o||(e&&_(e.$$.fragment,s),o=!0)},o(s){e&&k(e.$$.fragment,s),o=!1},d(s){s&&h(n),e&&V(e,s)}}}function In(a){let e,n,o,t;const i=[Un,Mn],r=[];function s(l,f){return l[4]?0:1}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,f){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function Ln(a){let e,n,o;var t=a[5].table;function i(r){return{props:{$$slots:{default:[jn]},$$scope:{ctx:r}}}}return t&&(e=ie(t,i(a))),{c(){e&&U(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&N(e,r,s),A(r,n,s),o=!0},p(r,s){const l={};if(s&8388716&&(l.$$scope={dirty:s,ctx:r}),t!==(t=r[5].table)){if(e){oe();const f=e;k(f.$$.fragment,1,0,()=>{V(f,1)}),re()}t?(e=ie(t,i(r)),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}else t&&e.$set(l)},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&V(e,r)}}}function Rn(a){let e=a[6].raw+"",n;return{c(){n=R(e)},l(o){n=P(o,e)},m(o,t){A(o,n,t)},p(o,t){t&64&&e!==(e=o[6].raw+"")&&pe(n,e)},i:ne,o:ne,d(o){o&&h(n)}}}function Pn(a){let e,n;return e=new Pe({props:{tokens:a[1],renderers:a[5]}}),{c(){U(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){N(e,o,t),n=!0},p(o,t){const i={};t&2&&(i.tokens=o[1]),t&32&&(i.renderers=o[5]),e.$set(i)},i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){V(e,o)}}}function Fn(a){let e,n,o,t;const i=[Pn,Rn],r=[];function s(l,f){return l[1]?0:1}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,f){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function Mn(a){let e,n,o;const t=[{ordered:a[4]},a[6]];var i=a[5].list;function r(s){let l={$$slots:{default:[Vn]},$$scope:{ctx:s}};for(let f=0;f<t.length;f+=1)l=Be(l,t[f]);return{props:l}}return i&&(e=ie(i,r(a))),{c(){e&&U(e.$$.fragment),n=K()},l(s){e&&G(e.$$.fragment,s),n=K()},m(s,l){e&&N(e,s,l),A(s,n,l),o=!0},p(s,l){const f=l&80?qe(t,[l&16&&{ordered:s[4]},l&64&&Ye(s[6])]):{};if(l&8388704&&(f.$$scope={dirty:l,ctx:s}),i!==(i=s[5].list)){if(e){oe();const c=e;k(c.$$.fragment,1,0,()=>{V(c,1)}),re()}i?(e=ie(i,r(s)),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}else i&&e.$set(f)},i(s){o||(e&&_(e.$$.fragment,s),o=!0)},o(s){e&&k(e.$$.fragment,s),o=!1},d(s){s&&h(n),e&&V(e,s)}}}function Un(a){let e,n,o;const t=[{ordered:a[4]},a[6]];var i=a[5].list;function r(s){let l={$$slots:{default:[Hn]},$$scope:{ctx:s}};for(let f=0;f<t.length;f+=1)l=Be(l,t[f]);return{props:l}}return i&&(e=ie(i,r(a))),{c(){e&&U(e.$$.fragment),n=K()},l(s){e&&G(e.$$.fragment,s),n=K()},m(s,l){e&&N(e,s,l),A(s,n,l),o=!0},p(s,l){const f=l&80?qe(t,[l&16&&{ordered:s[4]},l&64&&Ye(s[6])]):{};if(l&8388704&&(f.$$scope={dirty:l,ctx:s}),i!==(i=s[5].list)){if(e){oe();const c=e;k(c.$$.fragment,1,0,()=>{V(c,1)}),re()}i?(e=ie(i,r(s)),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}else i&&e.$set(f)},i(s){o||(e&&_(e.$$.fragment,s),o=!0)},o(s){e&&k(e.$$.fragment,s),o=!1},d(s){s&&h(n),e&&V(e,s)}}}function Nn(a){let e,n,o;return e=new Pe({props:{tokens:a[18].tokens,renderers:a[5]}}),{c(){U(e.$$.fragment),n=q()},l(t){G(e.$$.fragment,t),n=Y(t)},m(t,i){N(e,t,i),A(t,n,i),o=!0},p(t,i){const r={};i&64&&(r.tokens=t[18].tokens),i&32&&(r.renderers=t[5]),e.$set(r)},i(t){o||(_(e.$$.fragment,t),o=!0)},o(t){k(e.$$.fragment,t),o=!1},d(t){V(e,t),t&&h(n)}}}function gt(a){let e,n,o;const t=[a[18]];var i=a[5].unorderedlistitem||a[5].listitem;function r(s){let l={$$slots:{default:[Nn]},$$scope:{ctx:s}};for(let f=0;f<t.length;f+=1)l=Be(l,t[f]);return{props:l}}return i&&(e=ie(i,r(a))),{c(){e&&U(e.$$.fragment),n=K()},l(s){e&&G(e.$$.fragment,s),n=K()},m(s,l){e&&N(e,s,l),A(s,n,l),o=!0},p(s,l){const f=l&64?qe(t,[Ye(s[18])]):{};if(l&8388704&&(f.$$scope={dirty:l,ctx:s}),i!==(i=s[5].unorderedlistitem||s[5].listitem)){if(e){oe();const c=e;k(c.$$.fragment,1,0,()=>{V(c,1)}),re()}i?(e=ie(i,r(s)),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}else i&&e.$set(f)},i(s){o||(e&&_(e.$$.fragment,s),o=!0)},o(s){e&&k(e.$$.fragment,s),o=!1},d(s){s&&h(n),e&&V(e,s)}}}function Vn(a){let e,n,o=a[6].items,t=[];for(let r=0;r<o.length;r+=1)t[r]=gt(ut(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&96){o=r[6].items;let l;for(l=0;l<o.length;l+=1){const f=ut(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=gt(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){$e(t,r),r&&h(e)}}}function On(a){let e,n,o;return e=new Pe({props:{tokens:a[18].tokens,renderers:a[5]}}),{c(){U(e.$$.fragment),n=q()},l(t){G(e.$$.fragment,t),n=Y(t)},m(t,i){N(e,t,i),A(t,n,i),o=!0},p(t,i){const r={};i&64&&(r.tokens=t[18].tokens),i&32&&(r.renderers=t[5]),e.$set(r)},i(t){o||(_(e.$$.fragment,t),o=!0)},o(t){k(e.$$.fragment,t),o=!1},d(t){V(e,t),t&&h(n)}}}function xt(a){let e,n,o;const t=[a[18]];var i=a[5].orderedlistitem||a[5].listitem;function r(s){let l={$$slots:{default:[On]},$$scope:{ctx:s}};for(let f=0;f<t.length;f+=1)l=Be(l,t[f]);return{props:l}}return i&&(e=ie(i,r(a))),{c(){e&&U(e.$$.fragment),n=K()},l(s){e&&G(e.$$.fragment,s),n=K()},m(s,l){e&&N(e,s,l),A(s,n,l),o=!0},p(s,l){const f=l&64?qe(t,[Ye(s[18])]):{};if(l&8388704&&(f.$$scope={dirty:l,ctx:s}),i!==(i=s[5].orderedlistitem||s[5].listitem)){if(e){oe();const c=e;k(c.$$.fragment,1,0,()=>{V(c,1)}),re()}i?(e=ie(i,r(s)),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}else i&&e.$set(f)},i(s){o||(e&&_(e.$$.fragment,s),o=!0)},o(s){e&&k(e.$$.fragment,s),o=!1},d(s){s&&h(n),e&&V(e,s)}}}function Hn(a){let e,n,o=a[6].items,t=[];for(let r=0;r<o.length;r+=1)t[r]=xt(pt(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&96){o=r[6].items;let l;for(l=0;l<o.length;l+=1){const f=pt(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=xt(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){$e(t,r),r&&h(e)}}}function Kn(a){let e,n,o;return e=new Pe({props:{tokens:a[16].tokens,renderers:a[5]}}),{c(){U(e.$$.fragment),n=q()},l(t){G(e.$$.fragment,t),n=Y(t)},m(t,i){N(e,t,i),A(t,n,i),o=!0},p(t,i){const r={};i&4&&(r.tokens=t[16].tokens),i&32&&(r.renderers=t[5]),e.$set(r)},i(t){o||(_(e.$$.fragment,t),o=!0)},o(t){k(e.$$.fragment,t),o=!1},d(t){V(e,t),t&&h(n)}}}function _t(a){let e,n,o;var t=a[5].tablecell;function i(r){return{props:{header:!0,align:r[6].align[r[15]]||"center",$$slots:{default:[Kn]},$$scope:{ctx:r}}}}return t&&(e=ie(t,i(a))),{c(){e&&U(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&N(e,r,s),A(r,n,s),o=!0},p(r,s){const l={};if(s&64&&(l.align=r[6].align[r[15]]||"center"),s&8388644&&(l.$$scope={dirty:s,ctx:r}),t!==(t=r[5].tablecell)){if(e){oe();const f=e;k(f.$$.fragment,1,0,()=>{V(f,1)}),re()}t?(e=ie(t,i(r)),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}else t&&e.$set(l)},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&V(e,r)}}}function qn(a){let e,n,o=a[2],t=[];for(let r=0;r<o.length;r+=1)t[r]=_t(ht(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&100){o=r[2];let l;for(l=0;l<o.length;l+=1){const f=ht(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=_t(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){$e(t,r),r&&h(e)}}}function Yn(a){let e,n,o;var t=a[5].tablerow;function i(r){return{props:{$$slots:{default:[qn]},$$scope:{ctx:r}}}}return t&&(e=ie(t,i(a))),{c(){e&&U(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&N(e,r,s),A(r,n,s),o=!0},p(r,s){const l={};if(s&8388708&&(l.$$scope={dirty:s,ctx:r}),t!==(t=r[5].tablerow)){if(e){oe();const f=e;k(f.$$.fragment,1,0,()=>{V(f,1)}),re()}t?(e=ie(t,i(r)),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}else t&&e.$set(l)},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&V(e,r)}}}function Gn(a){let e,n;return e=new Pe({props:{tokens:a[13].tokens,renderers:a[5]}}),{c(){U(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){N(e,o,t),n=!0},p(o,t){const i={};t&8&&(i.tokens=o[13].tokens),t&32&&(i.renderers=o[5]),e.$set(i)},i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){V(e,o)}}}function bt(a){let e,n,o;var t=a[5].tablecell;function i(r){return{props:{header:!1,align:r[6].align[r[15]]||"center",$$slots:{default:[Gn]},$$scope:{ctx:r}}}}return t&&(e=ie(t,i(a))),{c(){e&&U(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&N(e,r,s),A(r,n,s),o=!0},p(r,s){const l={};if(s&64&&(l.align=r[6].align[r[15]]||"center"),s&8388648&&(l.$$scope={dirty:s,ctx:r}),t!==(t=r[5].tablecell)){if(e){oe();const f=e;k(f.$$.fragment,1,0,()=>{V(f,1)}),re()}t?(e=ie(t,i(r)),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}else t&&e.$set(l)},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&V(e,r)}}}function Wn(a){let e,n,o=a[10],t=[];for(let r=0;r<o.length;r+=1)t[r]=bt(dt(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=q()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=Y(r)},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&104){o=r[10];let l;for(l=0;l<o.length;l+=1){const f=dt(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=bt(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){$e(t,r),r&&h(e)}}}function wt(a){let e,n,o;var t=a[5].tablerow;function i(r){return{props:{$$slots:{default:[Wn]},$$scope:{ctx:r}}}}return t&&(e=ie(t,i(a))),{c(){e&&U(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&N(e,r,s),A(r,n,s),o=!0},p(r,s){const l={};if(s&8388712&&(l.$$scope={dirty:s,ctx:r}),t!==(t=r[5].tablerow)){if(e){oe();const f=e;k(f.$$.fragment,1,0,()=>{V(f,1)}),re()}t?(e=ie(t,i(r)),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}else t&&e.$set(l)},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&V(e,r)}}}function Xn(a){let e,n,o=a[3],t=[];for(let r=0;r<o.length;r+=1)t[r]=wt(mt(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&104){o=r[3];let l;for(l=0;l<o.length;l+=1){const f=mt(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=wt(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){$e(t,r),r&&h(e)}}}function jn(a){let e,n,o,t,i;var r=a[5].tablehead;function s(c){return{props:{$$slots:{default:[Yn]},$$scope:{ctx:c}}}}r&&(e=ie(r,s(a)));var l=a[5].tablebody;function f(c){return{props:{$$slots:{default:[Xn]},$$scope:{ctx:c}}}}return l&&(o=ie(l,f(a))),{c(){e&&U(e.$$.fragment),n=q(),o&&U(o.$$.fragment),t=K()},l(c){e&&G(e.$$.fragment,c),n=Y(c),o&&G(o.$$.fragment,c),t=K()},m(c,u){e&&N(e,c,u),A(c,n,u),o&&N(o,c,u),A(c,t,u),i=!0},p(c,u){const p={};if(u&8388708&&(p.$$scope={dirty:u,ctx:c}),r!==(r=c[5].tablehead)){if(e){oe();const d=e;k(d.$$.fragment,1,0,()=>{V(d,1)}),re()}r?(e=ie(r,s(c)),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}else r&&e.$set(p);const m={};if(u&8388712&&(m.$$scope={dirty:u,ctx:c}),l!==(l=c[5].tablebody)){if(o){oe();const d=o;k(d.$$.fragment,1,0,()=>{V(d,1)}),re()}l?(o=ie(l,f(c)),U(o.$$.fragment),_(o.$$.fragment,1),N(o,t.parentNode,t)):o=null}else l&&o.$set(m)},i(c){i||(e&&_(e.$$.fragment,c),o&&_(o.$$.fragment,c),i=!0)},o(c){e&&k(e.$$.fragment,c),o&&k(o.$$.fragment,c),i=!1},d(c){e&&V(e,c),c&&h(n),c&&h(t),o&&V(o,c)}}}function $t(a){let e,n;const o=[a[7],{renderers:a[5]}];let t={};for(let i=0;i<o.length;i+=1)t=Be(t,o[i]);return e=new Pe({props:t}),{c(){U(e.$$.fragment)},l(i){G(e.$$.fragment,i)},m(i,r){N(e,i,r),n=!0},p(i,r){const s=r&34?qe(o,[r&2&&Ye(i[7]),r&32&&{renderers:i[5]}]):{};e.$set(s)},i(i){n||(_(e.$$.fragment,i),n=!0)},o(i){k(e.$$.fragment,i),n=!1},d(i){V(e,i)}}}function Zn(a){let e,n,o,t;const i=[Cn,Bn],r=[];function s(l,f){return l[0]?l[5][l[0]]?1:-1:0}return~(e=s(a))&&(n=r[e]=i[e](a)),{c(){n&&n.c(),o=K()},l(l){n&&n.l(l),o=K()},m(l,f){~e&&r[e].m(l,f),A(l,o,f),t=!0},p(l,[f]){let c=e;e=s(l),e===c?~e&&r[e].p(l,f):(n&&(oe(),k(r[c],1,1,()=>{r[c]=null}),re()),~e?(n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o)):n=null)},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){~e&&r[e].d(l),l&&h(o)}}}function Qn(a,e,n){const o=["type","tokens","header","rows","ordered","renderers"];let t=ct(e,o),{type:i=void 0}=e,{tokens:r=void 0}=e,{header:s=void 0}=e,{rows:l=void 0}=e,{ordered:f=!1}=e,{renderers:c}=e;return zn(),a.$$set=u=>{e=Be(Be({},e),yn(u)),n(6,t=ct(e,o)),"type"in u&&n(0,i=u.type),"tokens"in u&&n(1,r=u.tokens),"header"in u&&n(2,s=u.header),"rows"in u&&n(3,l=u.rows),"ordered"in u&&n(4,f=u.ordered),"renderers"in u&&n(5,c=u.renderers)},[i,r,s,l,f,c,t]}let Pe=class extends Q{constructor(e){super(),J(this,e,Qn,Zn,ee,{type:0,tokens:1,header:2,rows:3,ordered:4,renderers:5})}};function an(){return{async:!1,baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,hooks:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1}}let Fe=an();function Jn(a){Fe=a}const ln=/[&<>"']/,e0=new RegExp(ln.source,"g"),sn=/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,t0=new RegExp(sn.source,"g"),n0={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},kt=a=>n0[a];function be(a,e){if(e){if(ln.test(a))return a.replace(e0,kt)}else if(sn.test(a))return a.replace(t0,kt);return a}const o0=/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;function fn(a){return a.replace(o0,(e,n)=>(n=n.toLowerCase(),n==="colon"?":":n.charAt(0)==="#"?n.charAt(1)==="x"?String.fromCharCode(parseInt(n.substring(2),16)):String.fromCharCode(+n.substring(1)):""))}const r0=/(^|[^\[])\^/g;function le(a,e){a=typeof a=="string"?a:a.source,e=e||"";const n={replace:(o,t)=>(t=t.source||t,t=t.replace(r0,"$1"),a=a.replace(o,t),n),getRegex:()=>new RegExp(a,e)};return n}const i0=/[^\w:]/g,a0=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;function yt(a,e,n){if(a){let o;try{o=decodeURIComponent(fn(n)).replace(i0,"").toLowerCase()}catch{return null}if(o.indexOf("javascript:")===0||o.indexOf("vbscript:")===0||o.indexOf("data:")===0)return null}e&&!a0.test(n)&&(n=c0(e,n));try{n=encodeURI(n).replace(/%25/g,"%")}catch{return null}return n}const Qe={},l0=/^[^:]+:\/*[^/]*$/,s0=/^([^:]+:)[\s\S]*$/,f0=/^([^:]+:\/*[^/]*)[\s\S]*$/;function c0(a,e){Qe[" "+a]||(l0.test(a)?Qe[" "+a]=a+"/":Qe[" "+a]=Je(a,"/",!0)),a=Qe[" "+a];const n=a.indexOf(":")===-1;return e.substring(0,2)==="//"?n?e:a.replace(s0,"$1")+e:e.charAt(0)==="/"?n?e:a.replace(f0,"$1")+e:a+e}const tt={exec:function(){}};function St(a,e){const n=a.replace(/\|/g,(i,r,s)=>{let l=!1,f=r;for(;--f>=0&&s[f]==="\\";)l=!l;return l?"|":" |"}),o=n.split(/ \|/);let t=0;if(o[0].trim()||o.shift(),o.length>0&&!o[o.length-1].trim()&&o.pop(),o.length>e)o.splice(e);else for(;o.length<e;)o.push("");for(;t<o.length;t++)o[t]=o[t].trim().replace(/\\\|/g,"|");return o}function Je(a,e,n){const o=a.length;if(o===0)return"";let t=0;for(;t<o;){const i=a.charAt(o-t-1);if(i===e&&!n)t++;else if(i!==e&&n)t++;else break}return a.slice(0,o-t)}function u0(a,e){if(a.indexOf(e[1])===-1)return-1;const n=a.length;let o=0,t=0;for(;t<n;t++)if(a[t]==="\\")t++;else if(a[t]===e[0])o++;else if(a[t]===e[1]&&(o--,o<0))return t;return-1}function p0(a){a&&a.sanitize&&!a.silent&&console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options")}function Et(a,e){if(e<1)return"";let n="";for(;e>1;)e&1&&(n+=a),e>>=1,a+=a;return n+a}function At(a,e,n,o){const t=e.href,i=e.title?be(e.title):null,r=a[1].replace(/\\([\[\]])/g,"$1");if(a[0].charAt(0)!=="!"){o.state.inLink=!0;const s={type:"link",raw:n,href:t,title:i,text:r,tokens:o.inlineTokens(r)};return o.state.inLink=!1,s}return{type:"image",raw:n,href:t,title:i,text:be(r)}}function m0(a,e){const n=a.match(/^(\s+)(?:```)/);if(n===null)return e;const o=n[1];return e.split(`
`).map(t=>{const i=t.match(/^\s+/);if(i===null)return t;const[r]=i;return r.length>=o.length?t.slice(o.length):t}).join(`
`)}class lt{constructor(e){this.options=e||Fe}space(e){const n=this.rules.block.newline.exec(e);if(n&&n[0].length>0)return{type:"space",raw:n[0]}}code(e){const n=this.rules.block.code.exec(e);if(n){const o=n[0].replace(/^ {1,4}/gm,"");return{type:"code",raw:n[0],codeBlockStyle:"indented",text:this.options.pedantic?o:Je(o,`
`)}}}fences(e){const n=this.rules.block.fences.exec(e);if(n){const o=n[0],t=m0(o,n[3]||"");return{type:"code",raw:o,lang:n[2]?n[2].trim().replace(this.rules.inline._escapes,"$1"):n[2],text:t}}}heading(e){const n=this.rules.block.heading.exec(e);if(n){let o=n[2].trim();if(/#$/.test(o)){const t=Je(o,"#");(this.options.pedantic||!t||/ $/.test(t))&&(o=t.trim())}return{type:"heading",raw:n[0],depth:n[1].length,text:o,tokens:this.lexer.inline(o)}}}hr(e){const n=this.rules.block.hr.exec(e);if(n)return{type:"hr",raw:n[0]}}blockquote(e){const n=this.rules.block.blockquote.exec(e);if(n){const o=n[0].replace(/^ *>[ \t]?/gm,""),t=this.lexer.state.top;this.lexer.state.top=!0;const i=this.lexer.blockTokens(o);return this.lexer.state.top=t,{type:"blockquote",raw:n[0],tokens:i,text:o}}}list(e){let n=this.rules.block.list.exec(e);if(n){let o,t,i,r,s,l,f,c,u,p,m,d,x=n[1].trim();const C=x.length>1,E={type:"list",raw:"",ordered:C,start:C?+x.slice(0,-1):"",loose:!1,items:[]};x=C?`\\d{1,9}\\${x.slice(-1)}`:`\\${x}`,this.options.pedantic&&(x=C?x:"[*+-]");const S=new RegExp(`^( {0,3}${x})((?:[	 ][^\\n]*)?(?:\\n|$))`);for(;e&&(d=!1,!(!(n=S.exec(e))||this.rules.block.hr.test(e)));){if(o=n[0],e=e.substring(o.length),c=n[2].split(`
`,1)[0].replace(/^\t+/,v=>" ".repeat(3*v.length)),u=e.split(`
`,1)[0],this.options.pedantic?(r=2,m=c.trimLeft()):(r=n[2].search(/[^ ]/),r=r>4?1:r,m=c.slice(r),r+=n[1].length),l=!1,!c&&/^ *$/.test(u)&&(o+=u+`
`,e=e.substring(u.length+1),d=!0),!d){const v=new RegExp(`^ {0,${Math.min(3,r-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),g=new RegExp(`^ {0,${Math.min(3,r-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),$=new RegExp(`^ {0,${Math.min(3,r-1)}}(?:\`\`\`|~~~)`),L=new RegExp(`^ {0,${Math.min(3,r-1)}}#`);for(;e&&(p=e.split(`
`,1)[0],u=p,this.options.pedantic&&(u=u.replace(/^ {1,4}(?=( {4})*[^ ])/g,"  ")),!($.test(u)||L.test(u)||v.test(u)||g.test(e)));){if(u.search(/[^ ]/)>=r||!u.trim())m+=`
`+u.slice(r);else{if(l||c.search(/[^ ]/)>=4||$.test(c)||L.test(c)||g.test(c))break;m+=`
`+u}!l&&!u.trim()&&(l=!0),o+=p+`
`,e=e.substring(p.length+1),c=u.slice(r)}}E.loose||(f?E.loose=!0:/\n *\n *$/.test(o)&&(f=!0)),this.options.gfm&&(t=/^\[[ xX]\] /.exec(m),t&&(i=t[0]!=="[ ] ",m=m.replace(/^\[[ xX]\] +/,""))),E.items.push({type:"list_item",raw:o,task:!!t,checked:i,loose:!1,text:m}),E.raw+=o}E.items[E.items.length-1].raw=o.trimRight(),E.items[E.items.length-1].text=m.trimRight(),E.raw=E.raw.trimRight();const M=E.items.length;for(s=0;s<M;s++)if(this.lexer.state.top=!1,E.items[s].tokens=this.lexer.blockTokens(E.items[s].text,[]),!E.loose){const v=E.items[s].tokens.filter($=>$.type==="space"),g=v.length>0&&v.some($=>/\n.*\n/.test($.raw));E.loose=g}if(E.loose)for(s=0;s<M;s++)E.items[s].loose=!0;return E}}html(e){const n=this.rules.block.html.exec(e);if(n){const o={type:"html",raw:n[0],pre:!this.options.sanitizer&&(n[1]==="pre"||n[1]==="script"||n[1]==="style"),text:n[0]};if(this.options.sanitize){const t=this.options.sanitizer?this.options.sanitizer(n[0]):be(n[0]);o.type="paragraph",o.text=t,o.tokens=this.lexer.inline(t)}return o}}def(e){const n=this.rules.block.def.exec(e);if(n){const o=n[1].toLowerCase().replace(/\s+/g," "),t=n[2]?n[2].replace(/^<(.*)>$/,"$1").replace(this.rules.inline._escapes,"$1"):"",i=n[3]?n[3].substring(1,n[3].length-1).replace(this.rules.inline._escapes,"$1"):n[3];return{type:"def",tag:o,raw:n[0],href:t,title:i}}}table(e){const n=this.rules.block.table.exec(e);if(n){const o={type:"table",header:St(n[1]).map(t=>({text:t})),align:n[2].replace(/^ *|\| *$/g,"").split(/ *\| */),rows:n[3]&&n[3].trim()?n[3].replace(/\n[ \t]*$/,"").split(`
`):[]};if(o.header.length===o.align.length){o.raw=n[0];let t=o.align.length,i,r,s,l;for(i=0;i<t;i++)/^ *-+: *$/.test(o.align[i])?o.align[i]="right":/^ *:-+: *$/.test(o.align[i])?o.align[i]="center":/^ *:-+ *$/.test(o.align[i])?o.align[i]="left":o.align[i]=null;for(t=o.rows.length,i=0;i<t;i++)o.rows[i]=St(o.rows[i],o.header.length).map(f=>({text:f}));for(t=o.header.length,r=0;r<t;r++)o.header[r].tokens=this.lexer.inline(o.header[r].text);for(t=o.rows.length,r=0;r<t;r++)for(l=o.rows[r],s=0;s<l.length;s++)l[s].tokens=this.lexer.inline(l[s].text);return o}}}lheading(e){const n=this.rules.block.lheading.exec(e);if(n)return{type:"heading",raw:n[0],depth:n[2].charAt(0)==="="?1:2,text:n[1],tokens:this.lexer.inline(n[1])}}paragraph(e){const n=this.rules.block.paragraph.exec(e);if(n){const o=n[1].charAt(n[1].length-1)===`
`?n[1].slice(0,-1):n[1];return{type:"paragraph",raw:n[0],text:o,tokens:this.lexer.inline(o)}}}text(e){const n=this.rules.block.text.exec(e);if(n)return{type:"text",raw:n[0],text:n[0],tokens:this.lexer.inline(n[0])}}escape(e){const n=this.rules.inline.escape.exec(e);if(n)return{type:"escape",raw:n[0],text:be(n[1])}}tag(e){const n=this.rules.inline.tag.exec(e);if(n)return!this.lexer.state.inLink&&/^<a /i.test(n[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&/^<\/a>/i.test(n[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(n[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(n[0])&&(this.lexer.state.inRawBlock=!1),{type:this.options.sanitize?"text":"html",raw:n[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,text:this.options.sanitize?this.options.sanitizer?this.options.sanitizer(n[0]):be(n[0]):n[0]}}link(e){const n=this.rules.inline.link.exec(e);if(n){const o=n[2].trim();if(!this.options.pedantic&&/^</.test(o)){if(!/>$/.test(o))return;const r=Je(o.slice(0,-1),"\\");if((o.length-r.length)%2===0)return}else{const r=u0(n[2],"()");if(r>-1){const l=(n[0].indexOf("!")===0?5:4)+n[1].length+r;n[2]=n[2].substring(0,r),n[0]=n[0].substring(0,l).trim(),n[3]=""}}let t=n[2],i="";if(this.options.pedantic){const r=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(t);r&&(t=r[1],i=r[3])}else i=n[3]?n[3].slice(1,-1):"";return t=t.trim(),/^</.test(t)&&(this.options.pedantic&&!/>$/.test(o)?t=t.slice(1):t=t.slice(1,-1)),At(n,{href:t&&t.replace(this.rules.inline._escapes,"$1"),title:i&&i.replace(this.rules.inline._escapes,"$1")},n[0],this.lexer)}}reflink(e,n){let o;if((o=this.rules.inline.reflink.exec(e))||(o=this.rules.inline.nolink.exec(e))){let t=(o[2]||o[1]).replace(/\s+/g," ");if(t=n[t.toLowerCase()],!t){const i=o[0].charAt(0);return{type:"text",raw:i,text:i}}return At(o,t,o[0],this.lexer)}}emStrong(e,n,o=""){let t=this.rules.inline.emStrong.lDelim.exec(e);if(!t||t[3]&&o.match(/[\p{L}\p{N}]/u))return;const i=t[1]||t[2]||"";if(!i||i&&(o===""||this.rules.inline.punctuation.exec(o))){const r=t[0].length-1;let s,l,f=r,c=0;const u=t[0][0]==="*"?this.rules.inline.emStrong.rDelimAst:this.rules.inline.emStrong.rDelimUnd;for(u.lastIndex=0,n=n.slice(-1*e.length+r);(t=u.exec(n))!=null;){if(s=t[1]||t[2]||t[3]||t[4]||t[5]||t[6],!s)continue;if(l=s.length,t[3]||t[4]){f+=l;continue}else if((t[5]||t[6])&&r%3&&!((r+l)%3)){c+=l;continue}if(f-=l,f>0)continue;l=Math.min(l,l+f+c);const p=e.slice(0,r+t.index+(t[0].length-s.length)+l);if(Math.min(r,l)%2){const d=p.slice(1,-1);return{type:"em",raw:p,text:d,tokens:this.lexer.inlineTokens(d)}}const m=p.slice(2,-2);return{type:"strong",raw:p,text:m,tokens:this.lexer.inlineTokens(m)}}}}codespan(e){const n=this.rules.inline.code.exec(e);if(n){let o=n[2].replace(/\n/g," ");const t=/[^ ]/.test(o),i=/^ /.test(o)&&/ $/.test(o);return t&&i&&(o=o.substring(1,o.length-1)),o=be(o,!0),{type:"codespan",raw:n[0],text:o}}}br(e){const n=this.rules.inline.br.exec(e);if(n)return{type:"br",raw:n[0]}}del(e){const n=this.rules.inline.del.exec(e);if(n)return{type:"del",raw:n[0],text:n[2],tokens:this.lexer.inlineTokens(n[2])}}autolink(e,n){const o=this.rules.inline.autolink.exec(e);if(o){let t,i;return o[2]==="@"?(t=be(this.options.mangle?n(o[1]):o[1]),i="mailto:"+t):(t=be(o[1]),i=t),{type:"link",raw:o[0],text:t,href:i,tokens:[{type:"text",raw:t,text:t}]}}}url(e,n){let o;if(o=this.rules.inline.url.exec(e)){let t,i;if(o[2]==="@")t=be(this.options.mangle?n(o[0]):o[0]),i="mailto:"+t;else{let r;do r=o[0],o[0]=this.rules.inline._backpedal.exec(o[0])[0];while(r!==o[0]);t=be(o[0]),o[1]==="www."?i="http://"+o[0]:i=o[0]}return{type:"link",raw:o[0],text:t,href:i,tokens:[{type:"text",raw:t,text:t}]}}}inlineText(e,n){const o=this.rules.inline.text.exec(e);if(o){let t;return this.lexer.state.inRawBlock?t=this.options.sanitize?this.options.sanitizer?this.options.sanitizer(o[0]):be(o[0]):o[0]:t=be(this.options.smartypants?n(o[0]):o[0]),{type:"text",raw:o[0],text:t}}}}const W={newline:/^(?: *(?:\n|$))+/,code:/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,fences:/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,hr:/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,heading:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,html:"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",def:/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,table:tt,lheading:/^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,_paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,text:/^[^\n]+/};W._label=/(?!\s*\])(?:\\.|[^\[\]\\])+/;W._title=/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;W.def=le(W.def).replace("label",W._label).replace("title",W._title).getRegex();W.bullet=/(?:[*+-]|\d{1,9}[.)])/;W.listItemStart=le(/^( *)(bull) */).replace("bull",W.bullet).getRegex();W.list=le(W.list).replace(/bull/g,W.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+W.def.source+")").getRegex();W._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";W._comment=/<!--(?!-?>)[\s\S]*?(?:-->|$)/;W.html=le(W.html,"i").replace("comment",W._comment).replace("tag",W._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();W.paragraph=le(W._paragraph).replace("hr",W.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",W._tag).getRegex();W.blockquote=le(W.blockquote).replace("paragraph",W.paragraph).getRegex();W.normal={...W};W.gfm={...W.normal,table:"^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"};W.gfm.table=le(W.gfm.table).replace("hr",W.hr).replace("heading"," {0,3}#{1,6} ").replace("blockquote"," {0,3}>").replace("code"," {4}[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",W._tag).getRegex();W.gfm.paragraph=le(W._paragraph).replace("hr",W.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("table",W.gfm.table).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",W._tag).getRegex();W.pedantic={...W.normal,html:le(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",W._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:tt,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:le(W.normal._paragraph).replace("hr",W.hr).replace("heading",` *#{1,6} *[^
]`).replace("lheading",W.lheading).replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").getRegex()};const H={escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:tt,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(ref)\]/,nolink:/^!?\[(ref)\](?:\[\])?/,reflinkSearch:"reflink|nolink(?!\\()",emStrong:{lDelim:/^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,rDelimAst:/^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,rDelimUnd:/^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/},code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br:/^( {2,}|\\)\n(?!\s*$)/,del:tt,text:/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,punctuation:/^([\spunctuation])/};H._punctuation="!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";H.punctuation=le(H.punctuation).replace(/punctuation/g,H._punctuation).getRegex();H.blockSkip=/\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;H.escapedEmSt=/(?:^|[^\\])(?:\\\\)*\\[*_]/g;H._comment=le(W._comment).replace("(?:-->|$)","-->").getRegex();H.emStrong.lDelim=le(H.emStrong.lDelim).replace(/punct/g,H._punctuation).getRegex();H.emStrong.rDelimAst=le(H.emStrong.rDelimAst,"g").replace(/punct/g,H._punctuation).getRegex();H.emStrong.rDelimUnd=le(H.emStrong.rDelimUnd,"g").replace(/punct/g,H._punctuation).getRegex();H._escapes=/\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;H._scheme=/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;H._email=/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;H.autolink=le(H.autolink).replace("scheme",H._scheme).replace("email",H._email).getRegex();H._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;H.tag=le(H.tag).replace("comment",H._comment).replace("attribute",H._attribute).getRegex();H._label=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;H._href=/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;H._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;H.link=le(H.link).replace("label",H._label).replace("href",H._href).replace("title",H._title).getRegex();H.reflink=le(H.reflink).replace("label",H._label).replace("ref",W._label).getRegex();H.nolink=le(H.nolink).replace("ref",W._label).getRegex();H.reflinkSearch=le(H.reflinkSearch,"g").replace("reflink",H.reflink).replace("nolink",H.nolink).getRegex();H.normal={...H};H.pedantic={...H.normal,strong:{start:/^__|\*\*/,middle:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,endAst:/\*\*(?!\*)/g,endUnd:/__(?!_)/g},em:{start:/^_|\*/,middle:/^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,endAst:/\*(?!\*)/g,endUnd:/_(?!_)/g},link:le(/^!?\[(label)\]\((.*?)\)/).replace("label",H._label).getRegex(),reflink:le(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",H._label).getRegex()};H.gfm={...H.normal,escape:le(H.escape).replace("])","~|])").getRegex(),_extended_email:/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,url:/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/};H.gfm.url=le(H.gfm.url,"i").replace("email",H.gfm._extended_email).getRegex();H.breaks={...H.gfm,br:le(H.br).replace("{2,}","*").getRegex(),text:le(H.gfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()};function d0(a){return a.replace(/---/g,"—").replace(/--/g,"–").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1‘").replace(/'/g,"’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1“").replace(/"/g,"”").replace(/\.{3}/g,"…")}function Dt(a){let e="",n,o;const t=a.length;for(n=0;n<t;n++)o=a.charCodeAt(n),Math.random()>.5&&(o="x"+o.toString(16)),e+="&#"+o+";";return e}class De{constructor(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||Fe,this.options.tokenizer=this.options.tokenizer||new lt,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};const n={block:W.normal,inline:H.normal};this.options.pedantic?(n.block=W.pedantic,n.inline=H.pedantic):this.options.gfm&&(n.block=W.gfm,this.options.breaks?n.inline=H.breaks:n.inline=H.gfm),this.tokenizer.rules=n}static get rules(){return{block:W,inline:H}}static lex(e,n){return new De(n).lex(e)}static lexInline(e,n){return new De(n).inlineTokens(e)}lex(e){e=e.replace(/\r\n|\r/g,`
`),this.blockTokens(e,this.tokens);let n;for(;n=this.inlineQueue.shift();)this.inlineTokens(n.src,n.tokens);return this.tokens}blockTokens(e,n=[]){this.options.pedantic?e=e.replace(/\t/g,"    ").replace(/^ +$/gm,""):e=e.replace(/^( *)(\t+)/gm,(s,l,f)=>l+"    ".repeat(f.length));let o,t,i,r;for(;e;)if(!(this.options.extensions&&this.options.extensions.block&&this.options.extensions.block.some(s=>(o=s.call({lexer:this},e,n))?(e=e.substring(o.raw.length),n.push(o),!0):!1))){if(o=this.tokenizer.space(e)){e=e.substring(o.raw.length),o.raw.length===1&&n.length>0?n[n.length-1].raw+=`
`:n.push(o);continue}if(o=this.tokenizer.code(e)){e=e.substring(o.raw.length),t=n[n.length-1],t&&(t.type==="paragraph"||t.type==="text")?(t.raw+=`
`+o.raw,t.text+=`
`+o.text,this.inlineQueue[this.inlineQueue.length-1].src=t.text):n.push(o);continue}if(o=this.tokenizer.fences(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.heading(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.hr(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.blockquote(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.list(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.html(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.def(e)){e=e.substring(o.raw.length),t=n[n.length-1],t&&(t.type==="paragraph"||t.type==="text")?(t.raw+=`
`+o.raw,t.text+=`
`+o.raw,this.inlineQueue[this.inlineQueue.length-1].src=t.text):this.tokens.links[o.tag]||(this.tokens.links[o.tag]={href:o.href,title:o.title});continue}if(o=this.tokenizer.table(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.lheading(e)){e=e.substring(o.raw.length),n.push(o);continue}if(i=e,this.options.extensions&&this.options.extensions.startBlock){let s=1/0;const l=e.slice(1);let f;this.options.extensions.startBlock.forEach(function(c){f=c.call({lexer:this},l),typeof f=="number"&&f>=0&&(s=Math.min(s,f))}),s<1/0&&s>=0&&(i=e.substring(0,s+1))}if(this.state.top&&(o=this.tokenizer.paragraph(i))){t=n[n.length-1],r&&t.type==="paragraph"?(t.raw+=`
`+o.raw,t.text+=`
`+o.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=t.text):n.push(o),r=i.length!==e.length,e=e.substring(o.raw.length);continue}if(o=this.tokenizer.text(e)){e=e.substring(o.raw.length),t=n[n.length-1],t&&t.type==="text"?(t.raw+=`
`+o.raw,t.text+=`
`+o.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=t.text):n.push(o);continue}if(e){const s="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(s);break}else throw new Error(s)}}return this.state.top=!0,n}inline(e,n=[]){return this.inlineQueue.push({src:e,tokens:n}),n}inlineTokens(e,n=[]){let o,t,i,r=e,s,l,f;if(this.tokens.links){const c=Object.keys(this.tokens.links);if(c.length>0)for(;(s=this.tokenizer.rules.inline.reflinkSearch.exec(r))!=null;)c.includes(s[0].slice(s[0].lastIndexOf("[")+1,-1))&&(r=r.slice(0,s.index)+"["+Et("a",s[0].length-2)+"]"+r.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;(s=this.tokenizer.rules.inline.blockSkip.exec(r))!=null;)r=r.slice(0,s.index)+"["+Et("a",s[0].length-2)+"]"+r.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;(s=this.tokenizer.rules.inline.escapedEmSt.exec(r))!=null;)r=r.slice(0,s.index+s[0].length-2)+"++"+r.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex),this.tokenizer.rules.inline.escapedEmSt.lastIndex--;for(;e;)if(l||(f=""),l=!1,!(this.options.extensions&&this.options.extensions.inline&&this.options.extensions.inline.some(c=>(o=c.call({lexer:this},e,n))?(e=e.substring(o.raw.length),n.push(o),!0):!1))){if(o=this.tokenizer.escape(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.tag(e)){e=e.substring(o.raw.length),t=n[n.length-1],t&&o.type==="text"&&t.type==="text"?(t.raw+=o.raw,t.text+=o.text):n.push(o);continue}if(o=this.tokenizer.link(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.reflink(e,this.tokens.links)){e=e.substring(o.raw.length),t=n[n.length-1],t&&o.type==="text"&&t.type==="text"?(t.raw+=o.raw,t.text+=o.text):n.push(o);continue}if(o=this.tokenizer.emStrong(e,r,f)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.codespan(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.br(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.del(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.autolink(e,Dt)){e=e.substring(o.raw.length),n.push(o);continue}if(!this.state.inLink&&(o=this.tokenizer.url(e,Dt))){e=e.substring(o.raw.length),n.push(o);continue}if(i=e,this.options.extensions&&this.options.extensions.startInline){let c=1/0;const u=e.slice(1);let p;this.options.extensions.startInline.forEach(function(m){p=m.call({lexer:this},u),typeof p=="number"&&p>=0&&(c=Math.min(c,p))}),c<1/0&&c>=0&&(i=e.substring(0,c+1))}if(o=this.tokenizer.inlineText(i,d0)){e=e.substring(o.raw.length),o.raw.slice(-1)!=="_"&&(f=o.raw.slice(-1)),l=!0,t=n[n.length-1],t&&t.type==="text"?(t.raw+=o.raw,t.text+=o.text):n.push(o);continue}if(e){const c="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(c);break}else throw new Error(c)}}return n}}class st{constructor(e){this.options=e||Fe}code(e,n,o){const t=(n||"").match(/\S*/)[0];if(this.options.highlight){const i=this.options.highlight(e,t);i!=null&&i!==e&&(o=!0,e=i)}return e=e.replace(/\n$/,"")+`
`,t?'<pre><code class="'+this.options.langPrefix+be(t)+'">'+(o?e:be(e,!0))+`</code></pre>
`:"<pre><code>"+(o?e:be(e,!0))+`</code></pre>
`}blockquote(e){return`<blockquote>
${e}</blockquote>
`}html(e){return e}heading(e,n,o,t){if(this.options.headerIds){const i=this.options.headerPrefix+t.slug(o);return`<h${n} id="${i}">${e}</h${n}>
`}return`<h${n}>${e}</h${n}>
`}hr(){return this.options.xhtml?`<hr/>
`:`<hr>
`}list(e,n,o){const t=n?"ol":"ul",i=n&&o!==1?' start="'+o+'"':"";return"<"+t+i+`>
`+e+"</"+t+`>
`}listitem(e){return`<li>${e}</li>
`}checkbox(e){return"<input "+(e?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "}paragraph(e){return`<p>${e}</p>
`}table(e,n){return n&&(n=`<tbody>${n}</tbody>`),`<table>
<thead>
`+e+`</thead>
`+n+`</table>
`}tablerow(e){return`<tr>
${e}</tr>
`}tablecell(e,n){const o=n.header?"th":"td";return(n.align?`<${o} align="${n.align}">`:`<${o}>`)+e+`</${o}>
`}strong(e){return`<strong>${e}</strong>`}em(e){return`<em>${e}</em>`}codespan(e){return`<code>${e}</code>`}br(){return this.options.xhtml?"<br/>":"<br>"}del(e){return`<del>${e}</del>`}link(e,n,o){if(e=yt(this.options.sanitize,this.options.baseUrl,e),e===null)return o;let t='<a href="'+e+'"';return n&&(t+=' title="'+n+'"'),t+=">"+o+"</a>",t}image(e,n,o){if(e=yt(this.options.sanitize,this.options.baseUrl,e),e===null)return o;let t=`<img src="${e}" alt="${o}"`;return n&&(t+=` title="${n}"`),t+=this.options.xhtml?"/>":">",t}text(e){return e}}class cn{strong(e){return e}em(e){return e}codespan(e){return e}del(e){return e}html(e){return e}text(e){return e}link(e,n,o){return""+o}image(e,n,o){return""+o}br(){return""}}class ft{constructor(){this.seen={}}serialize(e){return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig,"").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,"").replace(/\s/g,"-")}getNextSafeSlug(e,n){let o=e,t=0;if(this.seen.hasOwnProperty(o)){t=this.seen[e];do t++,o=e+"-"+t;while(this.seen.hasOwnProperty(o))}return n||(this.seen[e]=t,this.seen[o]=0),o}slug(e,n={}){const o=this.serialize(e);return this.getNextSafeSlug(o,n.dryrun)}}class Ce{constructor(e){this.options=e||Fe,this.options.renderer=this.options.renderer||new st,this.renderer=this.options.renderer,this.renderer.options=this.options,this.textRenderer=new cn,this.slugger=new ft}static parse(e,n){return new Ce(n).parse(e)}static parseInline(e,n){return new Ce(n).parseInline(e)}parse(e,n=!0){let o="",t,i,r,s,l,f,c,u,p,m,d,x,C,E,S,M,v,g,$;const L=e.length;for(t=0;t<L;t++){if(m=e[t],this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[m.type]&&($=this.options.extensions.renderers[m.type].call({parser:this},m),$!==!1||!["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(m.type))){o+=$||"";continue}switch(m.type){case"space":continue;case"hr":{o+=this.renderer.hr();continue}case"heading":{o+=this.renderer.heading(this.parseInline(m.tokens),m.depth,fn(this.parseInline(m.tokens,this.textRenderer)),this.slugger);continue}case"code":{o+=this.renderer.code(m.text,m.lang,m.escaped);continue}case"table":{for(u="",c="",s=m.header.length,i=0;i<s;i++)c+=this.renderer.tablecell(this.parseInline(m.header[i].tokens),{header:!0,align:m.align[i]});for(u+=this.renderer.tablerow(c),p="",s=m.rows.length,i=0;i<s;i++){for(f=m.rows[i],c="",l=f.length,r=0;r<l;r++)c+=this.renderer.tablecell(this.parseInline(f[r].tokens),{header:!1,align:m.align[r]});p+=this.renderer.tablerow(c)}o+=this.renderer.table(u,p);continue}case"blockquote":{p=this.parse(m.tokens),o+=this.renderer.blockquote(p);continue}case"list":{for(d=m.ordered,x=m.start,C=m.loose,s=m.items.length,p="",i=0;i<s;i++)S=m.items[i],M=S.checked,v=S.task,E="",S.task&&(g=this.renderer.checkbox(M),C?S.tokens.length>0&&S.tokens[0].type==="paragraph"?(S.tokens[0].text=g+" "+S.tokens[0].text,S.tokens[0].tokens&&S.tokens[0].tokens.length>0&&S.tokens[0].tokens[0].type==="text"&&(S.tokens[0].tokens[0].text=g+" "+S.tokens[0].tokens[0].text)):S.tokens.unshift({type:"text",text:g}):E+=g),E+=this.parse(S.tokens,C),p+=this.renderer.listitem(E,v,M);o+=this.renderer.list(p,d,x);continue}case"html":{o+=this.renderer.html(m.text);continue}case"paragraph":{o+=this.renderer.paragraph(this.parseInline(m.tokens));continue}case"text":{for(p=m.tokens?this.parseInline(m.tokens):m.text;t+1<L&&e[t+1].type==="text";)m=e[++t],p+=`
`+(m.tokens?this.parseInline(m.tokens):m.text);o+=n?this.renderer.paragraph(p):p;continue}default:{const D='Token with "'+m.type+'" type was not found.';if(this.options.silent){console.error(D);return}else throw new Error(D)}}}return o}parseInline(e,n){n=n||this.renderer;let o="",t,i,r;const s=e.length;for(t=0;t<s;t++){if(i=e[t],this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[i.type]&&(r=this.options.extensions.renderers[i.type].call({parser:this},i),r!==!1||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(i.type))){o+=r||"";continue}switch(i.type){case"escape":{o+=n.text(i.text);break}case"html":{o+=n.html(i.text);break}case"link":{o+=n.link(i.href,i.title,this.parseInline(i.tokens,n));break}case"image":{o+=n.image(i.href,i.title,i.text);break}case"strong":{o+=n.strong(this.parseInline(i.tokens,n));break}case"em":{o+=n.em(this.parseInline(i.tokens,n));break}case"codespan":{o+=n.codespan(i.text);break}case"br":{o+=n.br();break}case"del":{o+=n.del(this.parseInline(i.tokens,n));break}case"text":{o+=n.text(i.text);break}default:{const l='Token with "'+i.type+'" type was not found.';if(this.options.silent){console.error(l);return}else throw new Error(l)}}}return o}}class ot{constructor(e){this.options=e||Fe}static passThroughHooks=new Set(["preprocess","postprocess"]);preprocess(e){return e}postprocess(e){return e}}function h0(a,e,n){return o=>{if(o.message+=`
Please report this to https://github.com/markedjs/marked.`,a){const t="<p>An error occurred:</p><pre>"+be(o.message+"",!0)+"</pre>";if(e)return Promise.resolve(t);if(n){n(null,t);return}return t}if(e)return Promise.reject(o);if(n){n(o);return}throw o}}function un(a,e){return(n,o,t)=>{typeof o=="function"&&(t=o,o=null);const i={...o};o={...j.defaults,...i};const r=h0(o.silent,o.async,t);if(typeof n>"u"||n===null)return r(new Error("marked(): input parameter is undefined or null"));if(typeof n!="string")return r(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected"));if(p0(o),o.hooks&&(o.hooks.options=o),t){const s=o.highlight;let l;try{o.hooks&&(n=o.hooks.preprocess(n)),l=a(n,o)}catch(u){return r(u)}const f=function(u){let p;if(!u)try{o.walkTokens&&j.walkTokens(l,o.walkTokens),p=e(l,o),o.hooks&&(p=o.hooks.postprocess(p))}catch(m){u=m}return o.highlight=s,u?r(u):t(null,p)};if(!s||s.length<3||(delete o.highlight,!l.length))return f();let c=0;j.walkTokens(l,function(u){u.type==="code"&&(c++,setTimeout(()=>{s(u.text,u.lang,function(p,m){if(p)return f(p);m!=null&&m!==u.text&&(u.text=m,u.escaped=!0),c--,c===0&&f()})},0))}),c===0&&f();return}if(o.async)return Promise.resolve(o.hooks?o.hooks.preprocess(n):n).then(s=>a(s,o)).then(s=>o.walkTokens?Promise.all(j.walkTokens(s,o.walkTokens)).then(()=>s):s).then(s=>e(s,o)).then(s=>o.hooks?o.hooks.postprocess(s):s).catch(r);try{o.hooks&&(n=o.hooks.preprocess(n));const s=a(n,o);o.walkTokens&&j.walkTokens(s,o.walkTokens);let l=e(s,o);return o.hooks&&(l=o.hooks.postprocess(l)),l}catch(s){return r(s)}}}function j(a,e,n){return un(De.lex,Ce.parse)(a,e,n)}j.options=j.setOptions=function(a){return j.defaults={...j.defaults,...a},Jn(j.defaults),j};j.getDefaults=an;j.defaults=Fe;j.use=function(...a){const e=j.defaults.extensions||{renderers:{},childTokens:{}};a.forEach(n=>{const o={...n};if(o.async=j.defaults.async||o.async||!1,n.extensions&&(n.extensions.forEach(t=>{if(!t.name)throw new Error("extension name required");if(t.renderer){const i=e.renderers[t.name];i?e.renderers[t.name]=function(...r){let s=t.renderer.apply(this,r);return s===!1&&(s=i.apply(this,r)),s}:e.renderers[t.name]=t.renderer}if(t.tokenizer){if(!t.level||t.level!=="block"&&t.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");e[t.level]?e[t.level].unshift(t.tokenizer):e[t.level]=[t.tokenizer],t.start&&(t.level==="block"?e.startBlock?e.startBlock.push(t.start):e.startBlock=[t.start]:t.level==="inline"&&(e.startInline?e.startInline.push(t.start):e.startInline=[t.start]))}t.childTokens&&(e.childTokens[t.name]=t.childTokens)}),o.extensions=e),n.renderer){const t=j.defaults.renderer||new st;for(const i in n.renderer){const r=t[i];t[i]=(...s)=>{let l=n.renderer[i].apply(t,s);return l===!1&&(l=r.apply(t,s)),l}}o.renderer=t}if(n.tokenizer){const t=j.defaults.tokenizer||new lt;for(const i in n.tokenizer){const r=t[i];t[i]=(...s)=>{let l=n.tokenizer[i].apply(t,s);return l===!1&&(l=r.apply(t,s)),l}}o.tokenizer=t}if(n.hooks){const t=j.defaults.hooks||new ot;for(const i in n.hooks){const r=t[i];ot.passThroughHooks.has(i)?t[i]=s=>{if(j.defaults.async)return Promise.resolve(n.hooks[i].call(t,s)).then(f=>r.call(t,f));const l=n.hooks[i].call(t,s);return r.call(t,l)}:t[i]=(...s)=>{let l=n.hooks[i].apply(t,s);return l===!1&&(l=r.apply(t,s)),l}}o.hooks=t}if(n.walkTokens){const t=j.defaults.walkTokens;o.walkTokens=function(i){let r=[];return r.push(n.walkTokens.call(this,i)),t&&(r=r.concat(t.call(this,i))),r}}j.setOptions(o)})};j.walkTokens=function(a,e){let n=[];for(const o of a)switch(n=n.concat(e.call(j,o)),o.type){case"table":{for(const t of o.header)n=n.concat(j.walkTokens(t.tokens,e));for(const t of o.rows)for(const i of t)n=n.concat(j.walkTokens(i.tokens,e));break}case"list":{n=n.concat(j.walkTokens(o.items,e));break}default:j.defaults.extensions&&j.defaults.extensions.childTokens&&j.defaults.extensions.childTokens[o.type]?j.defaults.extensions.childTokens[o.type].forEach(function(t){n=n.concat(j.walkTokens(o[t],e))}):o.tokens&&(n=n.concat(j.walkTokens(o.tokens,e)))}return n};j.parseInline=un(De.lexInline,Ce.parseInline);j.Parser=Ce;j.parser=Ce.parse;j.Renderer=st;j.TextRenderer=cn;j.Lexer=De;j.lexer=De.lex;j.Tokenizer=lt;j.Slugger=ft;j.Hooks=ot;j.parse=j;j.options;j.setOptions;j.use;j.walkTokens;j.parseInline;Ce.parse;De.lex;const pn={};function v0(a){let e;return{c(){e=R(a[1])},l(n){e=P(n,a[1])},m(n,o){A(n,e,o)},p(n,o){o&2&&pe(e,n[1])},i:ne,o:ne,d(n){n&&h(e)}}}function g0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=z("h6"),t&&t.c(),this.h()},l(i){e=B(i,"H6",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function x0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=z("h5"),t&&t.c(),this.h()},l(i){e=B(i,"H5",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function _0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=z("h4"),t&&t.c(),this.h()},l(i){e=B(i,"H4",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function b0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=z("h3"),t&&t.c(),this.h()},l(i){e=B(i,"H3",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function w0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=z("h2"),t&&t.c(),this.h()},l(i){e=B(i,"H2",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function $0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=z("h1"),t&&t.c(),this.h()},l(i){e=B(i,"H1",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function k0(a){let e,n,o,t;const i=[$0,w0,b0,_0,x0,g0,v0],r=[];function s(l,f){return l[0]===1?0:l[0]===2?1:l[0]===3?2:l[0]===4?3:l[0]===5?4:l[0]===6?5:6}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,[f]){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function y0(a,e,n){let o,{$$slots:t={},$$scope:i}=e,{depth:r}=e,{raw:s}=e,{text:l}=e;const{slug:f,getOptions:c}=Sn(pn),u=c();return a.$$set=p=>{"depth"in p&&n(0,r=p.depth),"raw"in p&&n(1,s=p.raw),"text"in p&&n(3,l=p.text),"$$scope"in p&&n(4,i=p.$$scope)},a.$$.update=()=>{a.$$.dirty&8&&n(2,o=u.headerIds?u.headerPrefix+f(l):void 0)},[r,s,o,l,i,t]}class S0 extends Q{constructor(e){super(),J(this,e,y0,k0,ee,{depth:0,raw:1,text:3})}}function E0(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=z("p"),t&&t.c()},l(i){e=B(i,"P",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function A0(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class D0 extends Q{constructor(e){super(),J(this,e,A0,E0,ee,{})}}function z0(a){let e;const n=a[3].default,o=se(n,a,a[2],null);return{c(){o&&o.c()},l(t){o&&o.l(t)},m(t,i){o&&o.m(t,i),e=!0},p(t,[i]){o&&o.p&&(!e||i&4)&&fe(o,n,t,t[2],e?ue(n,t[2],i,null):ce(t[2]),null)},i(t){e||(_(o,t),e=!0)},o(t){k(o,t),e=!1},d(t){o&&o.d(t)}}}function B0(a,e,n){let{$$slots:o={},$$scope:t}=e,{text:i}=e,{raw:r}=e;return a.$$set=s=>{"text"in s&&n(0,i=s.text),"raw"in s&&n(1,r=s.raw),"$$scope"in s&&n(2,t=s.$$scope)},[i,r,t,o]}class C0 extends Q{constructor(e){super(),J(this,e,B0,z0,ee,{text:0,raw:1})}}function T0(a){let e,n;return{c(){e=z("img"),this.h()},l(o){e=B(o,"IMG",{src:!0,title:!0,alt:!0}),this.h()},h(){et(e.src,n=a[0])||y(e,"src",n),y(e,"title",a[1]),y(e,"alt",a[2])},m(o,t){A(o,e,t)},p(o,[t]){t&1&&!et(e.src,n=o[0])&&y(e,"src",n),t&2&&y(e,"title",o[1]),t&4&&y(e,"alt",o[2])},i:ne,o:ne,d(o){o&&h(e)}}}function I0(a,e,n){let{href:o=""}=e,{title:t=void 0}=e,{text:i=""}=e;return a.$$set=r=>{"href"in r&&n(0,o=r.href),"title"in r&&n(1,t=r.title),"text"in r&&n(2,i=r.text)},[o,t,i]}class L0 extends Q{constructor(e){super(),J(this,e,I0,T0,ee,{href:0,title:1,text:2})}}function R0(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=z("a"),t&&t.c(),this.h()},l(i){e=B(i,"A",{href:!0,title:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"href",a[0]),y(e,"title",a[1])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null),(!n||r&1)&&y(e,"href",i[0]),(!n||r&2)&&y(e,"title",i[1])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function P0(a,e,n){let{$$slots:o={},$$scope:t}=e,{href:i=""}=e,{title:r=void 0}=e;return a.$$set=s=>{"href"in s&&n(0,i=s.href),"title"in s&&n(1,r=s.title),"$$scope"in s&&n(2,t=s.$$scope)},[i,r,t,o]}class F0 extends Q{constructor(e){super(),J(this,e,P0,R0,ee,{href:0,title:1})}}function M0(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=z("em"),t&&t.c()},l(i){e=B(i,"EM",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function U0(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class N0 extends Q{constructor(e){super(),J(this,e,U0,M0,ee,{})}}function V0(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=z("del"),t&&t.c()},l(i){e=B(i,"DEL",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function O0(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class H0 extends Q{constructor(e){super(),J(this,e,O0,V0,ee,{})}}function K0(a){let e,n=a[0].replace(/`/g,"")+"",o;return{c(){e=z("code"),o=R(n)},l(t){e=B(t,"CODE",{});var i=T(e);o=P(i,n),i.forEach(h)},m(t,i){A(t,e,i),w(e,o)},p(t,[i]){i&1&&n!==(n=t[0].replace(/`/g,"")+"")&&pe(o,n)},i:ne,o:ne,d(t){t&&h(e)}}}function q0(a,e,n){let{raw:o}=e;return a.$$set=t=>{"raw"in t&&n(0,o=t.raw)},[o]}class Y0 extends Q{constructor(e){super(),J(this,e,q0,K0,ee,{raw:0})}}function G0(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=z("strong"),t&&t.c()},l(i){e=B(i,"STRONG",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function W0(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class X0 extends Q{constructor(e){super(),J(this,e,W0,G0,ee,{})}}function j0(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=z("table"),t&&t.c()},l(i){e=B(i,"TABLE",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function Z0(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class Q0 extends Q{constructor(e){super(),J(this,e,Z0,j0,ee,{})}}function J0(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=z("thead"),t&&t.c()},l(i){e=B(i,"THEAD",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function eo(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class to extends Q{constructor(e){super(),J(this,e,eo,J0,ee,{})}}function no(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=z("tbody"),t&&t.c()},l(i){e=B(i,"TBODY",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function oo(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class ro extends Q{constructor(e){super(),J(this,e,oo,no,ee,{})}}function io(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=z("tr"),t&&t.c()},l(i){e=B(i,"TR",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function ao(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class lo extends Q{constructor(e){super(),J(this,e,ao,io,ee,{})}}function so(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=z("td"),t&&t.c(),this.h()},l(i){e=B(i,"TD",{align:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"align",a[1])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null),(!n||r&2)&&y(e,"align",i[1])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function fo(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=z("th"),t&&t.c(),this.h()},l(i){e=B(i,"TH",{align:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"align",a[1])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null),(!n||r&2)&&y(e,"align",i[1])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function co(a){let e,n,o,t;const i=[fo,so],r=[];function s(l,f){return l[0]?0:1}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,[f]){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function uo(a,e,n){let{$$slots:o={},$$scope:t}=e,{header:i}=e,{align:r}=e;return a.$$set=s=>{"header"in s&&n(0,i=s.header),"align"in s&&n(1,r=s.align),"$$scope"in s&&n(2,t=s.$$scope)},[i,r,t,o]}class po extends Q{constructor(e){super(),J(this,e,uo,co,ee,{header:0,align:1})}}function mo(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=z("ul"),t&&t.c()},l(i){e=B(i,"UL",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function ho(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=z("ol"),t&&t.c(),this.h()},l(i){e=B(i,"OL",{start:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"start",a[1])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null),(!n||r&2)&&y(e,"start",i[1])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function vo(a){let e,n,o,t;const i=[ho,mo],r=[];function s(l,f){return l[0]?0:1}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,[f]){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function go(a,e,n){let{$$slots:o={},$$scope:t}=e,{ordered:i}=e,{start:r}=e;return a.$$set=s=>{"ordered"in s&&n(0,i=s.ordered),"start"in s&&n(1,r=s.start),"$$scope"in s&&n(2,t=s.$$scope)},[i,r,t,o]}class xo extends Q{constructor(e){super(),J(this,e,go,vo,ee,{ordered:0,start:1})}}function _o(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=z("li"),t&&t.c()},l(i){e=B(i,"LI",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function bo(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class wo extends Q{constructor(e){super(),J(this,e,bo,_o,ee,{})}}function $o(a){let e;return{c(){e=z("hr")},l(n){e=B(n,"HR",{})},m(n,o){A(n,e,o)},p:ne,i:ne,o:ne,d(n){n&&h(e)}}}class ko extends Q{constructor(e){super(),J(this,e,null,$o,ee,{})}}function yo(a){let e,n;return{c(){e=new En(!1),n=K(),this.h()},l(o){e=An(o,!1),n=K(),this.h()},h(){e.a=n},m(o,t){e.m(a[0],o,t),A(o,n,t)},p(o,[t]){t&1&&e.p(o[0])},i:ne,o:ne,d(o){o&&h(n),o&&e.d()}}}function So(a,e,n){let{text:o}=e;return a.$$set=t=>{"text"in t&&n(0,o=t.text)},[o]}class Eo extends Q{constructor(e){super(),J(this,e,So,yo,ee,{text:0})}}function Ao(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=z("blockquote"),t&&t.c()},l(i){e=B(i,"BLOCKQUOTE",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function Do(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class zo extends Q{constructor(e){super(),J(this,e,Do,Ao,ee,{})}}function Bo(a){let e,n,o;return{c(){e=z("pre"),n=z("code"),o=R(a[1]),this.h()},l(t){e=B(t,"PRE",{class:!0});var i=T(e);n=B(i,"CODE",{});var r=T(n);o=P(r,a[1]),r.forEach(h),i.forEach(h),this.h()},h(){y(e,"class",a[0])},m(t,i){A(t,e,i),w(e,n),w(n,o)},p(t,[i]){i&2&&pe(o,t[1]),i&1&&y(e,"class",t[0])},i:ne,o:ne,d(t){t&&h(e)}}}function Co(a,e,n){let{lang:o}=e,{text:t}=e;return a.$$set=i=>{"lang"in i&&n(0,o=i.lang),"text"in i&&n(1,t=i.text)},[o,t]}class To extends Q{constructor(e){super(),J(this,e,Co,Bo,ee,{lang:0,text:1})}}function Io(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=z("br"),t&&t.c()},l(i){e=B(i,"BR",{}),t&&t.l(i)},m(i,r){A(i,e,r),t&&t.m(i,r),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function Lo(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class Ro extends Q{constructor(e){super(),J(this,e,Lo,Io,ee,{})}}const Po={heading:S0,paragraph:D0,text:C0,image:L0,link:F0,em:N0,strong:X0,codespan:Y0,del:H0,table:Q0,tablehead:to,tablebody:ro,tablerow:lo,tablecell:po,list:xo,orderedlistitem:null,unorderedlistitem:null,listitem:wo,hr:ko,html:Eo,blockquote:zo,code:To,br:Ro},Fo={baseUrl:null,breaks:!1,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartLists:!1,smartypants:!1,tokenizer:null,xhtml:!1};function Mo(a){let e,n;return e=new Pe({props:{tokens:a[0],renderers:a[1]}}),{c(){U(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){N(e,o,t),n=!0},p(o,[t]){const i={};t&1&&(i.tokens=o[0]),t&2&&(i.renderers=o[1]),e.$set(i)},i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){V(e,o)}}}function Uo(a,e,n){let o,t,i,r,{source:s=[]}=e,{renderers:l={}}=e,{options:f={}}=e,{isInline:c=!1}=e;const u=Xe();let p,m,d;return Dn(pn,{slug:x=>t?t.slug(x):"",getOptions:()=>i}),Ee(()=>{n(7,d=!0)}),a.$$set=x=>{"source"in x&&n(2,s=x.source),"renderers"in x&&n(3,l=x.renderers),"options"in x&&n(4,f=x.options),"isInline"in x&&n(5,c=x.isInline)},a.$$.update=()=>{a.$$.dirty&4&&n(8,o=Array.isArray(s)),a.$$.dirty&4&&(t=s?new ft:void 0),a.$$.dirty&16&&n(9,i={...Fo,...f}),a.$$.dirty&869&&(o?n(0,p=s):(n(6,m=new De(i)),n(0,p=c?m.inlineTokens(s):m.lex(s)),u("parsed",{tokens:p}))),a.$$.dirty&8&&n(1,r={...Po,...l}),a.$$.dirty&385&&d&&!o&&u("parsed",{tokens:p})},[p,r,s,l,f,c,m,d,o,i]}class No extends Q{constructor(e){super(),J(this,e,Uo,Mo,ee,{source:2,renderers:3,options:4,isInline:5})}}function Vo(a){let e,n;return{c(){e=z("img"),this.h()},l(o){e=B(o,"IMG",{src:!0,title:!0,alt:!0,class:!0}),this.h()},h(){et(e.src,n=a[0])||y(e,"src",n),y(e,"title",a[1]),y(e,"alt",a[2]),y(e,"class","svelte-1pemytu")},m(o,t){A(o,e,t)},p(o,[t]){t&1&&!et(e.src,n=o[0])&&y(e,"src",n),t&2&&y(e,"title",o[1]),t&4&&y(e,"alt",o[2])},i:ne,o:ne,d(o){o&&h(e)}}}function Oo(a,e,n){let{href:o=""}=e,{title:t=void 0}=e,{text:i=""}=e;return a.$$set=r=>{"href"in r&&n(0,o=r.href),"title"in r&&n(1,t=r.title),"text"in r&&n(2,i=r.text)},[o,t,i]}class Ho extends Q{constructor(e){super(),J(this,e,Oo,Vo,ee,{href:0,title:1,text:2})}}function Ko(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=z("a"),t&&t.c(),this.h()},l(i){e=B(i,"A",{target:!0,rel:!0,href:!0,title:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"target","_blank"),y(e,"rel","noopener noreferrer"),y(e,"href",a[0]),y(e,"title",a[1])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null),(!n||r&1)&&y(e,"href",i[0]),(!n||r&2)&&y(e,"title",i[1])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function qo(a,e,n){let{$$slots:o={},$$scope:t}=e,{href:i=""}=e,{title:r=void 0}=e;return a.$$set=s=>{"href"in s&&n(0,i=s.href),"title"in s&&n(1,r=s.title),"$$scope"in s&&n(2,t=s.$$scope)},[i,r,t,o]}class Yo extends Q{constructor(e){super(),J(this,e,qo,Ko,ee,{href:0,title:1})}}const Go=`# Gray-Scott model for Reaction-Diffusion systems

This page contains my experiementations aroud [reaction-diffusion systems](https://en.wikipedia.org/wiki/Reaction%E2%80%93diffusion_system).

The system I am considering is a mathematical model of a physical system in which two chemical substances react with each other while also diffusing in the environment. The simulation allows to compute the concentration of these chemical on a virtual grid and visualize these concentrations over time. This representation shows how the reactions create various pattern with different properties.

The main parameters for the simulation are the \`f\` and \`k\` variables. They correspond to the \`f\` and \`k\` parameters found in the litterature ([[1]](https://www.mrob.com/pub/comp/xmorphia/index.html#formula), [[2]](https://karlsims.com/rd.html)). I chose to constrain these parameters to the following intervals \`f: [0, 0.12]\` \`k: [0.03, 0.07]\`  which is a slighty larger parameters space than the [uskate world](https://mrob.com/pub/comp/xmorphia/uskate-world.html) characterized by Robert Munafo.

The next sections explain more about these parameters, for now if you don't know what they are just keep in mind that varying \`f\` and \`k\` make the simulation generate different kinds of patterns.

The application contains 4 tabs you can explore.

### Manual
This is an interactive view of the model.

The menu on the left allows the user to change the \`f\` and \`k\` parameters of the simulation and see how they influence the reaction. It is also possible to select a preset with the drop down menu.

![fkselector]({baseUrl}/reaction_diffusion_about/fkselector.gif)

In the center screen the user can drop some amout of solution by moving the mouse around and clicking the left mouse button, the solution can also be removed with the right mouse button. The user can also zoom in the simulation by holding the \`Ctrl\` button and scrolling with the mouse wheel (note that there is a bug in the zoom mecanism which move the simulation around when zooming in/out).

![interface]({baseUrl}/reaction_diffusion_about/interface.gif)

Finally the menu on the right allows the user to tweak various parameters like the color scheme used, the speed of the simulation (which you might want to adjust proportionally to \`f\`), the initial conditions, the pen setting to add or remove the solution, etc...

![settings]({baseUrl}/reaction_diffusion_about/settings.png)

Unlike the Auto tab, this simulation lets the user tweak the parameters as they want. This is a good tool to understand how each parameter impacts the simulation. A few tips to get interesting patterns:

- Don't change the \`f\` and \`k\` values too quickly, abrupt changes tend to stabilize the system very quickly.
- If the simulation stabilize completely either use the mouse to add new chemical, hit \`r\` to reset the world or move \`fk\` around.
- In the selection menu on the left the orange area of the parameters map is the area which tends to produce more patterns. By moving around you'll find that there are a few different areas: the bottom left tends to produce largely chaotic patterns, a little bit higher and on the right we find patterns ressembling cells divisions, higher up are worms on the left and dots on the right with different characteristics as we go higher on the \`f\` axis. On his website Robert Munafo represents these areas like this:

![pearsons-parameter-space1.jpg]({baseUrl}/reaction_diffusion_about/pearsons-parameter-space1.jpg)
![pearsons-parameter-space2.png]({baseUrl}/reaction_diffusion_about/pearsons-parameter-space2.png)

You can try to find many different patterns like the following:

![pattern5]({baseUrl}/reaction_diffusion_about/pattern5.png)
![pattern4]({baseUrl}/reaction_diffusion_about/pattern4.png)
![pattern1]({baseUrl}/reaction_diffusion_about/pattern1.png)
![pattern2]({baseUrl}/reaction_diffusion_about/pattern2.png)
![pattern3]({baseUrl}/reaction_diffusion_about/pattern3.png)

### Auto
This is my "artistic" stake at this simulation. My goal was to explore infinite simulation. I wanted to have a screen which would be infinitely smoothly evolving.

The \`f\` and \`k\` parameters are contiually changing to automatically generate different kinds of patterns. A mecanism also regularly regenerates some amount of solution so that there is as few stable states as possible. The user doesn't have to do anything, just load the tab and watch funny colors move on the screen.

You can use the menu on the left to tweak how fast the \`f\` and \`k\` parameters change and how much they change at each step. In this tab the \`fk\` parameters are bound to the white polygon as this is the area with the most interesting parameters classes.

![fkrandomizer.gif]({baseUrl}/reaction_diffusion_about/fkrandomizer.gif)

There are several configurations to try out and which give various results:

- Increasing the change magnitude impacts the stability of the system. Small change magnitudes keeps \`f\` and \`k\` in a smaller area so the diversity of patterns generated is reduced, on the other hand larger magnitudes will create larger changes in the parameters space so it might create situations where the one of the chemical reacts with all of the other leaving a uniform colored texture.

- Increasing the change rate update the parameters more often which might give more time for configurations to stabilize and display all of their features.

### Parameters map
I used this tab to generate the parameters map used in the parameters selection menu. Here the difference with the other tabs is that the \`f\` and \`k\` parameters are not uniform accross the grid, they vary accross the screen to show the different possible patterns.

At the top of the page there is an input allowing to change the size of the underlying simulation. Increasing this parameter increases the definition of the simulation and gives a more detailled parameter map, naturally that also increases the load on the GPU runing the simulation. By default this setting is set lower than what I used to generate the final parameter map. To generate the parameters map in the \`fk\` selector of the other tabs I used a world size of 12 (which makes a texture of 4096x4096 pixels) and the simulation ran for ~140.000 iterations. I was curious to see what would happen with more iterations but it turns out the evolution is not significant after the first hundred thousands iterations:

![parameters_map_timelapse_0]({baseUrl}/reaction_diffusion_about/parameters_map_timelapse_0.png)
![parameters_map_timelapse_1]({baseUrl}/reaction_diffusion_about/parameters_map_timelapse_1.png)
![parameters_map_timelapse_2]({baseUrl}/reaction_diffusion_about/parameters_map_timelapse_2.png)
![parameters_map_timelapse_3]({baseUrl}/reaction_diffusion_about/parameters_map_timelapse_3.png)
![parameters_map_timelapse_4]({baseUrl}/reaction_diffusion_about/parameters_map_timelapse_4.png)


### Previous versions
It took me several iterations to get the results shown in the other tabs. This tab regroups my different iterations and a section later in this page describes the different versions.

## Gray-Scott model

The Gray-Scott model is a simulation of two chemicals reacting together. Here the chemicals are named U and V.

The environement is represented with a 2D grid in which each pixel holds a level of concentration of each chemical. The simulation consist in updating the grid following these equations (picture taken [here](https://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/)):

![gray scott equations]({baseUrl}/reaction_diffusion_about/gray-scott-equations.gif)

The chemical reaction section shows that when 1 unit of U and 2 units of V are in contact they react to become 3 units of V. The second part showing that V produces P is not really considered in the implementation, P only represents a byproduct of the reaction which is necessary for the math to work but doesn't really impacts the simulation _(at least to the extent of my understanding)_.

The equations show 3 things:

- Both chemicals diffuse over time and the diffusion from one spot depends on the concentration of the chemical in the surrounding spots
- The chemicals react together and that impacts their concentration (which makes sense if 1 U and 2 V create 3 V then during the reaction the concentration of U diminishes and the concentration of P increases)
- \`f\` and \`k\` are respectively a "feed rate" at which we add some U and a "kill rate" at we we remove some V. This allows the model to keep evolving.

[Karlsims](https://karlsims.com/rd.html) has the clearest explaination of these equations.
[mrob](https://www.mrob.com/pub/comp/xmorphia/index.html#formula) also has a good explanation.

The way that I represents this system in my mind is as follow:

- Let's have two tanks containing the solutions one on top of the other.
- Both tanks are separated by a semi porous membrane which only allow the U solution from the bottom to go the tank above containing V.
- What we see in my simulation is the surface of the top tank while the U solution is slowly introduced to the V and both react together.

## Turing patterns

The reason why this model is so fascinating is because it gives us a glance at how ordered patterns can emerge from the randomness of nature. This is related to a concept which was theorized in 1952 by Alan Turing and is named [Turing patterns](https://en.wikipedia.org/wiki/Turing_pattern)

This is hard to reproduce exact existing patterns because nature is complex whereas this model is quite simple but here are a few similarities I have found:

This are two [madrepora corals](https://en.wikipedia.org/wiki/Madrepora) I took in picture at [La Grande galerie de l'Évolution](https://fr.wikipedia.org/wiki/Grande_galerie_de_l%27%C3%89volution) in Paris:

![madrepore_museum_spots.JPEG]({baseUrl}/reaction_diffusion_about/gallery/madrepore_museum_spots.JPEG)
![madrepore_simulation_spots.png]({baseUrl}/reaction_diffusion_about/gallery/madrepore_simulation_spots.png)
![madrepore_museum_stripes.png]({baseUrl}/reaction_diffusion_about/gallery/madrepore_museum_stripes.png)
![madrepore_simulation_stripes1.png]({baseUrl}/reaction_diffusion_about/gallery/madrepore_simulation_stripes1.png)
![madrepore_simulation_stripes2.png]({baseUrl}/reaction_diffusion_about/gallery/madrepore_simulation_stripes2.png)

This is a puffer fish picture from wikipedia ([[1]](https://commons.wikimedia.org/wiki/File:Giant_Puffer_fish_skin_pattern.JPG) [[2]](https://en.wikipedia.org/wiki/File:Giant_Pufferfish_skin_pattern_detail.jpg))

![800px-Giant_Puffer_fish_skin_pattern.JPG]({baseUrl}/reaction_diffusion_about/gallery/800px-Giant_Puffer_fish_skin_pattern.JPG)
![Giant_Pufferfish_skin_pattern_detail.jpg]({baseUrl}/reaction_diffusion_about/gallery/Giant_Pufferfish_skin_pattern_detail.jpg)
![tbd_simulation_stripes.png]({baseUrl}/reaction_diffusion_about/gallery/tbd_simulation_stripes.png)
![tbd_simulation_stripes_spots.png]({baseUrl}/reaction_diffusion_about/gallery/tbd_simulation_stripes_spots.png)

Here are some behavior ressembling to cells mitosis:

![cells_division.gif]({baseUrl}/reaction_diffusion_about/gallery/cells_division.gif)
![cells_division2.gif]({baseUrl}/reaction_diffusion_about/gallery/cells_division2.gif)

A fish [from shutterstock](https://www.shutterstock.com/image-photo/goldspotted-rabbitfish-siganus-punctatus-bali-521298034) not sure which specy this is:

![fish_spots.jpg]({baseUrl}/reaction_diffusion_about/gallery/fish_spots.jpg)
![tbd_simulation_regular_spots.png]({baseUrl}/reaction_diffusion_about/gallery/tbd_simulation_regular_spots.png)

## Resources

Here are some resources which I found useful while making this project.

### Gray-Scott model
- Karlsims tutorial about Reaction-diffusion, very good introduction and good explanation of the formula
  https://karlsims.com/rd.html
- Mrob list of a lot of interesting parameter classes
  https://www.mrob.com/pub/comp/xmorphia/pearson-classes.html#eta
- Mrob Uskate parameter space
  https://mrob.com/pub/comp/xmorphia/uskate-world.html
- A very good high level introduction to reaction diffusion with some great analogies with the particule approach. Lot of interesting links.
  https://www.redblobgames.com/x/2202-turing-patterns/
- Redblobgames implementation of the parameter map visualisation
  https://www.redblobgames.com/x/2203-reaction-diffusion/art/parameter-map.html
- Good schema of the experience, one clue about the color map and a parameter space graph visualisation
  https://itp.uni-frankfurt.de/~gros/StudentProjects/Applets_2014_GrayScott/
- A scientific paper "Spatially localized structures in the Gray-Scott model"
  https://royalsocietypublishing.org/doi/10.1098/rsta.2017.0375

### Color maps
- General approach to color maps. Lot of visual representations of colormaps. The interesting one here is the diverging method.
  https://matplotlib.org/stable/tutorials/colors/colormaps.html#diverging
- A lot of colormaps implemented in glsl, I reused a few of them in my code.
  https://github.com/Polymole/glsl-colormap

### Other implementations

- [Redblobgames](https://www.redblobgames.com/x/2203-reaction-diffusion/) Various configurations with creative results.
- [Robert Munafo](https://www.mrob.com/pub/comp/xmorphia/ogl/index.html) Lots of presets to play with and a very good color picker.
- [pmneila](https://pmneila.github.io/jsexp/grayscott/) About the same set of features as Robert's implementation, with a dark theme.
- [Karlsims](https://www.karlsims.com/rdtool.html) Very good looking 3D like effect, flows applied to the whole grid and great interface.

## History of the project

The code of all the versions described here is available [on this project's repo on Github](https://github.com/statox/particles-life/tree/main/src/lib/ReactionDiffusion).

### Prototyping with P5.js (v1, v2, v3)

In versions v1, v2 and v3 were prototyping to validate my understanding of the math behind the model and of the general idea of the simulation.

These versions use the [p5.js](https://p5js.org/) framework to render and update the simulation. The world is represented by a 2D array in typescript and the update is a simple nested for loop iterating on each item of the grid and applying the formula.

The main difference between these 3 versions is the way I was updating the grid. In v1 I started with a very naive approach where I recreated the grid on each iteration. In v3 the algorithm is smarter, I create two grids when I build the world and then each update reads from one of the grids and writes to the other one which is then used by p5 to draw the canvas. This is a classical but inefficient approach to this kind problem.

With a grid of 500x500 pixels the frame rate is around 1 fps with 1 iteration by frame which isn't great. In comparison on the same machine my final version runs grids of 512x512 pixels rendered on a full screen at ~55fps with 50 iterations by frame, which is much better!

### Dabbling with WebGL (v4)

With the 3 previous versions I validated I understood the model and in v4 I started to make the simulation larger by using the GPU to update the world instead of doing that on the CPU in typescript. This was my first experience with [regl](https://github.com/regl-project/regl) which is an incredibly cool framework to make working with WebGL much easier. This version was laying the fundations for my WebGL simulation: First, in typescript we generate a grid representing the world and we generate two WebGL texture where each pixel is an item of the generated grid.

For each pixel we only generate a value on the red and green channels. Each value is comprised between \`0.0\` and \`1.0\` and corresponds to the concentration of the two chemicals U and V in each discrete position of the world.

Once this is done we create two regl commands:

- The \`update\` command which is responsible for reading from one of the created texture and updating the new state in the other texture.
- The \`draw\` command which simply takes the last updated texture and draws it directly on the canvas. The texture is drawn "raw" as in the red and green channels are used directly in the shader.

\`\`\`glsl
precision mediump float;
uniform sampler2D prevState;    // The state of the simulation to render
varying vec2 uv;                // The position of the vertex in the simulation texture
void main() {
    vec2 state = texture2D(prevState, uv).rg;   // Read the red and green channel in the simulation
    gl_FragColor = vec4(state, 0, 1);           // Use them directly in the color
}
\`\`\`

### Adding basic controls to the simulation (v5)

Once my simulation was working properly on the GPU I wanted to add some interactivity.

It was the opportunity to play with [dat.gui](https://github.com/dataarts/dat.gui/). This is a library which allows to easily create a graphical interface to modify the properties of a javascript object. I had already experimented with this library in my [previous game of life project]({baseUrl}/gameoflife)

In this simulation I added the following settings:

- A very crude manual selection of \`f\` and \`k\` parameters, allowing me to better grasp the impact of the feed rate and kill rate.
- Some additional presets seletions for \`f\` and \`k\`. I took these presets from the examples in [Robert Munafo's extended pearsons classification](https://www.mrob.com/pub/comp/xmorphia/pearson-classes.html). The fact that the classes I took from Robert's website were producing results similar to his own implementation was an encouraging sign that I was going in the right direction.
- A setting allowing to use different initial conditions for the world. It is useful because this version doesn't allow to modify the world with the mouse so having different starting worlds allowed me to test different \`f\` and \`k\` parameters.
- Some basic settings like the ability to pause and reset the simulation or see the current iteration number.

### Using the mouse to change the world (v6)

v6 saw a big improvement in my way to handle the glsl code for my shaders: instead of writing the shader code directly in the initialization of the regl commands (as it's shown in [regl's examples](https://github.com/regl-project/regl/blob/gh-pages/example/basic.js)) I created a mechanism which allows me to write the shader code in separate \`.glsl\` files which are imported in the typescript code and then injected in the regl commands properties.

Having a better separated code allowed me to pass more uniforms to my shaders and particularly to pass the mouse state to the update shader. Now the shader takes the position of the mouse as well as the state of each mouse button as uniforms. This way when updating each pixel if the pixel is close enough from the mouse and the button is pressed we can override the new value of the pixel (and ignore the value coming from the simulation). That allows to artifically increase the concentration of one of the chemicals on specific spots of the world.

### Zoom and \`fk\` selection (v7)

In v7 I focused on the UI of the application. A lot of things changed on this iteration.

Firstly I reworked the regl code and created two separate pipelines for the simulation itself and for its rendering. The simulation pipeline is basically the same one as in the previous versions.

The graphic pipeline is pretty different:

This version introduce a system where I use several texture to apply different transformations to the simulation texture before displaying it on the screen:

- Step 1 "Zoom": In the vertex shader of the graphical pipeline I pass as uniforms the state of the zoom (i.e. the zoom level and the pan on the x and y axis). These uniforms allows me to draw only the parts of the texture which are currently in a zoomed in area.
- Step 2 "Colors": To make the simulation more visally appealing the first stage takes the raw red and green channels of the simulation texture and transform them to use a wider spectrum of colors. Since regl makes the glsl code quite modular I was able to create different fragment shaders applying different color palettes.
- Step 3 "Grid": To help me debugging the implementation of my zoom mecanism I added a step which overlays a grid on the resulting texture. The goal was to have a grid with a fixed sized which would better show the resolution of the zoom.
- Step 4 "Cursor": To make the mouse drawing more intuitive I add another overlay showing the area which the cursor will drawn on.

This approach has the big advantage of keeping my code very modular and making it easier to implement the different steps. The main drawback is that it requires to keep one texture for each step of the pipeline which has an impact on the GPU. An alternative solution would be to do all the transformations in the same shader but I haven't experimented with that already and I'm not sure what are the best practices for this topic.

I also created the interface to select \`f\` and \`k\` on the parameters map. To do that, the first step was to create another type of simulation largely based on my previous experiements but where the \`f\` and \`k\` parameters are varying among the world. This way when initializing the world with small concentrations of the solutions and letting the simulation run for a few hundreds of thousands of iteration we get a nice map like this one

![parameter map]({baseUrl}/parameters_map.png)

Some inpsiration I had for the parameters map:

- [mrob](https://mrob.com/pub/comp/xmorphia/uskate-world.html)
- [RebBlobGames](https://www.redblobgames.com/x/2203-reaction-diffusion/art/parameter-map.html)

### "Auto Visualizer" (v8)

My last goal for this project was to create an infinite visualization based on the simulation. The issue with the raw simulation is that most of the parameters classes tend to create stable states after a number of iterations. Stable states are interesting to study the Gray-Scott system but they get boring quickly so I created the Auto Visualizer based on two ideas:

First the \`f\` and \`k\` parameters need to change regularly to create new patterns but they need to change slowly. A big step between two values of (f, k) often tend to destroy all the concentrations of chemicals. So reusing the menu component I created to select f and k, I added a bounding box of the values which create the most interesting patterns and then used a noise function to make the parameters vary slowly and consistenly over time.

Even when changing \`f\` and \`k\` the chemicals tends to disappear from the system so I have a mecanism which simulates the user clicking on the screen to add more chemical.
`;function Wo(a){let e,n;return e=new No({props:{source:a[0],renderers:{image:Ho,link:Yo}}}),{c(){U(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){N(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){V(e,o)}}}function Xo(a){return[Go.replaceAll("{baseUrl}",Ze)]}class zt extends Q{constructor(e){super(),J(this,e,Xo,Wo,ee,{})}}const Se=[{name:"KarlSims",type:"Unknown",f:.055,k:.062},{name:"STX 1",type:"N.A",f:.0353,k:.0614},{name:"STX 2",type:"N.A",f:.0201,k:.0602},{name:"STX 2",type:"N.A",f:.0181,k:.0435},{name:"α 1",type:"alpha",f:.01,k:.047},{name:"α 2",type:"alpha",f:.014,k:.053},{name:"β 1",type:"beta",f:.014,k:.039},{name:"β 2",type:"beta",f:.026,k:.051},{name:"δ 1",type:"delta",f:.03,k:.055},{name:"δ 2",type:"delta",f:.042,k:.059},{name:"ε 1",type:"epsilon",f:.018,k:.055},{name:"ε 2",type:"epsilon",f:.022,k:.059},{name:"η 1",type:"eta",f:.034,k:.063},{name:"γ 1",type:"gamma",f:.022,k:.051},{name:"γ 2",type:"gamma",f:.026,k:.055},{name:"ι 1",type:"iota",f:.046,k:.0594},{name:"κ 1",type:"kappa",f:.082,k:.06},{name:"κ 2",type:"kappa",f:.058,k:.063},{name:"λ 1",type:"lambda",f:.026,k:.061},{name:"λ 2",type:"lambda",f:.034,k:.065},{name:"μ 1",type:"mu",f:.046,k:.065},{name:"μ 2",type:"mu",f:.058,k:.065},{name:"ν 2",type:"nu",f:.046,k:.067},{name:"π 1",type:"pi",f:.062,k:.061},{name:"ρ 1",type:"rho",f:.09,k:.059},{name:"ρ 2",type:"rho",f:.102,k:.055},{name:"σ 1",type:"sigma",f:.09,k:.057},{name:"θ 2",type:"sigma",f:.11,k:.0523},{name:"θ 1",type:"theta",f:.03,k:.057},{name:"θ 2",type:"theta",f:.038,k:.061},{name:"ξ 1",type:"xi",f:.01,k:.041},{name:"ξ 2",type:"xi",f:.014,k:.047},{name:"ζ 1",type:"zeta",f:.022,k:.061},{name:"ζ 2",type:"zeta",f:.026,k:.059}];function Bt(a){let e,n,o,t,i,r,s,l,f=a[1].toFixed(2)+"",c,u,p,m,d,x,C,E=a[2].toFixed(2)+"",S,M,v,g;return v=new Le({props:{sketch:a[4]}}),{c(){e=z("div"),n=R(`Modify the change rate to change how fast the selector walks around the parameters space
            and the change magnitude to change how big each step taken by the selector is.`),o=q(),t=z("div"),i=z("label"),r=R("changeMag"),s=q(),l=z("span"),c=R(f),u=q(),p=z("div"),m=z("label"),d=R("changeRate"),x=q(),C=z("span"),S=R(E),M=q(),U(v.$$.fragment),this.h()},l($){e=B($,"DIV",{});var L=T(e);n=P(L,`Modify the change rate to change how fast the selector walks around the parameters space
            and the change magnitude to change how big each step taken by the selector is.`),L.forEach(h),o=Y($),t=B($,"DIV",{});var D=T(t);i=B(D,"LABEL",{for:!0});var b=T(i);r=P(b,"changeMag"),b.forEach(h),s=Y(D),l=B(D,"SPAN",{id:!0}),T(l).forEach(h),c=P(D,f),D.forEach(h),u=Y($),p=B($,"DIV",{});var O=T(p);m=B(O,"LABEL",{for:!0});var X=T(m);d=P(X,"changeRate"),X.forEach(h),x=Y(O),C=B(O,"SPAN",{id:!0}),T(C).forEach(h),S=P(O,E),O.forEach(h),M=Y($),G(v.$$.fragment,$),this.h()},h(){y(i,"for","changeMag"),y(l,"id","changeMag"),y(m,"for","changeRate"),y(C,"id","changeRate")},m($,L){A($,e,L),w(e,n),A($,o,L),A($,t,L),w(t,i),w(i,r),w(t,s),w(t,l),w(t,c),A($,u,L),A($,p,L),w(p,m),w(m,d),w(p,x),w(p,C),w(p,S),A($,M,L),N(v,$,L),g=!0},p($,L){(!g||L&2)&&f!==(f=$[1].toFixed(2)+"")&&pe(c,f),(!g||L&4)&&E!==(E=$[2].toFixed(2)+"")&&pe(S,E)},i($){g||(_(v.$$.fragment,$),g=!0)},o($){k(v.$$.fragment,$),g=!1},d($){$&&h(e),$&&h(o),$&&h(t),$&&h(u),$&&h(p),$&&h(M),V(v,$)}}}function jo(a){let e,n,o=a[0]?"Close":"F/K selection",t,i,r,s,l,f=a[0]&&Bt(a);return{c(){e=z("div"),n=z("button"),t=R(o),i=q(),f&&f.c(),this.h()},l(c){e=B(c,"DIV",{id:!0,class:!0});var u=T(e);n=B(u,"BUTTON",{class:!0,id:!0});var p=T(n);t=P(p,o),p.forEach(h),i=Y(u),f&&f.l(u),u.forEach(h),this.h()},h(){y(n,"class","full-width svelte-vk9dfi"),y(n,"id","toggleButton"),y(e,"id","container"),y(e,"class","svelte-vk9dfi"),Te(e,"no-cursor",a[3])},m(c,u){A(c,e,u),w(e,n),w(n,t),w(e,i),f&&f.m(e,null),r=!0,s||(l=Z(n,"click",a[5]),s=!0)},p(c,[u]){(!r||u&1)&&o!==(o=c[0]?"Close":"F/K selection")&&pe(t,o),c[0]?f?(f.p(c,u),u&1&&_(f,1)):(f=Bt(c),f.c(),_(f,1),f.m(e,null)):f&&(oe(),k(f,1,1,()=>{f=null}),re()),(!r||u&8)&&Te(e,"no-cursor",c[3])},i(c){r||(_(f),r=!0)},o(c){k(f),r=!1},d(c){c&&h(e),f&&f.d(),s=!1,l()}}}function Zo(a,e){let n=!1,o=1/0,t=null;for(let i=0;i<e.length;i++){const r=e[i],s=e[(i+1)%e.length];if(a[0]===r[0]&&a[1]===r[1])return a;r[1]>a[1]!=s[1]>a[1]&&a[0]<(s[0]-r[0])*(a[1]-r[1])/(s[1]-r[1])+r[0]&&(n=!n);const f=Qo(a,r,s);f<o&&(o=f,t=Jo(a,r,s))}if(n)return a;if(!t)throw new Error("Now closest point found");return t}function Qo(a,e,n){const o=[n[0]-e[0],n[1]-e[1]],t=[a[0]-e[0],a[1]-e[1]],i=o[0]*t[0]+o[1]*t[1],r=o[0]*o[0]+o[1]*o[1],s=i/r;let l;return s<0?l=e:s>1?l=n:l=[e[0]+s*o[0],e[1]+s*o[1]],Math.sqrt((a[0]-l[0])**2+(a[1]-l[1])**2)}function Jo(a,e,n){const o=[n[0]-e[0],n[1]-e[1]],t=[a[0]-e[0],a[1]-e[1]],i=o[0]*t[0]+o[1]*t[1],r=o[0]*o[0]+o[1]*o[1],s=i/r;let l;return s<0?l=e:s>1?l=n:l=[e[0]+s*o[0],e[1]+s*o[1]],l}function er(a,e,n){const o=Xe();let t=Se[0],i=!0,r=1,s=100;const l=[0,.12],f=[.03,.07],c={f:.0433,k:.0621},u=[{f:.1045,k:.0553},{f:.0829,k:.0582},{f:.0664,k:.0595},{f:.0511,k:.0594},{f:.0307,k:.0549},{f:.017,k:.0467},{f:.005,k:.0335},{f:.0076,k:.0472},{f:.0166,k:.0594},{f:.0277,k:.0657},{f:.046,k:.0675},{f:.0757,k:.0643},{f:.0949,k:.0594}],p=b=>{const{f:O,k:X}=b,I=g.map(X,f[0],f[1],0,g.width),F=g.map(O,l[0],l[1],g.height,0);return{x:I,y:F}},m=b=>{const{x:O,y:X}=b,I=g.map(X,g.height,0,l[0],l[1]),F=g.map(O,0,g.width,f[0],f[1]);return{f:I,k:F}},d=b=>{const O=b.mouseX,X=b.mouseY;if(O<0||X<0||O>b.width||X>b.height)return;const{f:I,k:F}=m({x:b.mouseX,y:b.mouseY});t={f:I,k:F,name:"custom",type:"manual"},o("fkupdated",t)},x=b=>{b.noStroke();const O=b.textSize();for(const X of Se){const{x:I,y:F}=p({f:X.f,k:X.k}),te=X.f===t.f&&X.k===t.k;b.circle(I,F,3),b.textSize(te?O*2:O),b.fill(te?[240,240,150]:[255,255,255]),b.text(X.name,I-b.textWidth(X.name)/2,F-10)}},C=b=>{b.noFill(),b.stroke("red"),b.strokeWeight(1);const{x:O,y:X}=p(t);b.text("F",10,X>10?X-5:X+15),b.line(0,X,b.width,X),b.text("K",O<b.width-10?O+5:O-15,b.height-10),b.line(O,0,O,b.height),b.circle(O,X,10)},E=b=>{const{f:O,k:X}=t,I=`F: ${O.toFixed(4)}`,F=`K: ${X.toFixed(4)}`,te=b.textSize(),xe=b.height*.05;b.textStyle(b.BOLD),b.textSize(xe),b.fill("white"),b.stroke(0),b.strokeWeight(1),b.text(I,b.width*.05,b.textSize()),b.text(F,b.width*.05,b.textSize()+b.textSize()+6),b.textStyle(b.NORMAL),b.textSize(te)},S=b=>{for(let O=0;O<u.length;O++){const{x:X,y:I}=p(u[O]),{x:F,y:te}=p(u[(O+1)%u.length]);b.fill("white"),b.stroke("white"),b.strokeWeight(1),b.circle(X,I,3),b.circle(F,te,3),b.line(X,I,F,te)}},M=()=>{const b=[t.f,t.k],O=u.map(I=>[I.f,I.k]),X=Zo(b,O);t.f=X[0],t.k=X[1]},v=()=>{let{f:b,k:O}=t;const X=g.noise(g.frameCount*.01),I=g.noise(5321+g.frameCount*.01),te=Math.random()<.97?.001:.01;b=b+(I*2-1)*(l[1]-l[0])*te*r,O=O+(X*2-1)*(f[1]-f[0])*te*r;const xe={f:b-c.f,k:O-c.k};b=b-xe.f*.001*(r/2),O=O-xe.k*.001*(r/2),t={f:b,k:O,name:"custom",type:"manual"},M(),o("fkupdated",t)};let g,$=!1;const L=b=>{g=b;let O,X,I;b.preload=()=>{O=b.loadImage(Ze+"/parameters_map.png")},b.setup=()=>{b.createCanvas(400,400),b.frameRate(55),X=b.createSlider(0,10,6,0);const F=b.select("#changeMag");if(!F)throw new Error("changeMag slider container not ready");X.parent(F),I=b.createSlider(1,80,30,1);const te=b.select("#changeRate");if(!te)throw new Error("changeRate slider container not ready");I.parent(te)},b.draw=()=>{b.background(255),b.tint(150,190),b.image(O,0,0,b.width,b.height),x(b),S(b),C(b),E(b),b.frameCount%s===0&&v(),n(3,$=!1),b.mouseIsPressed&&(d(b),n(3,$=!0)),n(1,r=Number(X.value())),n(2,s=Number(I.value()))}},D=()=>{n(0,i=!i),i||g.remove()};return ke(()=>g?.remove()),[i,r,s,$,L,D]}let tr=class extends Q{constructor(e){super(),J(this,e,er,jo,ee,{})}};const nr=`precision mediump float;
attribute vec2 position;
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,or=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    gl_FragColor = vec4(A, B, 0.0, 1.0);
}

`,rr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float PI = 3.14159265359;
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = sin(iteration*PI/180.0);
    if (val < 0.0) {
        val = -1.0 * val;
    }
    gl_FragColor = vec4(A, B, val, 1.0);
}
`,ir=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (A + B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}

`,ar=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(1.0 - val, 1.0 - val, 1.0 - val, 1.0);
}
`,lr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}
`,sr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    // vec3 color1 = vec3(1.0, 0.0, 0.0);
    // vec3 color2 = vec3(0.0, 1.0, 0.0);
    // vec3 result = color1 * A + color2 * B;

    vec3 color1RGB = vec3(0.639, 0.941, 0.717);
    vec3 color2RGB = vec3(0.929, 0.082, 0.705);

    vec3 color1HSV = rgb2hsv(color1RGB);
    vec3 color2HSV = rgb2hsv(color2RGB);

    float color1Offset = (cos(iteration * 0.001) + 1.0) * 0.5;
    float color1newH = 0.5 * (color1HSV.x + color1Offset);
    vec3 color1newHSV = vec3(color1newH, color1HSV.g, color1HSV.b);

    float color2Offset = (cos(iteration * 0.002)) * 0.5;
    float color2newH = 0.5 * (color2HSV.x + color2Offset + 0.33);
    vec3 color2newHSV = vec3(color2newH, color2HSV.g, color2HSV.b);


    vec3 resultHSV = color1newHSV * A + color2newHSV * B;
    vec3 result = hsv2rgb(resultHSV);

    gl_FragColor = vec4(result, 1.0);
}
`,fr=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float red = A; // The more A the redder
    float blue = 1.0 - A; // The less A the bleuer

    float green = max(A, B) - min(A, B);

    vec3 result = vec3(red, green, blue);

    gl_FragColor = vec4(result, 1.0);
}
`,cr=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec3 color1 = vec3(0.0, 0.0, 1.0);
    vec3 color2 = vec3(1.0, 0.0, 0.0);
    vec3 result = vec3(A, 0.0, 1.0-A);

    gl_FragColor = vec4(result, 1.0);
}
`,ur=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    if (A > 0.9) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else if (A > 0.4) {
        gl_FragColor = vec4(1.0 - A, 0.0, 0.0, 1.0);
    } else { 
        gl_FragColor = vec4(0.0, A, 0.0, 1.0);
    }
}
`,pr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);
    vec4 color = mix(blue, red, A);

    vec4 softRed = vec4(0.8588, 0.2824, 0.3765, 1.0);
    vec4 softBlue = vec4(0.2824, 0.3882, 0.8588, 1.0);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.6);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.4);
    vec4 softColor = mix(softBlue, softRed, 1.0-A);


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(color);
    }

}
`,mr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/MATLAB_cool.frag
float colormap_red(float x) {
    return (1.0 + 1.0 / 63.0) * x - 1.0 / 63.0;
}

float colormap_green(float x) {
    return -(1.0 + 1.0 / 63.0) * x + (1.0 + 1.0 / 63.0);
}

vec4 colormap(float x) {
    float r = clamp(colormap_red(x), 0.0, 1.0);
    float g = clamp(colormap_green(x), 0.0, 1.0);
    float b = 1.0;
    return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,dr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/MATLAB_parula.frag
 vec4 colormap(float x) {
    if (x < 0.0) {
        return vec4(0.0, 0.0, 0.0, 0.0);
    } else if (1.0 < x) {
        return vec4(0.0, 0.0, 0.0, 0.0);
    }
    if (x < 3.1250000000000000e-02) {
        float dx = x - 1.5625000000000000e-02;
        return ((vec4(-1.4151576683620706e+02,  2.4271369358056621e+01,  4.5510373586485706e+01, 1.0) * dx
               + vec4( 0.0000000000000000e+00,  0.0000000000000000e+00,  0.0000000000000000e+00, 1.0)) * dx
               + vec4( 2.6007355728658488e-01,  1.4968553250962457e+00,  3.0913652594248364e+00, 1.0)) * dx
               + vec4( 2.0810000000000001e-01,  1.6630000000000000e-01,  5.2920000000000000e-01, 1.0);
    } else if (x < 4.6875000000000000e-02) {
        float dx = x - 3.1250000000000000e-02;
        return ((vec4(-5.1390461057291191e+01,  1.2211762733842230e+01, -1.2843448884986955e+01, 1.0) * dx
               + vec4(-6.6335515704472066e+00,  1.1377204386589042e+00,  2.1332987618665173e+00, 1.0)) * dx
               + vec4( 1.5642431399834725e-01,  1.5146322069502911e+00,  3.1246980525790007e+00, 1.0)) * dx
               + vec4( 2.1162380952380999e-01,  1.8978095238095199e-01,  5.7767619047619101e-01, 1.0);
    } else if (x < 6.2500000000000000e-02) {
        float dx = x - 4.6875000000000000e-02;
        return ((vec4(-1.4725107464858192e+02,  1.3014608277362621e+01,  5.8634219534912217e+00, 1.0) * dx
               + vec4(-9.0424794325077311e+00,  1.7101468168077587e+00,  1.5312620953827538e+00, 1.0)) * dx
               + vec4(-8.8513670422823654e-02,  1.5591301328169576e+00,  3.1819568159735203e+00, 1.0)) * dx
               + vec4( 2.1225238095238100e-01,  2.1377142857142900e-01,  6.2697142857142896e-01, 1.0);
    } else if (x < 7.8125000000000000e-02) {
        float dx = x - 6.2500000000000000e-02;
        return ((vec4(-2.1469400225321081e+02, -1.4338005366630648e+01, -4.1817857976177763e+01, 1.0) * dx
               + vec4(-1.5944873556660008e+01,  2.3202065798091316e+00,  1.8061099994526548e+00, 1.0)) * dx
               + vec4(-4.7894106087856969e-01,  1.6221044046390967e+00,  3.2341032549553237e+00, 1.0)) * dx
               + vec4( 2.0810000000000001e-01,  2.3860000000000001e-01,  6.7708571428571396e-01, 1.0);
    } else if (x < 9.3750000000000000e-02) {
        float dx = x - 7.8125000000000000e-02;
        return ((vec4(-2.8846495443400278e+02,  2.0037550842697090e+02,  1.1771734328417965e+02, 1.0) * dx
               + vec4(-2.6008654912279265e+01,  1.6481125782483199e+00, -1.5410209318067788e-01, 1.0)) * dx
               + vec4(-1.1344649432057459e+00,  1.6841093914837442e+00,  3.2599158784908235e+00, 1.0)) * dx
               + vec4( 1.9590476190476200e-01,  2.6445714285714300e-01,  7.2789999999999999e-01, 1.0);
    } else if (x < 1.0937500000000000e-01) {
        float dx = x - 9.3750000000000000e-02;
        return ((vec4(-5.4509738001026233e+02,  5.1696771659011155e+01, -6.5374637230314454e+02, 1.0) * dx
               + vec4(-3.9530449651373146e+01,  1.1040714535762580e+01,  5.3638983732652425e+00, 1.0)) * dx
               + vec4(-2.1585134520128149e+00,  1.8823723151401646e+00,  3.3413189453671448e+00, 1.0)) * dx
               + vec4( 1.7072857142857101e-01,  2.9193809523809500e-01,  7.7924761904761897e-01, 1.0);
    } else if (x < 1.2500000000000000e-01) {
        float dx = x - 1.0937500000000000e-01;
        return ((vec4( 2.3639968744743715e+03, -8.1036503315845437e+02, -8.1573269216733058e+02, 1.0) * dx
               + vec4(-6.5081889339354191e+01,  1.3464000707278728e+01, -2.5280462828444659e+01, 1.0)) * dx
               + vec4(-3.7930812487429293e+00,  2.2652584908126849e+00,  3.0301226257549660e+00, 1.0)) * dx
               + vec4( 1.2527142857142901e-01,  3.2424285714285700e-01,  8.3027142857142899e-01, 1.0);
    } else if (x < 1.4062500000000000e-01) {
        float dx = x - 1.2500000000000000e-01;
        return ((vec4( 1.4125902630655582e+03,  2.5375056097507152e+02,  9.0826266478267496e+02, 1.0) * dx
               + vec4( 4.5730464151631985e+01, -2.4521860222023822e+01, -6.3517932773788282e+01, 1.0)) * dx
               + vec4(-4.0954472673010889e+00,  2.0924794358947931e+00,  1.6426476944700765e+00, 1.0)) * dx
               + vec4( 5.9133333333333399e-02,  3.5983333333333301e-01,  8.6833333333333296e-01, 1.0);
    } else if (x < 1.5625000000000000e-01) {
        float dx = x - 1.4062500000000000e-01;
        return ((vec4(-1.9850459267366693e+03,  1.4738473211499172e+02,  2.4976683303608979e+02, 1.0) * dx
               + vec4( 1.1194563273283002e+02, -1.2627302676317344e+01, -2.0943120362100398e+01, 1.0)) * dx
               + vec4(-1.6317582534813697e+00,  1.5120237656082123e+00,  3.2294373922181602e-01, 1.0)) * dx
               + vec4( 1.1695238095238101e-02,  3.8750952380952403e-01,  8.8195714285714299e-01, 1.0);
    } else if (x < 1.7187500000000000e-01) {
        float dx = x - 1.5625000000000000e-01;
        return ((vec4(-1.3211246088080517e+02,  6.1731462945951478e+01,  9.6199145930320853e+01, 1.0) * dx
               + vec4( 1.8896604917048652e+01, -5.7186433584271068e+00, -9.2353000635336890e+00, 1.0)) * dx
               + vec4( 4.1265170979798449e-01,  1.2253683588153301e+00, -1.4859407992871662e-01, 1.0)) * dx
               + vec4( 5.9571428571428596e-03,  4.0861428571428599e-01,  8.8284285714285704e-01, 1.0);
    } else if (x < 1.8750000000000000e-01) {
        float dx = x - 1.7187500000000000e-01;
        return ((vec4(-2.4276114402580023e+02,  1.8878292291818184e+01,  5.4500811814199913e+01, 1.0) * dx
               + vec4( 1.2703833313260910e+01, -2.8249810328356313e+00, -4.7259650980498993e+00, 1.0)) * dx
               + vec4( 9.0640855714657143e-01,  1.0918742277018498e+00, -3.6673884807846019e-01, 1.0)) * dx
               + vec4( 1.6514285714285700e-02,  4.2659999999999998e-01,  8.7863333333333304e-01, 1.0);
    } else if (x < 2.0312500000000000e-01) {
        float dx = x - 1.8750000000000000e-01;
        return ((vec4(-2.4875702015890445e+02,  2.7531596458333780e+01,  1.1605149669749400e+01, 1.0) * dx
               + vec4( 1.3244046870515243e+00, -1.9400610816566539e+00, -2.1712395442592785e+00, 1.0)) * dx
               + vec4( 1.1255997759014531e+00,  1.0174204446629080e+00, -4.7450767061454108e-01, 1.0)) * dx
               + vec4( 3.2852380952381001e-02,  4.4304285714285702e-01,  8.7195714285714299e-01, 1.0);
    } else if (x < 2.1875000000000000e-01) {
        float dx = x - 2.0312500000000000e-01;
        return ((vec4( 6.6879357994795782e+01,  3.3156266362545779e+00,  3.1398894268734253e+01, 1.0) * dx
               + vec4(-1.0336080632897122e+01, -6.4951749767225808e-01, -1.6272481534897754e+00, 1.0)) * dx
               + vec4( 9.8479233924761567e-01,  9.7695827936089374e-01, -5.3385904089187008e-01, 1.0)) * dx
               + vec4( 4.9814285714285700e-02,  4.5857142857142902e-01,  8.6405714285714297e-01, 1.0);
    } else if (x < 2.3437500000000000e-01) {
        float dx = x - 2.1875000000000000e-01;
        return ((vec4(-3.7807546774099214e+00,  2.9110963663947160e+01,  2.0085673255558202e+01, 1.0) * dx
               + vec4(-7.2011107268910699e+00, -4.9409749909782474e-01, -1.5542498464285720e-01, 1.0)) * dx
               + vec4( 7.1077372425092522e-01,  9.5908929503636120e-01, -5.6171330867519242e-01, 1.0)) * dx
               + vec4( 6.2933333333333299e-02,  4.7369047619047600e-01,  8.5543809523809500e-01, 1.0);
    } else if (x < 2.5000000000000000e-01) {
        float dx = x - 2.3437500000000000e-01;
        return ((vec4(-1.8052110713761824e+01,  7.5676044216235097e+00,  2.6820241280346455e+01, 1.0) * dx
               + vec4(-7.3783336023946600e+00,  8.7047892264969851e-01,  7.8609094921143352e-01, 1.0)) * dx
               + vec4( 4.8296990660583561e-01,  9.6497025477935916e-01, -5.5185915297880839e-01, 1.0)) * dx
               + vec4( 7.2266666666666701e-02,  4.8866666666666703e-01,  8.4670000000000001e-01, 1.0);
    } else if (x < 2.6562500000000000e-01) {
        float dx = x - 2.5000000000000000e-01;
        return ((vec4(-8.5042116753280467e+01,  3.9234694840689350e+01,  6.3623990194130904e+01, 1.0) * dx
               + vec4(-8.2245262921022455e+00,  1.2252103799133005e+00,  2.0432897592276738e+00, 1.0)) * dx
               + vec4( 2.3917522075432149e-01,  9.9771540013190607e-01, -5.0765007940944740e-01, 1.0)) * dx
               + vec4( 7.7942857142857203e-02,  5.0398571428571404e-01,  8.3837142857142899e-01, 1.0);
    } else if (x < 2.8125000000000000e-01) {
        float dx = x - 2.6562500000000000e-01;
        return ((vec4(-4.4981860368289709e+01,  3.5222378119677195e+01,  1.8276940800992332e+01, 1.0) * dx
               + vec4(-1.2210875514912267e+01,  3.0643367005706139e+00,  5.0256642995775600e+00, 1.0)) * dx
               + vec4(-8.0127932480280273e-02,  1.0647395732644671e+00, -3.9719767224061564e-01, 1.0)) * dx
               + vec4( 7.9347619047619000e-02,  5.2002380952381000e-01,  8.3118095238095202e-01, 1.0);
    } else if (x < 2.9687500000000000e-01) {
        float dx = x - 2.8125000000000000e-01;
        return ((vec4( 8.8958586797831074e+01, -6.4031864461777545e+01, -5.4343639113056135e+01, 1.0) * dx
               + vec4(-1.4319400219675847e+01,  4.7153856749304826e+00,  5.8823958996240755e+00, 1.0)) * dx
               + vec4(-4.9466349083321959e-01,  1.1862977353816719e+00, -2.2675923162809006e-01, 1.0)) * dx
               + vec4( 7.4942857142857103e-02,  5.3754285714285699e-01,  8.2627142857142899e-01, 1.0);
    } else if (x < 3.1250000000000000e-01) {
        float dx = x - 2.9687500000000000e-01;
        return ((vec4( 2.3465669412937996e+02, -7.4943148843863256e+01, -1.7040059387215410e+02, 1.0) * dx
               + vec4(-1.0149466463527515e+01,  1.7138920282846606e+00,  3.3350378161995691e+00, 1.0)) * dx
               + vec4(-8.7698953275827207e-01,  1.2867551994944084e+00, -8.2736829818345611e-02, 1.0)) * dx
               + vec4( 6.4057142857142799e-02,  5.5698571428571397e-01,  8.2395714285714305e-01, 1.0);
    } else if (x < 3.2812500000000000e-01) {
        float dx = x - 3.1250000000000000e-01;
        return ((vec4( 3.5054309382746595e+02, -7.5598816353949772e+01, -5.9224118732067950e+01, 1.0) * dx
               + vec4( 8.5006607378717081e-01, -1.7990680737714295e+00, -4.6524900215576546e+00, 1.0)) * dx
               + vec4(-1.0222926638479650e+00,  1.2854243237836778e+00, -1.0332202052706571e-01, 1.0)) * dx
               + vec4( 4.8771428571428597e-02,  5.7722380952381003e-01,  8.2282857142857202e-01, 1.0);
    } else if (x < 3.4375000000000000e-01) {
        float dx = x - 3.2812500000000000e-01;
        return ((vec4(-1.3511844086782639e+02,  2.1571557117596814e+01,  6.5912402293741552e+00, 1.0) * dx
               + vec4( 1.7281773596949638e+01, -5.3427625903628249e+00, -7.4286205871233397e+00, 1.0)) * dx
               + vec4(-7.3898266899270237e-01,  1.1738332196565799e+00, -2.9208937378770627e-01, 1.0)) * dx
               + vec4( 3.4342857142857203e-02,  5.9658095238095199e-01,  8.1985238095238100e-01, 1.0);
    } else if (x < 3.5937500000000000e-01) {
        float dx = x - 3.4375000000000000e-01;
        return ((vec4(-1.6458788273706924e+02,  1.0533768835542057e+01,  3.0362548290707878e+01, 1.0) * dx
               + vec4( 1.0948096681270275e+01, -4.3315958504754741e+00, -7.1196562013714262e+00, 1.0)) * dx
               + vec4(-2.9789094589551629e-01,  1.0226713690184817e+00, -5.1940619860793691e-01, 1.0)) * dx
               + vec4( 2.6499999999999999e-02,  6.1370000000000002e-01,  8.1350000000000000e-01, 1.0);
    } else if (x < 3.7500000000000000e-01) {
        float dx = x - 3.5937500000000000e-01;
        return ((vec4(-1.0406115199344315e+02,  1.9929786587720105e+01,  3.6734795179105028e+01, 1.0) * dx
               + vec4( 3.2330396779701545e+00, -3.8378254363094402e+00, -5.6964117502444944e+00, 1.0)) * dx
               + vec4(-7.6310690282384588e-02,  8.9502416141246732e-01, -7.1965726035193567e-01, 1.0)) * dx
               + vec4( 2.3890476190476202e-02,  6.2866190476190498e-01,  8.0376190476190501e-01, 1.0);
    } else if (x < 3.9062500000000000e-01) {
        float dx = x - 3.7500000000000000e-01;
        return ((vec4( 2.3255546213942225e+02,  1.8349599099637384e+01,  1.7433813849989207e+01, 1.0) * dx
               + vec4(-1.6448268217224928e+00, -2.9036166900100602e+00, -3.9744682262239461e+00, 1.0)) * dx
               + vec4(-5.1494864403514876e-02,  7.8968912818872505e-01, -8.7076475998425507e-01, 1.0)) * dx
               + vec4( 2.3090476190476199e-02,  6.4178571428571396e-01,  7.9126666666666701e-01, 1.0);
    } else if (x < 4.0625000000000000e-01) {
        float dx = x - 3.9062500000000000e-01;
        return ((vec4( 1.5126193200717549e+02,  2.0267550346934740e+01,  2.0857035135376179e+01, 1.0) * dx
               + vec4( 9.2562104660629245e+00, -2.0434792322145579e+00, -3.1572582020057021e+00, 1.0)) * dx
               + vec4( 6.7433005039304356e-02,  7.1239075440396538e-01, -9.8219798542534331e-01, 1.0)) * dx
               + vec4( 2.2771428571428599e-02,  6.5348571428571400e-01,  7.7675714285714303e-01, 1.0);
    } else if (x < 4.2187500000000000e-01) {
        float dx = x - 4.0625000000000000e-01;
        return ((vec4( 1.0861181935568159e+02, -5.7969433444380156e+00,  3.9956456082908054e+00, 1.0) * dx
               + vec4( 1.6346613528899276e+01, -1.0934378097019919e+00, -2.1795846800349437e+00, 1.0)) * dx
               + vec4( 4.6747712996058871e-01,  6.6337642562401933e-01, -1.0655861554572283e+00, 1.0)) * dx
               + vec4( 2.6661904761904800e-02,  6.6419523809523795e-01,  7.6071904761904796e-01, 1.0);
    } else if (x < 4.3750000000000000e-01) {
        float dx = x - 4.2187500000000000e-01;
        return ((vec4(-3.0484063800132168e+02,  1.4154965887634640e+01, -3.1353889969814710e+00, 1.0) * dx
               + vec4( 2.1437792561196851e+01, -1.3651695289725239e+00, -1.9922887921463122e+00, 1.0)) * dx
               + vec4( 1.0578584751183406e+00,  6.2496068595722998e-01, -1.1307716784600605e+00, 1.0)) * dx
               + vec4( 3.8371428571428598e-02,  6.7427142857142897e-01,  7.4355238095238096e-01, 1.0);
    } else if (x < 4.5312500000000000e-01) {
        float dx = x - 4.3750000000000000e-01;
        return ((vec4( 1.9732370744832981e+01, -3.3873392535419122e+00, -5.1854420010455629e+00, 1.0) * dx
               + vec4( 7.1483876548848961e+00, -7.0165550298965007e-01, -2.1392601513798186e+00, 1.0)) * dx
               + vec4( 1.5045175409946179e+00,  5.9266654483282100e-01, -1.1953271307026563e+00, 1.0)) * dx
               + vec4( 5.8971428571428598e-02,  6.8375714285714295e-01,  7.2538571428571397e-01, 1.0);
    } else if (x < 4.6875000000000000e-01) {
        float dx = x - 4.5312500000000000e-01;
        return ((vec4(-5.2460806882781675e+01, -6.0560887320505685e-01,  1.3890718905419471e+01, 1.0) * dx
               + vec4( 8.0733425335489422e+00, -8.6043703049942721e-01, -2.3823277451788294e+00, 1.0)) * dx
               + vec4( 1.7423570751888966e+00,  5.6825884899705426e-01, -1.2659769415863851e+00, 1.0)) * dx
               + vec4( 8.4300000000000000e-02,  6.9283333333333297e-01,  7.0616666666666705e-01, 1.0);
    } else if (x < 4.8437500000000000e-01) {
        float dx = x - 4.6875000000000000e-01;
        return ((vec4( 1.0354971072183483e+01,  5.8097747460711062e+00, -5.4384621916749820e+00, 1.0) * dx
               + vec4( 5.6142422109185510e+00, -8.8882494643091425e-01, -1.7312002964872917e+00, 1.0)) * dx
               + vec4( 1.9562255868212013e+00,  5.4092663060751767e-01, -1.3302508172374183e+00, 1.0)) * dx
               + vec4( 1.1329523809523800e-01,  7.0150000000000001e-01,  6.8585714285714305e-01, 1.0);
    } else if (x < 5.0000000000000000e-01) {
        float dx = x - 4.8437500000000000e-01;
        return ((vec4(-1.3925172644537971e+01, -8.9021377300786071e+00, -4.6199177582688593e+00, 1.0) * dx
               + vec4( 6.0996314799271518e+00, -6.1649175520883115e-01, -1.9861282117220564e+00, 1.0)) * dx
               + vec4( 2.1392548632406654e+00,  5.1740605714439658e-01, -1.3883340751781894e+00, 1.0)) * dx
               + vec4( 1.4527142857142900e-01,  7.0975714285714298e-01,  6.6462857142857201e-01, 1.0);
    } else if (x < 5.1562500000000000e-01) {
        float dx = x - 5.0000000000000000e-01;
        return ((vec4( 3.1614367125520630e+01, -1.1395280968671647e+01,  2.1421523701702025e+01, 1.0) * dx
               + vec4( 5.4468890122144344e+00, -1.0337794613062659e+00, -2.2026868566409092e+00, 1.0)) * dx
               + vec4( 2.3196692459303776e+00,  4.9162056938634824e-01, -1.4537843106213608e+00, 1.0)) * dx
               + vec4( 1.8013333333333301e-01,  7.1765714285714299e-01,  6.4243333333333297e-01, 1.0);
    } else if (x < 5.3125000000000000e-01) {
        float dx = x - 5.1562500000000000e-01;
        return ((vec4(-3.7634010143333590e+01,  2.0544616050328934e+00,  1.3219372364175872e+00, 1.0) * dx
               + vec4( 6.9288124712232140e+00, -1.5679332567127493e+00, -1.1985529331236269e+00, 1.0)) * dx
               + vec4( 2.5130395816090907e+00,  4.5096880816730112e-01, -1.5069286823364316e+00, 1.0)) * dx
               + vec4( 2.1782857142857101e-01,  7.2504285714285699e-01,  6.1926190476190501e-01, 1.0);
    } else if (x < 5.4687500000000000e-01) {
        float dx = x - 5.3125000000000000e-01;
        return ((vec4( 1.2815768685879013e+01, -1.4298832118473902e+01,  3.9450879734146490e+01, 1.0) * dx
               + vec4( 5.1647182457544520e+00, -1.4716303689768324e+00, -1.1365871251665525e+00, 1.0)) * dx
               + vec4( 2.7020009990618670e+00,  4.0347562651590141e-01, -1.5434152457472157e+00, 1.0)) * dx
               + vec4( 2.5864285714285701e-01,  7.3171428571428598e-01,  5.9542857142857097e-01, 1.0);
    } else if (x < 5.6250000000000000e-01) {
        float dx = x - 5.4687500000000000e-01;
        return ((vec4(-7.8540912219456771e+01, -1.8509114083431125e+01,  3.3113477160250433e+01, 1.0) * dx
               + vec4( 5.7654574029050307e+00, -2.1418881245302965e+00,  7.1267286237156402e-01, 1.0)) * dx
               + vec4( 2.8727849935721714e+00,  3.4701440005485251e-01, -1.5500389061033872e+00, 1.0)) * dx
               + vec4( 3.0217142857142898e-01,  7.3760476190476199e-01,  5.7118571428571396e-01, 1.0);
    } else if (x < 5.7812500000000000e-01) {
        float dx = x - 5.6250000000000000e-01;
        return ((vec4(-5.8163891236508938e+01,  9.6920884524980497e+00,  3.0320583052976861e+01, 1.0) * dx
               + vec4( 2.0838521426179946e+00, -3.0095028471911305e+00,  2.2648671042583031e+00, 1.0)) * dx
               + vec4( 2.9954304552209687e+00,  2.6652391612170523e-01, -1.5035148441247956e+00, 1.0)) * dx
               + vec4( 3.4816666666666701e-01,  7.4243333333333295e-01,  5.4726666666666701e-01, 1.0);
    } else if (x < 5.9375000000000000e-01) {
        float dx = x - 5.7812500000000000e-01;
        return ((vec4(-6.4543256167712116e+01, -2.8636353652780144e-01,  2.8905906284068501e+00, 1.0) * dx
               + vec4(-6.4258025909336181e-01, -2.5551862009802844e+00,  3.6861444348665935e+00, 1.0)) * dx
               + vec4( 3.0179503284010409e+00,  1.7957564974402687e-01, -1.4105302888259692e+00, 1.0)) * dx
               + vec4( 3.9525714285714297e-01,  7.4590000000000001e-01,  5.2444285714285699e-01, 1.0);
    } else if (x < 6.0937500000000000e-01) {
        float dx = x - 5.9375000000000000e-01;
        return ((vec4(-2.4450284092939786e+01,  1.3922851408411924e+01, -1.6916850328844372e+01, 1.0) * dx
               + vec4(-3.6680453919548675e+00, -2.5686094917550251e+00,  3.8216408705731646e+00, 1.0)) * dx
               + vec4( 2.9505968026034126e+00,  9.9516342045037676e-02, -1.2932211434284731e+00, 1.0)) * dx
               + vec4( 4.4200952380952402e-01,  7.4808095238095196e-01,  5.0331428571428605e-01, 1.0);
    } else if (x < 6.2500000000000000e-01) {
        float dx = x - 6.0937500000000000e-01;
        return ((vec4( 1.2547821111311350e+01,  1.5748329330961459e+01, -1.7611303598786566e+01, 1.0) * dx
               + vec4(-4.8141524588114200e+00, -1.9159758319857161e+00,  3.0286635114085847e+00, 1.0)) * dx
               + vec4( 2.8180624611851890e+00,  2.9444696361588602e-02, -1.1861851374600081e+00, 1.0)) * dx
               + vec4( 4.8712380952380901e-01,  7.4906190476190504e-01,  4.8397619047619100e-01, 1.0);
    } else if (x < 6.4062500000000000e-01) {
        float dx = x - 6.2500000000000000e-01;
        return ((vec4( 9.2115329809656430e+00, -3.2661877796437579e+00, -1.2675733711774058e+00, 1.0) * dx
               + vec4(-4.2259733442187004e+00, -1.1777728945968977e+00,  2.2031336552154643e+00, 1.0)) * dx
               + vec4( 2.6768104955128438e+00, -1.8895127491264742e-02, -1.1044383067315073e+00, 1.0)) * dx
               + vec4( 5.3002857142857096e-01,  7.4911428571428595e-01,  4.6611428571428598e-01, 1.0);
    } else if (x < 6.5625000000000000e-01) {
        float dx = x - 6.4062500000000000e-01;
        return ((vec4( 1.4269589821681299e+01,  7.3028598827757278e+00, -8.5260219639800940e+00, 1.0) * dx
               + vec4(-3.7941827357359359e+00, -1.3308754467676989e+00,  2.1437161534415234e+00, 1.0)) * dx
               + vec4( 2.5514955567635522e+00, -5.8092757825086563e-02, -1.0365187784712420e+00, 1.0)) * dx
               + vec4( 5.7085714285714295e-01,  7.4851904761904797e-01,  4.4939047619047601e-01, 1.0);
    } else if (x < 6.7187500000000000e-01) {
        float dx = x - 6.5625000000000000e-01;
        return ((vec4( 8.6083934467238432e+00,  2.6914824850885094e-01, -1.7057138772896455e+01, 1.0) * dx
               + vec4(-3.1252957128446250e+00, -9.8855388976258662e-01,  1.7440588738799565e+00, 1.0)) * dx
               + vec4( 2.4433787060044811e+00, -9.4333841208372265e-02, -9.7577229366934382e-01, 1.0)) * dx
               + vec4( 6.0985238095238103e-01,  7.4731428571428604e-01,  4.3368571428571401e-01, 1.0);
    } else if (x < 6.8750000000000000e-01) {
        float dx = x - 6.7187500000000000e-01;
        return ((vec4( 8.7188554392023345e+00,  1.7834947123447904e+01, -1.8886229447019101e+00, 1.0) * dx
               + vec4(-2.7217772700294449e+00, -9.7593756561373424e-01,  9.4450549390043514e-01, 1.0)) * dx
               + vec4( 2.3520181906470738e+00, -1.2502902019862727e-01, -9.3376347542277516e-01, 1.0)) * dx
               + vec4( 6.4729999999999999e-01,  7.4560000000000004e-01,  4.1880000000000001e-01, 1.0);
    } else if (x < 7.0312500000000000e-01) {
        float dx = x - 6.8750000000000000e-01;
        return ((vec4( 8.9449847961700044e+00, -2.1676746266635202e+01, -4.0993789718798466e+00, 1.0) * dx
               + vec4(-2.3130809213168355e+00, -1.3992441920211368e-01,  8.5597629336753311e-01, 1.0)) * dx
               + vec4( 2.2733485314072883e+00, -1.4246436371137491e-01, -9.0563094749671313e-01, 1.0)) * dx
               + vec4( 6.8341904761904804e-01,  7.4347619047619096e-01,  4.0443333333333298e-01, 1.0);
    } else if (x < 7.1875000000000000e-01) {
        float dx = x - 7.0312500000000000e-01;
        return ((vec4( 1.1674919661892304e+01,  2.3933066515154213e+01, -1.1673175453308831e+01, 1.0) * dx
               + vec4(-1.8937847589963666e+00, -1.1560219004506387e+00,  6.6381790406066532e-01, 1.0)) * dx
               + vec4( 2.2076162551523946e+00, -1.6271352495594915e-01, -8.8188416316189755e-01, 1.0)) * dx
               + vec4( 7.1840952380952405e-01,  7.4113333333333298e-01,  3.9047619047618998e-01, 1.0);
    } else if (x < 7.3437500000000000e-01) {
        float dx = x - 7.1875000000000000e-01;
        return ((vec4(-4.4641682053710623e+00,  2.0910706819426692e+00,  4.6048045942407727e+00, 1.0) * dx
               + vec4(-1.3465228998451648e+00, -3.4159407552784897e-02,  1.1663780468681384e-01, 1.0)) * dx
               + vec4( 2.1569864479829954e+00, -1.8131010789350266e-01, -8.6968954271271826e-01, 1.0)) * dx
               + vec4( 7.5248571428571398e-01,  7.3839999999999995e-01,  3.7681428571428599e-01, 1.0);
    } else if (x < 7.5000000000000000e-01) {
        float dx = x - 7.3437500000000000e-01;
        return ((vec4( 1.2423276968973711e+01, -6.0829492432479162e+00, -2.1725700066572116e+01, 1.0) * dx
               + vec4(-1.5557807844719334e+00,  6.3859530663277708e-02,  3.3248802004185007e-01, 1.0)) * dx
               + vec4( 2.1116379529155407e+00, -1.8084604346990121e-01, -8.6267195170133282e-01, 1.0)) * dx
               + vec4( 7.8584285714285695e-01,  7.3556666666666704e-01,  3.6327142857142902e-01, 1.0);
    } else if (x < 7.6562500000000000e-01) {
        float dx = x - 7.5000000000000000e-01;
        return ((vec4( 3.4549460436900552e+00,  2.2240726291601970e+01, -7.5799471847609725e+00, 1.0) * dx
               + vec4(-9.7343967655129060e-01, -2.2127871511396835e-01, -6.8590417057871789e-01, 1.0)) * dx
               + vec4( 2.0721188832120530e+00, -1.8330571822694325e-01, -8.6819407905347146e-01, 1.0)) * dx
               + vec4( 8.1850476190476196e-01,  7.3273333333333301e-01,  3.4979047619047599e-01, 1.0);
    } else if (x < 7.8125000000000000e-01) {
        float dx = x - 7.6562500000000000e-01;
        return ((vec4( 8.7094721894791203e+00,  1.3239510743088688e+01, -2.2852796908624047e+01, 1.0) * dx
               + vec4(-8.1148908075331927e-01,  8.2125532980487381e-01, -1.0412141948643885e+00, 1.0)) * dx
               + vec4( 2.0442293713791684e+00, -1.7393108362239784e-01, -8.9518030351351996e-01, 1.0)) * dx
               + vec4( 8.5065714285714300e-01,  7.2989999999999999e-01,  3.3602857142857101e-01, 1.0);
    } else if (x < 7.9687500000000000e-01) {
        float dx = x - 7.8125000000000000e-01;
        return ((vec4(-1.2078434801289291e+01,  4.3390183117236198e+01, -3.9570693752303733e+01, 1.0) * dx
               + vec4(-4.0323257187148548e-01,  1.4418573958871561e+00, -2.1124390499561407e+00, 1.0)) * dx
               + vec4( 2.0252493455569058e+00, -1.3856994728345987e-01, -9.4445613546384066e-01, 1.0)) * dx
               + vec4( 8.8243333333333296e-01,  7.2743333333333304e-01,  3.2169999999999999e-01, 1.0);
    } else if (x < 8.1250000000000000e-01) {
        float dx = x - 7.9687500000000000e-01;
        return ((vec4(-1.2824532984374384e+01,  1.1653781393088177e+02, -1.1096774236821523e+02, 1.0) * dx
               + vec4(-9.6940920318192092e-01,  3.4757722295076028e+00, -3.9673153195953783e+00, 1.0)) * dx
               + vec4( 2.0038018178216963e+00, -6.1731984386666772e-02, -1.0394522974880831e+00, 1.0)) * dx
               + vec4( 9.1393333333333304e-01,  7.2578571428571403e-01,  3.0627619047619098e-01, 1.0);
    } else if (x < 8.2812500000000000e-01) {
        float dx = x - 8.1250000000000000e-01;
        return ((vec4(-3.5855044278532131e+02,  2.7064903734930277e+02, -8.0792089155266083e+01, 1.0) * dx
               + vec4(-1.5705591868244702e+00,  8.9384822575176859e+00, -9.1689282431054675e+00, 1.0)) * dx
               + vec4( 1.9641148117278464e+00,  1.3224074197310332e-01, -1.2447061031552840e+00, 1.0)) * dx
               + vec4( 9.4495714285714305e-01,  7.2611428571428605e-01,  2.8864285714285698e-01, 1.0);
    } else if (x < 8.4375000000000000e-01) {
        float dx = x - 8.2812500000000000e-01;
        return ((vec4(-3.8174017206443654e+02, -1.9549693475620506e+02,  4.4911575613188438e+02, 1.0) * dx
               + vec4(-1.8377611192386407e+01,  2.1625155883266252e+01, -1.2956057422258565e+01, 1.0)) * dx
               + vec4( 1.6524246495526764e+00,  6.0979758792285232e-01, -1.5904090041765968e+00, 1.0)) * dx
               + vec4( 9.7389523809523804e-01,  7.3139523809523799e-01,  2.6664761904761902e-01, 1.0);
    } else if (x < 8.5937500000000000e-01) {
        float dx = x - 8.4375000000000000e-01;
        return ((vec4( 4.3248438818547703e+02, -2.7134838403902307e+02,  3.3204036056432756e+01, 1.0) * dx
               + vec4(-3.6271681757906869e+01,  1.2461237066569140e+01,  8.0962436464235150e+00, 1.0)) * dx
               + vec4( 7.9852944720434427e-01,  1.1423974777640304e+00, -1.6663435944240195e+00, 1.0)) * dx
               + vec4( 9.9377142857142897e-01,  7.4545714285714304e-01,  2.4034761904761900e-01, 1.0);
    } else if (x < 8.7500000000000000e-01) {
        float dx = x - 8.5937500000000000e-01;
        return ((vec4( 1.7847934313241271e+02, -6.1117386114828536e+00, -1.0882439559595376e+02, 1.0) * dx
               + vec4(-1.5998976061712632e+01, -2.5821843526006538e-01,  9.6526828365688004e+00, 1.0)) * dx
               + vec4(-1.8199581227210410e-02,  1.3330696438782346e+00, -1.3890166181272647e+00, 1.0)) * dx
               + vec4( 9.9904285714285701e-01,  7.6531428571428595e-01,  2.1641428571428600e-01, 1.0);
    } else if (x < 8.9062500000000000e-01) {
        float dx = x - 8.7500000000000000e-01;
        return ((vec4( 1.0065469642774150e+02,  1.1181852770679304e+01, -4.2302948910418884e+01, 1.0) * dx
               + vec4(-7.6327568523807861e+00, -5.4470618267332416e-01,  4.5515392930084682e+00, 1.0)) * dx
               + vec4(-3.8744540800992006e-01,  1.3205239467230254e+00, -1.1670756473526198e+00, 1.0)) * dx
               + vec4( 9.9553333333333305e-01,  7.8605714285714301e-01,  1.9665238095238100e-01, 1.0);
    } else if (x < 9.0625000000000000e-01) {
        float dx = x - 8.9062500000000000e-01;
        return ((vec4( 5.1792385442186948e+01,  1.3813127528788970e+01, -4.7771351619749993e+01, 1.0) * dx
               + vec4(-2.9145679573304033e+00, -2.0556834047731776e-02,  2.5685885628325829e+00, 1.0)) * dx
               + vec4(-5.5224735816165738e-01,  1.3116917120867588e+00, -1.0558236496051034e+00, 1.0)) * dx
               + vec4( 9.8799999999999999e-01,  8.0659999999999998e-01,  1.7936666666666701e-01, 1.0);
    } else if (x < 9.2187500000000000e-01) {
        float dx = x - 9.0625000000000000e-01;
        return ((vec4( 1.1035785704157649e+02,  5.2154589495154021e+01, -3.9990387467675163e+01, 1.0) * dx
               + vec4(-4.8679988972789023e-01,  6.2693351886425119e-01,  3.2930645565680206e-01, 1.0)) * dx
               + vec4(-6.0539373077194325e-01,  1.3211663477870170e+00, -1.0105440399412067e+00, 1.0)) * dx
               + vec4( 9.7885714285714298e-01,  8.2714285714285696e-01,  1.6331428571428599e-01, 1.0);
    } else if (x < 9.3750000000000000e-01) {
        float dx = x - 9.2187500000000000e-01;
        return ((vec4( 4.6043843534396274e+01,  2.0987943062129727e+01, -2.3203479461840441e+01, 1.0) * dx
               + vec4( 4.6862246590960082e+00,  3.0716799014495959e+00, -1.5452429568904713e+00, 1.0)) * dx
               + vec4(-5.3977771875056635e-01,  1.3789571824794209e+00, -1.0295430477729828e+00, 1.0)) * dx
               + vec4( 9.6970000000000001e-01,  8.4813809523809502e-01,  1.4745238095238100e-01, 1.0);
    } else if (x < 9.5312500000000000e-01) {
        float dx = x - 9.3750000000000000e-01;
        return ((vec4( 6.1233625963980650e+01,  2.8669866827404956e+01,  2.4201791029260814e+01, 1.0) * dx
               + vec4( 6.8445298247708335e+00,  4.0554897324869268e+00, -2.6329060566642419e+00, 1.0)) * dx
               + vec4(-3.5960967994014698e-01,  1.4903192080096790e+00, -1.0948266261097752e+00, 1.0)) * dx
               + vec4( 9.6258571428571404e-01,  8.7051428571428602e-01,  1.3089999999999999e-01, 1.0);
    } else if (x < 9.6875000000000000e-01) {
        float dx = x - 9.5312500000000000e-01;
        return ((vec4( 4.1070719275903762e+01,  5.3910277236601019e+00,  2.0019172487757277e+01, 1.0) * dx
               + vec4( 9.7148560418324266e+00,  5.3993897400215340e+00, -1.4984471021676413e+00, 1.0)) * dx
               + vec4(-1.0086927577447102e-01,  1.6380516997676238e+00, -1.1593790192165234e+00, 1.0)) * dx
               + vec4( 9.5887142857142904e-01,  8.9490000000000003e-01,  1.1324285714285701e-01, 1.0);
    } else if (x < 9.8437500000000000e-01) {
        float dx = x - 9.6875000000000000e-01;
        return ((vec4(-5.3250445924665847e+01, -1.6529749150400146e+01, -1.4422423336140781e+02, 1.0) * dx
               + vec4( 1.1640046007890415e+01,  5.6520941645681013e+00, -5.6004839180401900e-01, 1.0)) * dx
               + vec4( 2.3280106875244833e-01,  1.8107311357768368e+00, -1.1915430113098306e+00, 1.0)) * dx
               + vec4( 9.5982380952380997e-01,  9.2183333333333295e-01,  9.4838095238095305e-02, 1.0);
    } else if (x < 1.0000000000000000e+00) {
        float dx = x - 9.8437500000000000e-01;
        return ((vec4(-1.9507053557699635e+02, -1.0404825969371934e+02,  1.5617193238656020e+02, 1.0) * dx
               + vec4( 9.1439313551717039e+00,  4.8772621731430945e+00, -7.3205593306200099e+00, 1.0)) * dx
               + vec4( 5.5755071505029385e-01,  1.9752523285535741e+00, -1.3146775069727061e+00, 1.0)) * dx
               + vec4( 9.6609999999999996e-01,  9.5144285714285703e-01,  7.5533333333333300e-02, 1.0);
    } else {
        float dx = x - 1.0000000000000000e+00;
        return ((vec4( 0.0000000000000000e+00,  3.4202936336155174e+00,  3.0625241907655076e+00, 1.0) * dx
               + vec4( 0.0000000000000000e+00,  0.0000000000000000e+00,  0.0000000000000000e+00, 1.0)) * dx
               + vec4( 0.0000000000000000e+00,  0.0000000000000000e+00,  0.0000000000000000e+00, 1.0)) * dx
               + vec4( 9.7629999999999995e-01,  9.8309999999999997e-01,  5.3800000000000001e-02, 1.0);
    }
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }
}
`,hr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdBu.frag
float colormap_red(float x) {
	if (x < 0.09771832105856419) {
		return 7.60263247863246E+02 * x + 1.02931623931624E+02;
	} else if (x < 0.3017162107441106) {
		return (-2.54380938558548E+02 * x + 4.29911571188803E+02) * x + 1.37642085716717E+02;
	} else if (x < 0.4014205790737471) {
		return 8.67103448276151E+01 * x + 2.18034482758611E+02;
	} else if (x < 0.5019932233215039) {
		return -6.15461538461498E+01 * x + 2.77547692307680E+02;
	} else if (x < 0.5969483882550937) {
		return -3.77588522588624E+02 * x + 4.36198819698878E+02;
	} else if (x < 0.8046060096654594) {
		return (-6.51345897546620E+02 * x + 2.09780968434337E+02) * x + 3.17674951640855E+02;
	} else {
		return -3.08431855203590E+02 * x + 3.12956742081421E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09881640500975222) {
		return 2.41408547008547E+02 * x + 3.50427350427364E-01;
	} else if (x < 0.5000816285610199) {
		return ((((1.98531871433258E+04 * x - 2.64108262469187E+04) * x + 1.10991785969817E+04) * x - 1.92958444776211E+03) * x + 8.39569642882186E+02) * x - 4.82944517518776E+01;
	} else if (x < 0.8922355473041534) {
		return (((6.16712686949223E+03 * x - 1.59084026055125E+04) * x + 1.45172137257997E+04) * x - 5.80944127411621E+03) * x + 1.12477959061948E+03;
	} else {
		return -5.28313797313699E+02 * x + 5.78459299959206E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.1033699568661857) {
		return 1.30256410256410E+02 * x + 3.08518518518519E+01;
	} else if (x < 0.2037526071071625) {
		return 3.38458128078815E+02 * x + 9.33004926108412E+00;
	} else if (x < 0.2973267734050751) {
		return (-1.06345054944861E+02 * x + 5.93327252747168E+02) * x - 3.81852747252658E+01;
	} else if (x < 0.4029109179973602) {
		return 6.68959706959723E+02 * x - 7.00740740740798E+01;
	} else if (x < 0.5006715489526758) {
		return 4.87348695652202E+02 * x + 3.09898550724286E+00;
	} else if (x < 0.6004396902588283) {
		return -6.85799999999829E+01 * x + 2.81436666666663E+02;
	} else if (x < 0.702576607465744) {
		return -1.81331701891043E+02 * x + 3.49137263626287E+02;
	} else if (x < 0.9010407030582428) {
		return (2.06124143164576E+02 * x - 5.78166906665595E+02) * x + 5.26198653917172E+02;
	} else {
		return -7.36990769230737E+02 * x + 8.36652307692262E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,vr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,gr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap(1.0 - (A-0.4)*(1.0/0.6));


    if (A > 0.6) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,xr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/transform_seismic.frag
float colormap_f(float x) {
    return ((-2010.0 * x + 2502.5950459) * x - 481.763180924) / 255.0;
}

float colormap_red(float x) {
    if (x < 0.0) {
        return 3.0 / 255.0;
    } else if (x < 0.238) {
        return ((-1810.0 * x + 414.49) * x + 3.87702) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return (344441250.0 / 323659.0 * x - 23422005.0 / 92474.0) / 255.0;
    } else if (x < 25851.0 / 34402.0) {
        return 1.0;
    } else if (x <= 1.0) {
        return (-688.04 * x + 772.02) / 255.0;
    } else {
        return 83.0 / 255.0;
    }
}

float colormap_green(float x) {
    if (x < 0.0) {
        return 0.0;
    } else if (x < 0.238) {
        return 0.0;
    } else if (x < 51611.0 / 108060.0) {
        return colormap_f(x);
    } else if (x < 0.739376978894039) {
        float xx = x - 51611.0 / 108060.0;
        return ((-914.74 * xx - 734.72) * xx + 255.) / 255.0;
    } else {
        return 0.0;
    }
}

float colormap_blue(float x) {
    if (x < 0.0) {
        return 19.0 / 255.0;
    } else if (x < 0.238) {
        float xx = x - 0.238;
        return (((1624.6 * xx + 1191.4) * xx + 1180.2) * xx + 255.0) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return 1.0;
    } else if (x < 174.5 / 256.0) {
        return (-951.67322673866 * x + 709.532730938451) / 255.0;
    } else if (x < 0.745745353439206) {
        return (-705.250074130877 * x + 559.620050530617) / 255.0;
    } else if (x <= 1.0) {
        return ((-399.29 * x + 655.71) * x - 233.25) / 255.0;
    } else {
        return 23.0 / 255.0;
    }
}

vec4 colormap(float x) {
    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,_r=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((B-0.1)*(1.0/0.9));


    if (B < 0.1) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,he={},br=a=>{const e={vert:nr,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{iteration:a.prop("iteration"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}};he.raw=a({frag:or,...e}),he.A_transform_seismic=a({frag:xr,...e}),he.A_gradiant1=a({frag:ur,...e}),he.A_gradiant2=a({frag:pr,...e}),he.A_MATLAB_cool=a({frag:mr,...e}),he.A_MATLAB_parula=a({frag:dr,...e}),he.A_IDL_CB_RdBu=a({frag:hr,...e}),he.A_IDL_CB_RdYiBu=a({frag:vr,...e}),he.A_IDL_CB_BuYiRd=a({frag:gr,...e}),he.B_IDL_CB_RdYiBu=a({frag:_r,...e}),he.grayscale=a({frag:ir,...e}),he.blackwhite=a({frag:ar,...e}),he.whiteblack=a({frag:lr,...e}),he.timebasedblue=a({frag:rr,...e}),he.lerp=a({frag:sr,...e}),he.mrob=a({frag:fr,...e}),he.redblue=a({frag:cr,...e})},wr=a=>{const{colorMode:e,inputBuffer:n,iteration:o,outputBuffer:t,zoomState:i}=a;(he[e]||he.raw)({inputBuffer:n,iteration:o,outputBuffer:t,pan:[i.panX,i.panY],zoomLevel:i.zoomLevel})},$r=`precision mediump float;

uniform float radius;
uniform sampler2D prevState;
uniform bool pauseSimulation;
uniform float Da;
uniform float Db;
uniform float f;
uniform float k;

uniform bool penIsActive;
uniform bool eraserIsActive;
uniform float penDensity;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

// https://thebookofshaders.com/10/
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
}

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(radius)).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(radius)).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(radius)).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(radius)).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(radius)).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(radius)).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(radius)).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(radius)).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(radius)).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));


    float rnd = random(uv);
    if (penIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(0.0, 1.0, 0, 1);
    } else if (eraserIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(1.0, 0.0, 0, 1);
    } else if (pauseSimulation) {
        gl_FragColor = vec4(A, B, 0, 1);
    } else {
        gl_FragColor = vec4(newA, newB, 0, 1);
    }
}
`,kr=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
uniform float penRadius;

attribute vec2 position;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

void main() {
    uv = 0.5 * (position + 1.0);
    mouseUv = (mousePosition * zoomLevel) + pan * (1.0 - zoomLevel);
    scaledPenRadius = penRadius * zoomLevel;
    gl_Position = vec4(position, 0, 1);
}
`;let mn;const yr=(a,e)=>{mn=a({frag:$r,vert:kr,attributes:{position:[-4,-4,4,-4,0,4]},count:3,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),Da:1,Db:.5,f:a.prop("f"),k:a.prop("k"),radius:e,pauseSimulation:a.prop("pauseSimulation"),mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),penDensity:a.prop("penDensity"),penIsActive:a.prop("penIsActive"),eraserIsActive:a.prop("eraserIsActive"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},Sr=a=>{const{inputBuffer:e,outputBuffer:n,pauseSimulation:o,mouseState:t,simulationParameters:i,worldSize:r}=a;mn({inputBuffer:e,outputBuffer:n,pauseSimulation:o,zoomLevel:t.zoomLevel,pan:[t.panX,t.panY],mousePosition:[t.x,t.y],penRadius:1/2**(r-t.penSize),penDensity:t.penDensity,penIsActive:t.pressedLeft,eraserIsActive:t.pressedRight,...i})},Er=(a,e)=>a==="randomSpots"?zr(e,.001):a==="middleCircleAndRandomSpots"?Ar(e,.005,.05):a==="empty"?Dr(e):Br(e,.02),Ar=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},Dr=a=>Array(a*a).fill(0).map(()=>[0,0,0,1]).flat(),zr=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),Br=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),Cr=`precision highp float;

attribute vec2 position;

uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,Tr=`precision highp float;

uniform sampler2D prevState;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float division = 10.0;
    float column = mod(uv.x, 1.0 / division);
    float c = column * division;

    float row = mod(uv.y, 1.0 / division);
    float r = row * division;

    // I haven't found a way to compare the value to an exact value
    // Might be a precision issue, or just that I'm missing something
    if (c < 0.05 || r < 0.05) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
       gl_FragColor = color;
    }
}
`;let dn;const Ir=a=>{dn=a({vert:Cr,frag:Tr,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},Lr=a=>{const{inputBuffer:e,outputBuffer:n,zoomState:o}=a;dn({inputBuffer:e,outputBuffer:n,zoomLevel:o.zoomLevel,pan:[o.panX,o.panY]})},Rr=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

attribute vec2 position;

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}
`,Pr=`precision mediump float;

uniform sampler2D prevState;
uniform vec2 mousePosition;
uniform float penRadius;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float d = distance(uv, mousePosition);
    if (
        (d >= penRadius && d <= penRadius + 0.001) ||
        (uv.x >= mousePosition.x - 0.001 && uv.x <= mousePosition.x + 0.001 && uv.y >= mousePosition.y - 0.01 && uv.y <= mousePosition.y + 0.01) ||
        (uv.x >= mousePosition.x - 0.01 && uv.x <= mousePosition.x + 0.01 && uv.y >= mousePosition.y - 0.001 && uv.y <= mousePosition.y + 0.001))
    {
        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    } else {
        gl_FragColor = color;
    }
}
`;let hn;const Fr=a=>{hn=a({frag:Pr,vert:Rr,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}})},Mr=a=>{const{inputBuffer:e,mouseState:n,outputBuffer:o,worldSize:t}=a;hn({inputBuffer:e,outputBuffer:o,mousePosition:[n.x,n.y],penRadius:1/2**(t-n.penSize),zoomLevel:n.zoomLevel,pan:[n.panX,n.panY]})},vn=a=>{const{controls:e,info:n,mouseState:o,simulationParameters:t}=a,i=document.getElementById("canvas");if(!i)throw new Error("Canvas container not ready");const r=Re({extensions:["OES_texture_float"],canvas:i});n.iteration=0;const s=2**n.worldSize,l=Er(e.initialConditions,s),f=()=>r.framebuffer({color:r.texture({radius:s,data:l,wrap:"repeat",type:"float"}),depthStencil:!1}),c=Array(2).fill(0).map(f),u=Array(2).fill(0).map(f);return yr(r,s),br(r),Ir(r),Fr(r),r.frame(()=>{e.pause||n.iteration++;let p=c[(n.iteration+1)%2];for(let m=0;m<e.speed;m++){n.iteration++;const d=c[n.iteration%2];p=c[(n.iteration+1)%2],Sr({inputBuffer:d,outputBuffer:p,worldSize:n.worldSize,pauseSimulation:e.pause,mouseState:o,simulationParameters:t})}Ur({inputTexture:p,graphicsTextures:u,controls:e,info:n,mouseState:o})}),r},Ur=a=>{const{inputTexture:e,graphicsTextures:n,controls:o,info:t,mouseState:i}=a;let r=0;r++;const s=e;let l=n[r%2];if(!o.grid&&!o.pen&&(l=null),wr({colorMode:o.colors,inputBuffer:s,iteration:t.iteration,outputBuffer:l,zoomState:i}),o.grid){r++;const f=n[(r+1)%2];let c=n[r%2];o.pen||(c=null),Lr({inputBuffer:f,outputBuffer:c,zoomState:i})}if(o.pen){r++;const f=n[(r+1)%2],c=null;Mr({mouseState:i,worldSize:t.worldSize,inputBuffer:f,outputBuffer:c})}};const{window:Nr}=je;function Vr(a){let e,n,o,t,i,r,s,l,f,c,u,p,m,d=2**a[0].worldSize+"",x,C,E=2**a[0].worldSize+"",S,M,v=2**(a[0].worldSize+1)+"",g,$,L,D,b,O,X;return n=new tr({}),n.$on("fkupdated",a[4]),{c(){e=z("main"),U(n.$$.fragment),o=q(),t=z("div"),i=q(),r=z("div"),s=z("label"),l=R("World Size:"),f=q(),c=z("input"),u=q(),p=z("span"),m=R("("),x=R(d),C=R(" x "),S=R(E),M=R(" : "),g=R(v),$=R(")"),L=q(),D=z("canvas"),this.h()},l(I){e=B(I,"MAIN",{});var F=T(e);G(n.$$.fragment,F),o=Y(F),t=B(F,"DIV",{id:!0,class:!0}),T(t).forEach(h),i=Y(F),r=B(F,"DIV",{});var te=T(r);s=B(te,"LABEL",{for:!0});var xe=T(s);l=P(xe,"World Size:"),xe.forEach(h),f=Y(te),c=B(te,"INPUT",{id:!0,type:!0,step:!0}),u=Y(te),p=B(te,"SPAN",{});var ae=T(p);m=P(ae,"("),x=P(ae,d),C=P(ae," x "),S=P(ae,E),M=P(ae," : "),g=P(ae,v),$=P(ae,")"),ae.forEach(h),te.forEach(h),L=Y(F),D=B(F,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(D).forEach(h),F.forEach(h),this.h()},h(){y(t,"id","datgui-container"),y(t,"class","svelte-198vt5w"),y(s,"for","worldSize"),y(c,"id","worldSize"),y(c,"type","number"),y(c,"step","1"),y(D,"id","canvas"),y(D,"width",a[1].width),y(D,"height",a[1].height),y(D,"class","svelte-198vt5w")},m(I,F){A(I,e,F),N(n,e,null),w(e,o),w(e,t),w(e,i),w(e,r),w(r,s),w(s,l),w(r,f),w(r,c),ye(c,a[0].worldSize),w(r,u),w(r,p),w(p,m),w(p,x),w(p,C),w(p,S),w(p,M),w(p,g),w(p,$),w(e,L),w(e,D),b=!0,O||(X=[Z(Nr,"keydown",a[2]),Z(c,"input",a[5]),Z(c,"change",a[3]),Z(D,"contextmenu",we(Or))],O=!0)},p(I,[F]){F&1&&Ae(c.value)!==I[0].worldSize&&ye(c,I[0].worldSize),(!b||F&1)&&d!==(d=2**I[0].worldSize+"")&&pe(x,d),(!b||F&1)&&E!==(E=2**I[0].worldSize+"")&&pe(S,E),(!b||F&1)&&v!==(v=2**(I[0].worldSize+1)+"")&&pe(g,v)},i(I){b||(_(n.$$.fragment,I),b=!0)},o(I){k(n.$$.fragment,I),b=!1},d(I){I&&h(e),V(n),O=!1,ze(X)}}}const Or=a=>a;function Hr(a,e,n){const o={width:Math.min(window.innerWidth,window.innerHeight)*.9,height:Math.min(window.innerWidth,window.innerHeight)*.9},t={colors:"A_transform_seismic",initialConditions:"middleCircleAndRandomSpots",reset:()=>d(),pause:!1,grid:!1,pen:!1,speed:50},i={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:3,penDensity:.3,zoomLevel:1,panX:.5,panY:.5},r={iteration:0,worldSize:8},s={f:Se[0].f,k:Se[0].k};let l,f;const c=async()=>{const E=await Ie(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);l=new E.GUI({autoPlace:!1,closeOnTop:!0}),l.domElement.id="datgui";const S=document.getElementById("datgui-container");if(!S)throw new Error("Gui container not ready");S.appendChild(l.domElement),l.add(t,"pause").name("Pause"),l.add(t,"grid").name("Debug grid"),l.add(t,"pen").name("Show pen"),l.add(t,"reset").name("Reset simulation"),l.add(t,"colors",["grayscale","blackwhite","whiteblack","raw","timebasedblue","lerp","mrob","redblue","A_gradiant1","A_gradiant2","A_MATLAB_cool","A_MATLAB_parula","A_IDL_CB_RdBu","A_IDL_CB_RdYiBu","A_IDL_CB_BuYiRd","A_transform_seismic","B_IDL_CB_RdYiBu"]).name("Color scheme");const M={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots",Empty:"empty"};l.add(t,"initialConditions",M).onFinishChange(t.reset).name("Initial conditions");const v=l.add(r,"iteration").listen();v.domElement.style.pointerEvents="none",l.add(t,"speed",1,200).name("Simulation speed").listen(),l.add(i,"penSize",0,r.worldSize).name("Pen size").listen(),l.add(i,"penDensity",0,1).name("Pen density"),l.add(i,"zoomLevel",0,1).name("Zoom level").listen(),l.add(i,"panX",0,1).name("pan x").listen(),l.add(i,"panY",0,1).name("pan y").listen()},u=E=>{if(E.code==="Space"){t.pause=!t.pause,E.preventDefault();return}if(E.code==="KeyR"&&!E.getModifierState("Control")){d(),E.preventDefault();return}};let p;const m=()=>{i.x=Math.random(),i.y=Math.random(),i.penSize=Math.random()*3,i.pressedLeft=!0,setTimeout(()=>i.pressedLeft=!1,500),p=setTimeout(m,Math.random()*5e3)},d=()=>{isNaN(r.worldSize)||(r.worldSize>11&&n(0,r.worldSize=11,r),r.worldSize<1&&n(0,r.worldSize=1,r),l&&(document.getElementById(l.domElement.id)?.remove(),l.destroy()),f?.destroy(),c(),f=vn({controls:t,info:r,mouseState:i,simulationParameters:s}),p&&clearTimeout(p),m())},x=E=>{s.f=E.detail.f,s.k=E.detail.k,s.f>.06?t.speed=70:s.f>.03?t.speed=50:t.speed=2};Ee(()=>{d()}),ke(()=>{l.destroy(),f.destroy()});function C(){r.worldSize=Ae(this.value),n(0,r)}return[r,o,u,d,x,C]}class Ct extends Q{constructor(e){super(),J(this,e,Hr,Vr,ee,{})}}function Tt(a,e,n){const o=a.slice();return o[17]=e[n],o}function It(a){let e,n,o,t,i,r,s,l,f,c=Se,u=[];for(let p=0;p<c.length;p+=1)u[p]=Lt(Tt(a,c,p));return r=new Le({props:{sketch:a[4]}}),{c(){e=z("div"),n=R("Select f and k parameters on the map of use a preset"),o=q(),t=z("select");for(let p=0;p<u.length;p+=1)u[p].c();i=q(),U(r.$$.fragment),this.h()},l(p){e=B(p,"DIV",{});var m=T(e);n=P(m,"Select f and k parameters on the map of use a preset"),m.forEach(h),o=Y(p),t=B(p,"SELECT",{class:!0});var d=T(t);for(let x=0;x<u.length;x+=1)u[x].l(d);d.forEach(h),i=Y(p),G(r.$$.fragment,p),this.h()},h(){y(t,"class","full-width svelte-vk9dfi"),a[0]===void 0&&it(()=>a[6].call(t))},m(p,m){A(p,e,m),w(e,n),A(p,o,m),A(p,t,m);for(let d=0;d<u.length;d+=1)u[d].m(t,null);Oe(t,a[0]),A(p,i,m),N(r,p,m),s=!0,l||(f=[Z(t,"change",a[6]),Z(t,"change",a[7])],l=!0)},p(p,m){if(m&0){c=Se;let d;for(d=0;d<c.length;d+=1){const x=Tt(p,c,d);u[d]?u[d].p(x,m):(u[d]=Lt(x),u[d].c(),u[d].m(t,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}m&1&&Oe(t,p[0])},i(p){s||(_(r.$$.fragment,p),s=!0)},o(p){k(r.$$.fragment,p),s=!1},d(p){p&&h(e),p&&h(o),p&&h(t),$e(u,p),p&&h(i),V(r,p),l=!1,ze(f)}}}function Lt(a){let e,n=a[17].type+"",o,t,i=a[17].name+"",r,s,l=a[17].f+"",f,c,u=a[17].k+"",p,m;return{c(){e=z("option"),o=R(n),t=R(" - "),r=R(i),s=R(" (f/k "),f=R(l),c=R(" / "),p=R(u),m=R(`)
                `),this.h()},l(d){e=B(d,"OPTION",{});var x=T(e);o=P(x,n),t=P(x," - "),r=P(x,i),s=P(x," (f/k "),f=P(x,l),c=P(x," / "),p=P(x,u),m=P(x,`)
                `),x.forEach(h),this.h()},h(){e.__value=a[17],e.value=e.__value},m(d,x){A(d,e,x),w(e,o),w(e,t),w(e,r),w(e,s),w(e,f),w(e,c),w(e,p),w(e,m)},p:ne,d(d){d&&h(e)}}}function Kr(a){let e,n,o=a[1]?"Close":"F/K selection",t,i,r,s,l,f=a[1]&&It(a);return{c(){e=z("div"),n=z("button"),t=R(o),i=q(),f&&f.c(),this.h()},l(c){e=B(c,"DIV",{id:!0,class:!0});var u=T(e);n=B(u,"BUTTON",{class:!0,id:!0});var p=T(n);t=P(p,o),p.forEach(h),i=Y(u),f&&f.l(u),u.forEach(h),this.h()},h(){y(n,"class","full-width svelte-vk9dfi"),y(n,"id","toggleButton"),y(e,"id","container"),y(e,"class","svelte-vk9dfi"),Te(e,"no-cursor",a[2])},m(c,u){A(c,e,u),w(e,n),w(n,t),w(e,i),f&&f.m(e,null),r=!0,s||(l=Z(n,"click",a[5]),s=!0)},p(c,[u]){(!r||u&2)&&o!==(o=c[1]?"Close":"F/K selection")&&pe(t,o),c[1]?f?(f.p(c,u),u&2&&_(f,1)):(f=It(c),f.c(),_(f,1),f.m(e,null)):f&&(oe(),k(f,1,1,()=>{f=null}),re()),(!r||u&4)&&Te(e,"no-cursor",c[2])},i(c){r||(_(f),r=!0)},o(c){k(f),r=!1},d(c){c&&h(e),f&&f.d(),s=!1,l()}}}function qr(a,e,n){const o=Xe();let t=Se[0],i=!0;const r=[0,.12],s=[.03,.07],l=v=>{const{f:g,k:$}=v,L=d.map($,s[0],s[1],0,d.width),D=d.map(g,r[0],r[1],d.height,0);return{x:L,y:D}},f=v=>{const{x:g,y:$}=v,L=d.map($,d.height,0,r[0],r[1]),D=d.map(g,0,d.width,s[0],s[1]);return{f:L,k:D}},c=v=>{const g=v.mouseX,$=v.mouseY;if(g<0||$<0||g>v.width||$>v.height)return;const{f:L,k:D}=f({x:v.mouseX,y:v.mouseY});n(0,t={f:L,k:D,name:"custom",type:"manual"}),o("fkupdated",t)},u=v=>{v.noStroke();const g=v.textSize();for(const $ of Se){const{x:L,y:D}=l({f:$.f,k:$.k}),b=$.f===t.f&&$.k===t.k;v.circle(L,D,3),v.textSize(b?g*2:g),v.fill(b?[240,240,150]:[255,255,255]),v.text($.name,L-v.textWidth($.name)/2,D-10)}},p=v=>{v.noFill(),v.stroke("red");const{x:g,y:$}=l(t);v.text("F",10,$>10?$-5:$+15),v.line(0,$,v.width,$),v.text("K",g<v.width-10?g+5:g-15,v.height-10),v.line(g,0,g,v.height),v.circle(g,$,10)},m=v=>{const{f:g,k:$}=t,L=`F: ${g.toFixed(4)}`,D=`K: ${$.toFixed(4)}`,b=v.textSize(),O=v.height*.05;v.textStyle(v.BOLD),v.textSize(O),v.fill("white"),v.stroke(0),v.strokeWeight(1),v.text(L,v.width*.05,v.textSize()),v.text(D,v.width*.05,v.textSize()+v.textSize()+6),v.textStyle(v.NORMAL),v.textSize(b)};let d,x=!1;const C=v=>{d=v;let g;v.preload=()=>{g=v.loadImage(Ze+"/parameters_map.png")},v.setup=()=>{v.createCanvas(400,400),v.frameRate(55)},v.draw=()=>{v.background(255),v.tint(150,190),v.image(g,0,0,v.width,v.height),u(v),p(v),m(v),n(2,x=!1),v.mouseIsPressed&&(c(v),n(2,x=!0))}},E=()=>{n(1,i=!i),i||d.remove()};ke(()=>d?.remove());function S(){t=at(this),n(0,t)}return[t,i,x,o,C,E,S,()=>o("fkupdated",t)]}let Yr=class extends Q{constructor(e){super(),J(this,e,qr,Kr,ee,{})}};const Rt=a=>{if(!a.currentTarget)throw new Error("Event has no currentTarget");const e=a.currentTarget,n=e.getBoundingClientRect(),o=a.clientX-n.left,t=a.clientY-n.top,{width:i,height:r}=e,s=o/i,l=(r-t)/r;return{x:s,y:l}};const{window:Gr}=je;function Wr(a){let e,n,o,t,i,r,s,l,f,c,u,p,m,d=2**a[0].worldSize+"",x,C,E=2**a[0].worldSize+"",S,M,v=2**(a[0].worldSize+1)+"",g,$,L,D,b,O,X;return n=new Yr({}),n.$on("fkupdated",a[7]),{c(){e=z("main"),U(n.$$.fragment),o=q(),t=z("div"),i=q(),r=z("div"),s=z("label"),l=R("World Size:"),f=q(),c=z("input"),u=q(),p=z("span"),m=R("("),x=R(d),C=R(" x "),S=R(E),M=R(" : "),g=R(v),$=R(")"),L=q(),D=z("canvas"),this.h()},l(I){e=B(I,"MAIN",{});var F=T(e);G(n.$$.fragment,F),o=Y(F),t=B(F,"DIV",{id:!0,class:!0}),T(t).forEach(h),i=Y(F),r=B(F,"DIV",{});var te=T(r);s=B(te,"LABEL",{for:!0});var xe=T(s);l=P(xe,"World Size:"),xe.forEach(h),f=Y(te),c=B(te,"INPUT",{id:!0,type:!0,step:!0}),u=Y(te),p=B(te,"SPAN",{});var ae=T(p);m=P(ae,"("),x=P(ae,d),C=P(ae," x "),S=P(ae,E),M=P(ae," : "),g=P(ae,v),$=P(ae,")"),ae.forEach(h),te.forEach(h),L=Y(F),D=B(F,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(D).forEach(h),F.forEach(h),this.h()},h(){y(t,"id","datgui-container"),y(t,"class","svelte-18zf5fr"),y(s,"for","worldSize"),y(c,"id","worldSize"),y(c,"type","number"),y(c,"step","1"),y(D,"id","canvas"),y(D,"width",a[1].width),y(D,"height",a[1].height),y(D,"class","svelte-18zf5fr")},m(I,F){A(I,e,F),N(n,e,null),w(e,o),w(e,t),w(e,i),w(e,r),w(r,s),w(s,l),w(r,f),w(r,c),ye(c,a[0].worldSize),w(r,u),w(r,p),w(p,m),w(p,x),w(p,C),w(p,S),w(p,M),w(p,g),w(p,$),w(e,L),w(e,D),b=!0,O||(X=[Z(Gr,"keydown",a[2]),Z(c,"input",a[8]),Z(c,"change",a[6]),Z(D,"mousemove",a[4]),Z(D,"mousedown",we(a[5])),Z(D,"mouseup",a[5]),Z(D,"wheel",a[3]),Z(D,"keydown",we(a[2])),Z(D,"contextmenu",we(Xr))],O=!0)},p(I,[F]){F&1&&Ae(c.value)!==I[0].worldSize&&ye(c,I[0].worldSize),(!b||F&1)&&d!==(d=2**I[0].worldSize+"")&&pe(x,d),(!b||F&1)&&E!==(E=2**I[0].worldSize+"")&&pe(S,E),(!b||F&1)&&v!==(v=2**(I[0].worldSize+1)+"")&&pe(g,v)},i(I){b||(_(n.$$.fragment,I),b=!0)},o(I){k(n.$$.fragment,I),b=!1},d(I){I&&h(e),V(n),O=!1,ze(X)}}}const Xr=a=>a;function jr(a,e,n){const o={width:Math.min(window.innerWidth,window.innerHeight)*.9,height:Math.min(window.innerWidth,window.innerHeight)*.9},t={colors:"A_transform_seismic",initialConditions:"middleCircleAndRandomSpots",reset:()=>x(),pause:!1,grid:!1,pen:!0,speed:50},i={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:3,penDensity:.3,zoomLevel:1,panX:.5,panY:.5},r={iteration:0,worldSize:8},s={f:Se[0].f,k:Se[0].k};let l,f;const c=async()=>{const S=await Ie(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);l=new S.GUI({autoPlace:!1,closeOnTop:!0}),l.domElement.id="datgui";const M=document.getElementById("datgui-container");if(!M)throw new Error("Gui container not ready");M.appendChild(l.domElement),l.add(t,"pause").name("Pause"),l.add(t,"grid").name("Debug grid"),l.add(t,"pen").name("Show pen"),l.add(t,"reset").name("Reset simulation"),l.add(t,"colors",["grayscale","blackwhite","whiteblack","raw","timebasedblue","lerp","mrob","redblue","A_gradiant1","A_gradiant2","A_MATLAB_cool","A_MATLAB_parula","A_IDL_CB_RdBu","A_IDL_CB_RdYiBu","A_IDL_CB_BuYiRd","A_transform_seismic","B_IDL_CB_RdYiBu"]).name("Color scheme");const v={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots",Empty:"empty"};l.add(t,"initialConditions",v).onFinishChange(t.reset).name("Initial conditions");const g=l.add(r,"iteration").listen();g.domElement.style.pointerEvents="none",l.add(t,"speed",1,200).name("Simulation speed"),l.add(i,"penSize",0,r.worldSize).name("Pen size"),l.add(i,"penDensity",0,1).name("Pen density"),l.add(i,"zoomLevel",0,1).name("Zoom level").listen(),l.add(i,"panX",0,1).name("pan x").listen(),l.add(i,"panY",0,1).name("pan y").listen()},u=S=>{if(S.code==="Space"){t.pause=!t.pause,S.preventDefault();return}if(S.code==="KeyR"&&!S.getModifierState("Control")){x(),S.preventDefault();return}},p=S=>{if(!S.getModifierState("Control"))return;const M=Rt(S);i.panX=M.x,i.panY=M.y,S.deltaY>0?i.zoomLevel*=1+i.zoomLevel/2:i.zoomLevel*=1-i.zoomLevel/2,i.zoomLevel>1&&(i.zoomLevel=1),i.zoomLevel<0&&(i.zoomLevel=0),S.preventDefault()},m=S=>{const M=Rt(S);i.x=M.x,i.y=M.y},d=S=>{if(![0,2].includes(S.button)||!["mouseup","mousedown"].includes(S.type))return;let M=S.type==="mousedown";S.button===0&&(i.pressedLeft=M),S.button===2&&(i.pressedRight=M)},x=()=>{isNaN(r.worldSize)||(r.worldSize>11&&n(0,r.worldSize=11,r),r.worldSize<1&&n(0,r.worldSize=1,r),l&&(document.getElementById(l.domElement.id)?.remove(),l.destroy()),f?.destroy(),c(),f=vn({controls:t,info:r,mouseState:i,simulationParameters:s}))},C=S=>{s.f=S.detail.f,s.k=S.detail.k};Ee(()=>{x()}),ke(()=>{l.destroy(),f.destroy()});function E(){r.worldSize=Ae(this.value),n(0,r)}return[r,o,u,p,m,d,x,C,E]}class Pt extends Q{constructor(e){super(),J(this,e,jr,Wr,ee,{})}}const Zr=`precision mediump float;
attribute vec2 position;
varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}
`,Qr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    gl_FragColor = vec4(A, B, 0.0, 1.0);
}

`,Jr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float PI = 3.14159265359;
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = sin(iteration*PI/180.0);
    if (val < 0.0) {
        val = -1.0 * val;
    }
    gl_FragColor = vec4(A, B, val, 1.0);
}
`,ei=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (A + B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}

`,ti=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(1.0 - val, 1.0 - val, 1.0 - val, 1.0);
}
`,ni=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}
`,oi=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    // vec3 color1 = vec3(1.0, 0.0, 0.0);
    // vec3 color2 = vec3(0.0, 1.0, 0.0);
    // vec3 result = color1 * A + color2 * B;

    vec3 color1RGB = vec3(0.639, 0.941, 0.717);
    vec3 color2RGB = vec3(0.929, 0.082, 0.705);

    vec3 color1HSV = rgb2hsv(color1RGB);
    vec3 color2HSV = rgb2hsv(color2RGB);

    float color1Offset = (cos(iteration * 0.001) + 1.0) * 0.5;
    float color1newH = 0.5 * (color1HSV.x + color1Offset);
    vec3 color1newHSV = vec3(color1newH, color1HSV.g, color1HSV.b);

    float color2Offset = (cos(iteration * 0.002)) * 0.5;
    float color2newH = 0.5 * (color2HSV.x + color2Offset + 0.33);
    vec3 color2newHSV = vec3(color2newH, color2HSV.g, color2HSV.b);


    vec3 resultHSV = color1newHSV * A + color2newHSV * B;
    vec3 result = hsv2rgb(resultHSV);

    gl_FragColor = vec4(result, 1.0);
}
`,ri=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float red = A; // The more A the redder
    float blue = 1.0 - A; // The less A the bleuer

    float green = max(A, B) - min(A, B);

    vec3 result = vec3(red, green, blue);

    gl_FragColor = vec4(result, 1.0);
}
`,ii=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec3 color1 = vec3(0.0, 0.0, 1.0);
    vec3 color2 = vec3(1.0, 0.0, 0.0);
    vec3 result = vec3(A, 0.0, 1.0-A);

    gl_FragColor = vec4(result, 1.0);
}
`,ai=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    if (A > 0.9) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else if (A > 0.4) {
        gl_FragColor = vec4(1.0 - A, 0.0, 0.0, 1.0);
    } else { 
        gl_FragColor = vec4(0.0, A, 0.0, 1.0);
    }
}
`,li=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);
    vec4 color = mix(blue, red, A);

    vec4 softRed = vec4(0.8588, 0.2824, 0.3765, 1.0);
    vec4 softBlue = vec4(0.2824, 0.3882, 0.8588, 1.0);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.6);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.4);
    vec4 softColor = mix(softBlue, softRed, 1.0-A);


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(color);
    }

}
`,si=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/MATLAB_cool.frag
float colormap_red(float x) {
    return (1.0 + 1.0 / 63.0) * x - 1.0 / 63.0;
}

float colormap_green(float x) {
    return -(1.0 + 1.0 / 63.0) * x + (1.0 + 1.0 / 63.0);
}

vec4 colormap(float x) {
    float r = clamp(colormap_red(x), 0.0, 1.0);
    float g = clamp(colormap_green(x), 0.0, 1.0);
    float b = 1.0;
    return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,fi=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdBu.frag
float colormap_red(float x) {
	if (x < 0.09771832105856419) {
		return 7.60263247863246E+02 * x + 1.02931623931624E+02;
	} else if (x < 0.3017162107441106) {
		return (-2.54380938558548E+02 * x + 4.29911571188803E+02) * x + 1.37642085716717E+02;
	} else if (x < 0.4014205790737471) {
		return 8.67103448276151E+01 * x + 2.18034482758611E+02;
	} else if (x < 0.5019932233215039) {
		return -6.15461538461498E+01 * x + 2.77547692307680E+02;
	} else if (x < 0.5969483882550937) {
		return -3.77588522588624E+02 * x + 4.36198819698878E+02;
	} else if (x < 0.8046060096654594) {
		return (-6.51345897546620E+02 * x + 2.09780968434337E+02) * x + 3.17674951640855E+02;
	} else {
		return -3.08431855203590E+02 * x + 3.12956742081421E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09881640500975222) {
		return 2.41408547008547E+02 * x + 3.50427350427364E-01;
	} else if (x < 0.5000816285610199) {
		return ((((1.98531871433258E+04 * x - 2.64108262469187E+04) * x + 1.10991785969817E+04) * x - 1.92958444776211E+03) * x + 8.39569642882186E+02) * x - 4.82944517518776E+01;
	} else if (x < 0.8922355473041534) {
		return (((6.16712686949223E+03 * x - 1.59084026055125E+04) * x + 1.45172137257997E+04) * x - 5.80944127411621E+03) * x + 1.12477959061948E+03;
	} else {
		return -5.28313797313699E+02 * x + 5.78459299959206E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.1033699568661857) {
		return 1.30256410256410E+02 * x + 3.08518518518519E+01;
	} else if (x < 0.2037526071071625) {
		return 3.38458128078815E+02 * x + 9.33004926108412E+00;
	} else if (x < 0.2973267734050751) {
		return (-1.06345054944861E+02 * x + 5.93327252747168E+02) * x - 3.81852747252658E+01;
	} else if (x < 0.4029109179973602) {
		return 6.68959706959723E+02 * x - 7.00740740740798E+01;
	} else if (x < 0.5006715489526758) {
		return 4.87348695652202E+02 * x + 3.09898550724286E+00;
	} else if (x < 0.6004396902588283) {
		return -6.85799999999829E+01 * x + 2.81436666666663E+02;
	} else if (x < 0.702576607465744) {
		return -1.81331701891043E+02 * x + 3.49137263626287E+02;
	} else if (x < 0.9010407030582428) {
		return (2.06124143164576E+02 * x - 5.78166906665595E+02) * x + 5.26198653917172E+02;
	} else {
		return -7.36990769230737E+02 * x + 8.36652307692262E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,ci=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,ui=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((B-0.1)*(1.0/0.9));


    if (B < 0.1) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,_e={},pi=a=>{const e={vert:Zr,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{iteration:a.prop("iteration"),prevState:a.prop("inputBuffer")}};_e.raw=a({frag:Qr,...e}),_e.A_gradiant1=a({frag:ai,...e}),_e.A_gradiant2=a({frag:li,...e}),_e.A_MATLAB_cool=a({frag:si,...e}),_e.A_IDL_CB_RdBu=a({frag:fi,...e}),_e.A_IDL_CB_RdYiBu=a({frag:ci,...e}),_e.B_IDL_CB_RdYiBu=a({frag:ui,...e}),_e.grayscale=a({frag:ei,...e}),_e.blackwhite=a({frag:ti,...e}),_e.whiteblack=a({frag:ni,...e}),_e.timebasedblue=a({frag:Jr,...e}),_e.lerp=a({frag:oi,...e}),_e.mrob=a({frag:ri,...e}),_e.redblue=a({frag:ii,...e})},mi=a=>{const{colorMode:e,inputBuffer:n,iteration:o,outputBuffer:t,zoomState:i}=a;(_e[e]||_e.raw)({inputBuffer:n,iteration:o,outputBuffer:t,pan:[i.panX,i.panY],zoomLevel:i.zoomLevel})},di=`precision mediump float;

uniform float radius;
uniform sampler2D prevState;
uniform bool pauseSimulation;
uniform float Da;
uniform float Db;

varying vec2 v_fk;

uniform bool penIsActive;
uniform bool eraserIsActive;
uniform float penDensity;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

// https://thebookofshaders.com/10/
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
}

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(radius)).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(radius)).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(radius)).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(radius)).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(radius)).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(radius)).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(radius)).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(radius)).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(radius)).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float f = v_fk.x;
    float k = v_fk.y;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));


    float rnd = random(uv);
    if (penIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(0.0, 1.0, 0, 1);
    } else if (pauseSimulation) {
        gl_FragColor = vec4(A, B, 0, 1);
    } else {
        gl_FragColor = vec4(newA, newB, 0, 1);
    }
}
`,hi=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float penRadius;

attribute vec2 position;
attribute vec2 fk;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;
varying vec2 v_fk;

void main() {
    uv = 0.5 * (position + 1.0);
    v_fk = fk;
    mouseUv = mousePosition;
    scaledPenRadius = penRadius;
    gl_Position = vec4(position, 0, 1);
}
`;let gn;const vi=(a,e)=>{gn=a({frag:di,vert:hi,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]],fk:(n,o)=>{const{maxF:t,minF:i,maxK:r,minK:s}=o.simulationParameters;return[[i,r],[i,s],[t,r],[t,r],[i,s],[t,s]]}},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),Da:1,Db:.5,radius:e,pauseSimulation:a.prop("pauseSimulation"),mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),penDensity:a.prop("penDensity"),penIsActive:a.prop("penIsActive")}})},gi=a=>{const{inputBuffer:e,outputBuffer:n,simulationParameters:o,pauseSimulation:t,mouseState:i,worldSize:r}=a;gn({inputBuffer:e,outputBuffer:n,pauseSimulation:t,zoomLevel:i.zoomLevel,pan:[i.panX,i.panY],mousePosition:[i.x,i.y],penRadius:1/2**(r-i.penSize),penDensity:i.penDensity,penIsActive:i.pressedLeft,eraserIsActive:i.pressedRight,simulationParameters:o})},xi=(a,e)=>a==="randomSpots"?bi(e,.001):a==="middleCircleAndRandomSpots"?_i(e,.005,.05):a==="empty"||a==="full"?Ft(e):wi(e,.02),_i=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},Ft=a=>Array(a*a).fill(0).map(()=>[0,0,0,1]).flat(),bi=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),wi=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),$i=a=>{const{controls:e,info:n,mouseState:o,simulationParameters:t}=a,i=document.getElementById("canvas");if(!i)throw new Error("Canvas container not ready");const r=Re({extensions:["OES_texture_float"],canvas:i});n.iteration=0;const s=2**n.worldSize,l=xi(e.initialConditions,s),f=()=>r.framebuffer({color:r.texture({radius:s,data:l,wrap:"repeat",type:"float"}),depthStencil:!1}),c=Array(2).fill(0).map(f);return vi(r,s),pi(r),r.frame(()=>{e.pause||n.iteration++;let u=c[(n.iteration+1)%2];for(let p=0;p<e.speed;p++){n.iteration++;const m=c[n.iteration%2];u=c[(n.iteration+1)%2],gi({inputBuffer:m,outputBuffer:u,worldSize:n.worldSize,pauseSimulation:e.pause,mouseState:o,simulationParameters:t})}mi({colorMode:e.colors,inputBuffer:u,iteration:n.iteration,outputBuffer:null,zoomState:o})}),r},Mt=a=>{if(!a.currentTarget)throw new Error("Event has no currentTarget");const e=a.currentTarget,n=e.getBoundingClientRect(),o=a.clientX-n.left,t=a.clientY-n.top,{width:i,height:r}=e,s=o/i,l=(r-t)/r;return{x:s,y:l}};const{window:ki}=je;function yi(a){let e,n,o,t,i,r,s,l,f,c,u,p;return{c(){e=z("main"),n=z("div"),o=q(),t=z("div"),i=z("label"),r=R("World Size:"),s=q(),l=z("input"),f=q(),c=z("canvas"),this.h()},l(m){e=B(m,"MAIN",{});var d=T(e);n=B(d,"DIV",{id:!0,class:!0}),T(n).forEach(h),o=Y(d),t=B(d,"DIV",{});var x=T(t);i=B(x,"LABEL",{for:!0});var C=T(i);r=P(C,"World Size:"),C.forEach(h),s=Y(x),l=B(x,"INPUT",{id:!0,type:!0,step:!0}),x.forEach(h),f=Y(d),c=B(d,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(c).forEach(h),d.forEach(h),this.h()},h(){y(n,"id","datgui-container"),y(n,"class","svelte-198vt5w"),y(i,"for","worldSize"),y(l,"id","worldSize"),y(l,"type","number"),y(l,"step","1"),y(c,"id","canvas"),y(c,"width",a[1].width),y(c,"height",a[1].height),y(c,"class","svelte-198vt5w")},m(m,d){A(m,e,d),w(e,n),w(e,o),w(e,t),w(t,i),w(i,r),w(t,s),w(t,l),ye(l,a[0].worldSize),w(e,f),w(e,c),u||(p=[Z(ki,"keydown",a[2]),Z(l,"input",a[7]),Z(l,"change",a[6]),Z(c,"mousemove",a[4]),Z(c,"mousedown",we(a[5])),Z(c,"mouseup",a[5]),Z(c,"wheel",a[3]),Z(c,"keydown",we(a[2])),Z(c,"contextmenu",we(Si))],u=!0)},p(m,[d]){d&1&&Ae(l.value)!==m[0].worldSize&&ye(l,m[0].worldSize)},i:ne,o:ne,d(m){m&&h(e),u=!1,ze(p)}}}const Si=a=>a;function Ei(a,e,n){const o={width:Math.min(window.innerWidth,window.innerHeight)*.9,height:Math.min(window.innerWidth,window.innerHeight)*.9},t={colors:"B_IDL_CB_RdYiBu",initialConditions:"full",reset:()=>x(),pause:!1,grid:!1,speed:10},i={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:12,penDensity:.3,zoomLevel:1,panX:.5,panY:.5},r={iteration:0,worldSize:10},s={minK:.02,maxK:.07,minF:0,maxF:.12};let l,f;const c=async()=>{const E=await Ie(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);l=new E.GUI({autoPlace:!1,closeOnTop:!0}),l.domElement.id="datgui";const S=document.getElementById("datgui-container");if(!S)throw new Error("Gui container not ready");S.appendChild(l.domElement),l.add(t,"pause").name("Pause"),l.add(t,"grid").name("Debug grid"),l.add(t,"reset").name("Reset simulation"),l.add(t,"colors",["grayscale","blackwhite","whiteblack","raw","timebasedblue","lerp","mrob","redblue","A_gradiant1","A_gradiant2","A_MATLAB_cool","A_IDL_CB_RdBu","A_IDL_CB_RdYiBu","B_IDL_CB_RdYiBu"]).name("Color scheme");const M={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots",Empty:"empty",Full:"full"};l.add(t,"initialConditions",M).onFinishChange(t.reset).name("Initial conditions");const v=l.add(r,"iteration").listen();v.domElement.style.pointerEvents="none",l.add(t,"speed",1,500).name("Simulation speed"),l.add(i,"penSize",0,r.worldSize).name("Pen size"),l.add(i,"penDensity",0,1).name("Pen density"),l.add(s,"minK",0,s.maxK),l.add(s,"maxK",s.minK,1),l.add(s,"minF",0,s.maxF),l.add(s,"maxF",s.minF,1)},u=E=>{if(E.code==="Space"){t.pause=!t.pause,E.preventDefault();return}if(E.code==="KeyR"&&!E.getModifierState("Control")){x(),E.preventDefault();return}},p=E=>{if(!E.getModifierState("Control"))return;const S=Mt(E);i.panX=S.x,i.panY=S.y,E.deltaY>0?i.zoomLevel*=1+i.zoomLevel/2:i.zoomLevel*=1-i.zoomLevel/2,i.zoomLevel>1&&(i.zoomLevel=1),i.zoomLevel<0&&(i.zoomLevel=0),E.preventDefault()},m=E=>{const S=Mt(E);i.x=S.x,i.y=S.y},d=E=>{if(![0,2].includes(E.button)||!["mouseup","mousedown"].includes(E.type))return;let S=E.type==="mousedown";E.button===0&&(i.pressedLeft=S),E.button===2&&(i.pressedRight=S)},x=()=>{isNaN(r.worldSize)||(r.worldSize>12&&n(0,r.worldSize=12,r),r.worldSize<1&&n(0,r.worldSize=1,r),l&&(document.getElementById(l.domElement.id)?.remove(),l.destroy()),f?.destroy(),c(),f=$i({controls:t,info:r,mouseState:i,simulationParameters:s}))};Ee(()=>{x(),i.pressedLeft=!0,setTimeout(()=>i.pressedLeft=!1,10)}),ke(()=>{l.destroy(),f.destroy()});function C(){r.worldSize=Ae(this.value),n(0,r)}return[r,o,u,p,m,d,x,C]}let rt=class extends Q{constructor(e){super(),J(this,e,Ei,yi,ee,{})}};const Ai=a=>{const e=[];for(let r=0;r<a.height;r++){e.push([]);for(let s=0;s<a.width;s++)e[e.length-1].push({A:1,B:0})}const n=5,o=5,t=Math.floor(a.width/2),i=Math.floor(a.height/2);for(let r=i-o;r<i+o;r++)for(let s=t-n;s<t+n;s++)e[r][s].B=1;return e},Di=(a,e)=>{const n={width:a.width/e[0].length,height:a.height/e.length};for(let o=0;o<e.length;o++)for(let t=0;t<e[0].length;t++){const{A:i,B:r}=e[o][t];a.fill(i*255,r*255,0),a.rect(t*n.width,o*n.height,n.width,n.height)}},zi=1,Bi=.5,Ut=.055,Ci=.062,Ti=a=>{const e=[];for(let n=0;n<a.length;n++){e.push([]);for(let o=0;o<a[0].length;o++){const{A:t,B:i}=a[n][o],r=Nt(a,{x:o,y:n},"A"),s=Nt(a,{x:o,y:n},"B"),l=t+(zi*r-t*i*i+Ut*(1-t)),f=i+(Bi*s+t*i*i-(Ci+Ut)*i);e[n].push({A:l,B:f})}}return e},Nt=(a,e,n)=>{const o=Ii(a,e);let t=0;for(const i of o){const{coord:r,weight:s}=i;t+=a[r.y][r.x][n]*s}return t},Ii=(a,e)=>{const{x:n,y:o}=e,t=a[0].length,i=a.length,r={coord:{x:n>0?n-1:t-1,y:o>0?o-1:i-1},weight:.05},s={coord:{x:n,y:o>0?o-1:i-1},weight:.2},l={coord:{x:n<t-1?n+1:0,y:o>0?o-1:i-1},weight:.05},f={coord:{x:n>0?n-1:t-1,y:o},weight:.2},c={coord:{x:n,y:o},weight:-1},u={coord:{x:n<t-1?n+1:0,y:o},weight:.2},p={coord:{x:n>0?n-1:t-1,y:o<i-1?o+1:0},weight:.05},m={coord:{x:n,y:o<i-1?o+1:0},weight:.2},d={coord:{x:n<t-1?n+1:0,y:o<i-1?o+1:0},weight:.05};return[r,s,l,f,c,u,p,m,d]};function Li(a){let e,n;return e=new Le({props:{sketch:a[0]}}),{c(){U(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){N(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){V(e,o)}}}function Ri(a){const e={width:200,height:200};let n;return[t=>{let i;t.setup=()=>{n=t,t.createCanvas(500,500),t.noStroke(),i=Ai(e)},t.draw=()=>{t.background(0);for(let r=0;r<20;r++)i=Ti(i);Di(n,i)}}]}let Pi=class extends Q{constructor(e){super(),J(this,e,Ri,Li,ee,{})}},me,Ne;const Fi=a=>{me=[],Ne=[];for(let i=0;i<a.height;i++){me.push([]),Ne.push([]);for(let r=0;r<a.width;r++)me[me.length-1].push({A:1,B:0}),Ne[me.length-1].push({A:1,B:0})}const e=5,n=5,o=Math.floor(a.width/2),t=Math.floor(a.height/2);for(let i=t-n;i<t+n;i++)for(let r=o-e;r<o+e;r++)me[i][r].B=1;return me},Mi=a=>{const e={width:a.width/me[0].length,height:a.height/me.length};for(let n=0;n<me.length;n++)for(let o=0;o<me[0].length;o++){const{A:t,B:i}=me[n][o];a.fill(t*255,i*255,0),a.rect(o*e.width,n*e.height,e.width,e.height)}},Ui=1,Ni=.5,Vt=.055,Vi=.062,Oi=()=>{for(let e=0;e<me.length;e++)for(let n=0;n<me[0].length;n++){const{A:o,B:t}=me[e][n],i=Ot(me,{x:n,y:e},"A"),r=Ot(me,{x:n,y:e},"B"),s=o+(Ui*i-o*t*t+Vt*(1-o)),l=t+(Ni*r+o*t*t-(Vi+Vt)*t);Ne[e][n]={A:s,B:l}}const a=me;return me=Ne,Ne=a,me},Ot=(a,e,n)=>{const o=Hi(a,e);let t=0;for(const i of o){const{coord:r,weight:s}=i;t+=a[r.y][r.x][n]*s}return t},Hi=(a,e)=>{const{x:n,y:o}=e,t=a[0].length,i=a.length,r={coord:{x:n>0?n-1:t-1,y:o>0?o-1:i-1},weight:.05},s={coord:{x:n,y:o>0?o-1:i-1},weight:.2},l={coord:{x:n<t-1?n+1:0,y:o>0?o-1:i-1},weight:.05},f={coord:{x:n>0?n-1:t-1,y:o},weight:.2},c={coord:{x:n,y:o},weight:-1},u={coord:{x:n<t-1?n+1:0,y:o},weight:.2},p={coord:{x:n>0?n-1:t-1,y:o<i-1?o+1:0},weight:.05},m={coord:{x:n,y:o<i-1?o+1:0},weight:.2},d={coord:{x:n<t-1?n+1:0,y:o<i-1?o+1:0},weight:.05};return[r,s,l,f,c,u,p,m,d]};function Ki(a){let e,n;return e=new Le({props:{sketch:a[0]}}),{c(){U(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){N(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){V(e,o)}}}function qi(a){const e={width:200,height:200};let n;return[t=>{t.setup=()=>{n=t,t.createCanvas(500,500),t.noStroke(),Fi(e)},t.draw=()=>{for(let i=0;i<5;i++)Oi();Mi(n)}}]}let Yi=class extends Q{constructor(e){super(),J(this,e,qi,Ki,ee,{})}},de,Ve;const Gi=a=>{de=[],Ve=[];for(let i=0;i<a.height;i++){de.push([]),Ve.push([]);for(let r=0;r<a.width;r++)de[de.length-1].push({A:1,B:0}),Ve[de.length-1].push({A:1,B:0})}const e=5,n=5,o=Math.floor(a.width/2),t=Math.floor(a.height/2);for(let i=t-n;i<t+n;i++)for(let r=o-e;r<o+e;r++)de[i][r].B=1;return de},Wi=a=>{const e={width:a.width/de[0].length,height:a.height/de.length};for(let n=0;n<de.length;n++)for(let o=0;o<de[0].length;o++){const{A:t,B:i}=de[n][o];a.fill(t*255,i*255,0),a.rect(o*e.width,n*e.height,e.width,e.height)}},Xi=1,ji=.5,Ht=.055,Zi=.062,Qi=()=>{for(let e=0;e<de.length;e++)for(let n=0;n<de[0].length;n++){const{A:o,B:t}=de[e][n],i=Kt(de,{x:n,y:e},"A"),r=Kt(de,{x:n,y:e},"B"),s=o+(Xi*i-o*t*t+Ht*(1-o)),l=t+(ji*r+o*t*t-(Zi+Ht)*t);Ve[e][n]={A:s,B:l}}const a=de;return de=Ve,Ve=a,de},Kt=(a,e,n)=>{const o=Ji(a,e);let t=0;for(const i of o){const{coord:r,weight:s}=i;t+=a[r.y][r.x][n]*s}return t},Ji=(a,e)=>{const{x:n,y:o}=e,t=a[0].length,i=a.length,r={coord:{x:n>0?n-1:t-1,y:o>0?o-1:i-1},weight:.05},s={coord:{x:n,y:o>0?o-1:i-1},weight:.2},l={coord:{x:n<t-1?n+1:0,y:o>0?o-1:i-1},weight:.05},f={coord:{x:n>0?n-1:t-1,y:o},weight:.2},c={coord:{x:n,y:o},weight:-1},u={coord:{x:n<t-1?n+1:0,y:o},weight:.2},p={coord:{x:n>0?n-1:t-1,y:o<i-1?o+1:0},weight:.05},m={coord:{x:n,y:o<i-1?o+1:0},weight:.2},d={coord:{x:n<t-1?n+1:0,y:o<i-1?o+1:0},weight:.05};return[r,s,l,f,c,u,p,m,d]};function ea(a){let e,n;return e=new Le({props:{sketch:a[0]}}),{c(){U(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){N(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){V(e,o)}}}function ta(a){const e={width:200,height:200};let n;return[t=>{t.setup=()=>{n=t,t.createCanvas(500,500),t.noStroke(),Gi(e)},t.draw=()=>{for(let i=0;i<5;i++)Qi();Wi(n)}}]}let na=class extends Q{constructor(e){super(),J(this,e,ta,ea,ee,{})}};function oa(a){let e;return{c(){e=z("canvas"),this.h()},l(n){e=B(n,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(e).forEach(h),this.h()},h(){y(e,"id","canvas"),y(e,"width",a[0].width),y(e,"height",a[0].height),y(e,"class","svelte-1b0ol19")},m(n,o){A(n,e,o)},p:ne,i:ne,o:ne,d(n){n&&h(e)}}}function ra(a){const e={width:window.innerWidth-50,height:window.innerHeight-10},n=2**10,o=n*.05,t=Array(n*n).fill(0).map((i,r)=>{const s=Math.floor(r/n),l=r%n;return Math.hypot(n/2-l,n/2-s)<o?[0,1,0,1]:Math.random()<.01?[0,1,0,1]:[1,0,0,1]}).flat();return Ee(()=>{const i=document.getElementById("canvas");if(!i)throw new Error("Canvas container not ready");const r=Re({extensions:["OES_texture_float"],canvas:i}),s=Array(2).fill(0).map(()=>r.framebuffer({color:r.texture({radius:n,data:t,wrap:"repeat",type:"float"}),depthStencil:!1})),l=r({frag:`
precision mediump float;
uniform sampler2D prevState;
varying vec2 uv;

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(${n})).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(${n})).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(${n})).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(${n})).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(${n})).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(${n})).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(${n})).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(${n})).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(${n})).rg * 0.05;

    return r;
}

void main() {
    float Da = 1.0;
    float Db = 0.5;
    float f = 0.055;
    float k = 0.062;

    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));

    gl_FragColor = vec4(newA, newB, 0, 1);
}`,framebuffer:c=>s[(c.tick+1)%2]}),f=r({frag:`
precision mediump float;
uniform sampler2D prevState;
varying vec2 uv;
void main() {
    vec2 state = texture2D(prevState, uv).rg;
    gl_FragColor = vec4(state, 0, 1);
}`,vert:`
precision mediump float;
attribute vec2 position;
varying vec2 uv;
void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}`,attributes:{position:[-4,-4,4,-4,0,4]},uniforms:{prevState:({tick:c})=>s[c%2]},depth:{enable:!1},count:3});r.frame(()=>{f(()=>{r.draw(),l()})})}),[e]}let ia=class extends Q{constructor(e){super(),J(this,e,ra,oa,ee,{})}};const aa=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},la=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),sa=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),Ge=[{name:"KarlSims",type:"Unknown",f:.055,k:.062},{name:"Alpha 1",type:"alpha",f:.01,k:.047},{name:"Alpha 2",type:"alpha",f:.014,k:.053},{name:"Beta 1",type:"beta",f:.014,k:.039},{name:"Beta 2",type:"beta",f:.026,k:.051},{name:"Epsilon 1",type:"epsilon",f:.018,k:.055},{name:"Epsilon 2",type:"epsilon",f:.022,k:.059},{name:"Epsilon 1",type:"epsilon",f:.034,k:.063},{name:"Gamma 1",type:"gamma",f:.022,k:.051},{name:"Gamma 2",type:"gamma",f:.026,k:.055},{name:"Iota 1",type:"iota",f:.046,k:.0594},{name:"Lambda 1",type:"lambda",f:.026,k:.061},{name:"Lambda 2",type:"lambda",f:.034,k:.065},{name:"Mu 1",type:"mu",f:.046,k:.065},{name:"Mu 2",type:"mu",f:.058,k:.065},{name:"Pi 1",type:"pi",f:.062,k:.061},{name:"Rho 1",type:"rho",f:.09,k:.059},{name:"Rho 2",type:"rho",f:.102,k:.055},{name:"Sigma 1",type:"sigma",f:.09,k:.057},{name:"Sigma 2",type:"sigma",f:.11,k:.0523},{name:"Theta 1",type:"theta",f:.03,k:.057},{name:"Theta 2",type:"theta",f:.038,k:.061},{name:"Xi 1",type:"xi",f:.01,k:.041},{name:"Xi 2",type:"xi",f:.014,k:.047},{name:"Zeta 1",type:"zeta",f:.022,k:.061},{name:"Zeta 2",type:"zeta",f:.026,k:.059}];function fa(a){let e;return{c(){e=z("canvas"),this.h()},l(n){e=B(n,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(e).forEach(h),this.h()},h(){y(e,"id","canvas"),y(e,"width",a[0].width),y(e,"height",a[0].height),y(e,"class","svelte-1b0ol19")},m(n,o){A(n,e,o)},p:ne,i:ne,o:ne,d(n){n&&h(e)}}}function ca(a){const e={width:window.innerWidth-50,height:window.innerHeight-10},n={presetParams:4,initialConditions:"randomSpots",reset:()=>f(),pause:!1},o={iteration:0},t={f:Ge[n.presetParams].f,k:Ge[n.presetParams].k};let i,r;const s=async()=>{const c=await Ie(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);i=new c.GUI,i.domElement.setAttribute("style","background-color: black"),i.add(t,"f").name("Feed rate").listen(),i.add(t,"k").name("Kill rate").listen(),i.add(n,"pause").name("Pause"),i.add(n,"reset").name("Reset simulation");const u=Ge.reduce((d,x,C)=>(d[x.name]=C,d),{});i.add(n,"presetParams",u).onFinishChange(()=>{t.f=Ge[n.presetParams].f,t.k=Ge[n.presetParams].k});const p={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots"};i.add(n,"initialConditions",p).onFinishChange(n.reset);const m=i.add(o,"iteration").listen();m.domElement.style.pointerEvents="none"},l=()=>{document.addEventListener("keydown",c=>{if(c.code==="Space")return n.pause=!n.pause,c.preventDefault();if(c.code==="KeyR")return f(),c.preventDefault()})},f=()=>{const c=document.getElementById("canvas");if(!c)throw new Error("Canvas container not ready");r&&r.destroy(),r=Re({extensions:["OES_texture_float"],canvas:c}),o.iteration=0;const u=2**11;let p;n.initialConditions==="randomSpots"?p=la(u,.001):n.initialConditions==="middleCircleAndRandomSpots"?p=aa(u,.005,.05):p=sa(u,.02);const m=Array(2).fill(0).map(()=>r.framebuffer({color:r.texture({radius:u,data:p,wrap:"repeat",type:"float"}),depthStencil:!1})),d=r({frag:`
precision mediump float;

uniform sampler2D prevState;
uniform float Da;
uniform float Db;
uniform float f;
uniform float k;

varying vec2 uv;

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(${u})).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(${u})).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(${u})).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(${u})).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(${u})).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(${u})).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(${u})).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(${u})).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(${u})).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));

    gl_FragColor = vec4(newA, newB, 0, 1);
}`,framebuffer:C=>m[(C.tick+1)%2],uniforms:{Da:r.prop("Da"),Db:r.prop("Db"),f:r.prop("f"),k:r.prop("k")}}),x=r({frag:`
precision mediump float;
uniform sampler2D prevState;
varying vec2 uv;
void main() {
    vec2 state = texture2D(prevState, uv).rg;
    gl_FragColor = vec4(state, 0, 1);
}`,vert:`
precision mediump float;
attribute vec2 position;
varying vec2 uv;
void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}`,attributes:{position:[-4,-4,4,-4,0,4]},uniforms:{prevState:({tick:C})=>m[C%2]},depth:{enable:!1},count:3});r.frame(()=>{x(()=>{r.draw(),!n.pause&&(o.iteration++,d({Da:1,Db:.5,...t}))})})};return Ee(()=>{s(),l(),f()}),ke(()=>{i.destroy(),r.destroy()}),[e]}let ua=class extends Q{constructor(e){super(),J(this,e,ca,fa,ee,{})}};const pa=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},ma=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),da=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),We=[{name:"KarlSims",type:"Unknown",f:.055,k:.062},{name:"Alpha 1",type:"alpha",f:.01,k:.047},{name:"Alpha 2",type:"alpha",f:.014,k:.053},{name:"Beta 1",type:"beta",f:.014,k:.039},{name:"Beta 2",type:"beta",f:.026,k:.051},{name:"Epsilon 1",type:"epsilon",f:.018,k:.055},{name:"Epsilon 2",type:"epsilon",f:.022,k:.059},{name:"Epsilon 1",type:"epsilon",f:.034,k:.063},{name:"Gamma 1",type:"gamma",f:.022,k:.051},{name:"Gamma 2",type:"gamma",f:.026,k:.055},{name:"Iota 1",type:"iota",f:.046,k:.0594},{name:"Lambda 1",type:"lambda",f:.026,k:.061},{name:"Lambda 2",type:"lambda",f:.034,k:.065},{name:"Mu 1",type:"mu",f:.046,k:.065},{name:"Mu 2",type:"mu",f:.058,k:.065},{name:"Pi 1",type:"pi",f:.062,k:.061},{name:"Rho 1",type:"rho",f:.09,k:.059},{name:"Rho 2",type:"rho",f:.102,k:.055},{name:"Sigma 1",type:"sigma",f:.09,k:.057},{name:"Sigma 2",type:"sigma",f:.11,k:.0523},{name:"Theta 1",type:"theta",f:.03,k:.057},{name:"Theta 2",type:"theta",f:.038,k:.061},{name:"Xi 1",type:"xi",f:.01,k:.041},{name:"Xi 2",type:"xi",f:.014,k:.047},{name:"Zeta 1",type:"zeta",f:.022,k:.061},{name:"Zeta 2",type:"zeta",f:.026,k:.059}],ha=`precision mediump float;
attribute vec2 position;
varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}
`,va=`precision mediump float;
uniform sampler2D prevState;
varying vec2 uv;

void main() {
    vec2 state = texture2D(prevState, uv).rg;
    gl_FragColor = vec4(state, 0, 1);
}
`,ga=`precision mediump float;

uniform float radius;
uniform sampler2D prevState;
uniform bool pauseSimulation;
uniform float Da;
uniform float Db;
uniform float f;
uniform float k;

uniform vec2 mousePosition;
uniform bool penIsActive;
uniform bool eraserIsActive;
uniform float penRadius;

varying vec2 uv;

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(radius)).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(radius)).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(radius)).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(radius)).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(radius)).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(radius)).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(radius)).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(radius)).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(radius)).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));

    if (penIsActive && distance(uv, mousePosition) < penRadius) {
        gl_FragColor = vec4(0.0, 1.0, 0, 1);
    } else if (eraserIsActive && distance(uv, mousePosition) < penRadius) {
        gl_FragColor = vec4(1.0, 0.0, 0, 1);
    } else if (pauseSimulation) {
        gl_FragColor = vec4(A, B, 0, 1);
    } else {
        gl_FragColor = vec4(newA, newB, 0, 1);
    }
}
`;function xa(a){let e,n,o;return{c(){e=z("canvas"),this.h()},l(t){e=B(t,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(e).forEach(h),this.h()},h(){y(e,"id","canvas"),y(e,"width",a[0].width),y(e,"height",a[0].height),y(e,"class","svelte-1b0ol19")},m(t,i){A(t,e,i),n||(o=[Z(e,"mousemove",a[1]),Z(e,"mousedown",we(a[2])),Z(e,"mouseup",a[2]),Z(e,"contextmenu",we(_a))],n=!0)},p:ne,i:ne,o:ne,d(t){t&&h(e),n=!1,ze(o)}}}const nt=11,_a=a=>a;function ba(a){const e={width:window.innerWidth-50,height:window.innerHeight-10},n={presetParams:4,initialConditions:"randomSpots",reset:()=>c(),pause:!1},o={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:3},t={iteration:0},i={f:We[n.presetParams].f,k:We[n.presetParams].k};let r,s;const l=async()=>{const m=await Ie(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);r=new m.GUI,r.domElement.setAttribute("style","background-color: black"),r.add(i,"f").name("Feed rate").listen(),r.add(i,"k").name("Kill rate").listen(),r.add(n,"pause").name("Pause"),r.add(n,"reset").name("Reset simulation");const d=We.reduce((E,S,M)=>(E[S.name]=M,E),{});r.add(n,"presetParams",d).onFinishChange(()=>{i.f=We[n.presetParams].f,i.k=We[n.presetParams].k});const x={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots"};r.add(n,"initialConditions",x).onFinishChange(n.reset);const C=r.add(t,"iteration").listen();C.domElement.style.pointerEvents="none",r.add(o,"penSize",1,nt,1).name("Pen size")},f=()=>{document.addEventListener("keydown",m=>{if(m.code==="Space")return n.pause=!n.pause,m.preventDefault();if(m.code==="KeyR")return c(),m.preventDefault()})},c=()=>{const m=document.getElementById("canvas");if(!m)throw new Error("Canvas container not ready");s&&s.destroy(),s=Re({extensions:["OES_texture_float"],canvas:m}),t.iteration=0;const d=2**nt;let x;n.initialConditions==="randomSpots"?x=ma(d,.001):n.initialConditions==="middleCircleAndRandomSpots"?x=pa(d,.005,.05):x=da(d,.02);const C=Array(2).fill(0).map(()=>s.framebuffer({color:s.texture({radius:d,data:x,wrap:"repeat",type:"float"}),depthStencil:!1})),E=s({frag:ga,framebuffer:M=>C[(M.tick+1)%2],uniforms:{Da:s.prop("Da"),Db:s.prop("Db"),f:s.prop("f"),k:s.prop("k"),radius:d,pauseSimulation:s.prop("pauseSimulation"),mousePosition:s.prop("mousePosition"),penRadius:s.prop("penRadius"),penIsActive:s.prop("penIsActive"),eraserIsActive:s.prop("eraserIsActive")}}),S=s({frag:va,vert:ha,attributes:{position:[-4,-4,4,-4,0,4]},uniforms:{prevState:({tick:M})=>C[M%2]},depth:{enable:!1},count:3});s.frame(()=>{S(()=>{s.draw(),n.pause||t.iteration++,E({Da:1,Db:.5,pauseSimulation:n.pause,mousePosition:[o.x,o.y],penRadius:1/2**(nt-o.penSize),penIsActive:o.pressedLeft,eraserIsActive:o.pressedRight,...i})})})},u=m=>{if(!m.currentTarget)throw new Error("No target for the onmousemove event");if(!m.currentTarget.width||!m.currentTarget.height)throw new Error("No target dimensions for the onmousemove event target");const{x:d,y:x}=m,{width:C,height:E}=m.currentTarget,S=d/C,M=(E-x)/E;o.x=S,o.y=M},p=m=>{if(![0,2].includes(m.button)||!["mouseup","mousedown"].includes(m.type))return;let d=m.type==="mousedown";m.button===0&&(o.pressedLeft=d),m.button===2&&(o.pressedRight=d)};return Ee(()=>{l(),f(),c()}),ke(()=>{r.destroy(),s.destroy()}),[e,u,p]}let wa=class extends Q{constructor(e){super(),J(this,e,ba,xa,ee,{})}};const He=[{name:"KarlSims",type:"Unknown",f:.055,k:.062},{name:"STX 1",type:"N.A",f:.0353,k:.0614},{name:"STX 2",type:"N.A",f:.0201,k:.0602},{name:"STX 2",type:"N.A",f:.0181,k:.0435},{name:"α 1",type:"alpha",f:.01,k:.047},{name:"α 2",type:"alpha",f:.014,k:.053},{name:"β 1",type:"beta",f:.014,k:.039},{name:"β 2",type:"beta",f:.026,k:.051},{name:"δ 1",type:"delta",f:.03,k:.055},{name:"δ 2",type:"delta",f:.042,k:.059},{name:"ε 1",type:"epsilon",f:.018,k:.055},{name:"ε 2",type:"epsilon",f:.022,k:.059},{name:"η 1",type:"eta",f:.034,k:.063},{name:"γ 1",type:"gamma",f:.022,k:.051},{name:"γ 2",type:"gamma",f:.026,k:.055},{name:"ι 1",type:"iota",f:.046,k:.0594},{name:"κ 1",type:"kappa",f:.082,k:.06},{name:"κ 2",type:"kappa",f:.058,k:.063},{name:"λ 1",type:"lambda",f:.026,k:.061},{name:"λ 2",type:"lambda",f:.034,k:.065},{name:"μ 1",type:"mu",f:.046,k:.065},{name:"μ 2",type:"mu",f:.058,k:.065},{name:"ν 2",type:"nu",f:.046,k:.067},{name:"π 1",type:"pi",f:.062,k:.061},{name:"ρ 1",type:"rho",f:.09,k:.059},{name:"ρ 2",type:"rho",f:.102,k:.055},{name:"σ 1",type:"sigma",f:.09,k:.057},{name:"θ 2",type:"sigma",f:.11,k:.0523},{name:"θ 1",type:"theta",f:.03,k:.057},{name:"θ 2",type:"theta",f:.038,k:.061},{name:"ξ 1",type:"xi",f:.01,k:.041},{name:"ξ 2",type:"xi",f:.014,k:.047},{name:"ζ 1",type:"zeta",f:.022,k:.061},{name:"ζ 2",type:"zeta",f:.026,k:.059}];function qt(a,e,n){const o=a.slice();return o[17]=e[n],o}function Yt(a){let e,n,o,t,i,r,s,l,f,c=He,u=[];for(let p=0;p<c.length;p+=1)u[p]=Gt(qt(a,c,p));return r=new Le({props:{sketch:a[4]}}),{c(){e=z("div"),n=R("Select f and k parameters on the map of use a preset"),o=q(),t=z("select");for(let p=0;p<u.length;p+=1)u[p].c();i=q(),U(r.$$.fragment),this.h()},l(p){e=B(p,"DIV",{});var m=T(e);n=P(m,"Select f and k parameters on the map of use a preset"),m.forEach(h),o=Y(p),t=B(p,"SELECT",{class:!0});var d=T(t);for(let x=0;x<u.length;x+=1)u[x].l(d);d.forEach(h),i=Y(p),G(r.$$.fragment,p),this.h()},h(){y(t,"class","full-width svelte-1qznlxf"),a[0]===void 0&&it(()=>a[6].call(t))},m(p,m){A(p,e,m),w(e,n),A(p,o,m),A(p,t,m);for(let d=0;d<u.length;d+=1)u[d].m(t,null);Oe(t,a[0]),A(p,i,m),N(r,p,m),s=!0,l||(f=[Z(t,"change",a[6]),Z(t,"change",a[7])],l=!0)},p(p,m){if(m&0){c=He;let d;for(d=0;d<c.length;d+=1){const x=qt(p,c,d);u[d]?u[d].p(x,m):(u[d]=Gt(x),u[d].c(),u[d].m(t,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}m&1&&Oe(t,p[0])},i(p){s||(_(r.$$.fragment,p),s=!0)},o(p){k(r.$$.fragment,p),s=!1},d(p){p&&h(e),p&&h(o),p&&h(t),$e(u,p),p&&h(i),V(r,p),l=!1,ze(f)}}}function Gt(a){let e,n=a[17].type+"",o,t,i=a[17].name+"",r,s,l=a[17].f+"",f,c,u=a[17].k+"",p,m;return{c(){e=z("option"),o=R(n),t=R(" - "),r=R(i),s=R(" (f/k "),f=R(l),c=R(" / "),p=R(u),m=R(`)
                `),this.h()},l(d){e=B(d,"OPTION",{});var x=T(e);o=P(x,n),t=P(x," - "),r=P(x,i),s=P(x," (f/k "),f=P(x,l),c=P(x," / "),p=P(x,u),m=P(x,`)
                `),x.forEach(h),this.h()},h(){e.__value=a[17],e.value=e.__value},m(d,x){A(d,e,x),w(e,o),w(e,t),w(e,r),w(e,s),w(e,f),w(e,c),w(e,p),w(e,m)},p:ne,d(d){d&&h(e)}}}function $a(a){let e,n,o=a[1]?"Close":"F/K selection",t,i,r,s,l,f=a[1]&&Yt(a);return{c(){e=z("div"),n=z("button"),t=R(o),i=q(),f&&f.c(),this.h()},l(c){e=B(c,"DIV",{id:!0,class:!0});var u=T(e);n=B(u,"BUTTON",{class:!0,id:!0});var p=T(n);t=P(p,o),p.forEach(h),i=Y(u),f&&f.l(u),u.forEach(h),this.h()},h(){y(n,"class","full-width svelte-1qznlxf"),y(n,"id","toggleButton"),y(e,"id","container"),y(e,"class","svelte-1qznlxf"),Te(e,"no-cursor",a[2])},m(c,u){A(c,e,u),w(e,n),w(n,t),w(e,i),f&&f.m(e,null),r=!0,s||(l=Z(n,"click",a[5]),s=!0)},p(c,[u]){(!r||u&2)&&o!==(o=c[1]?"Close":"F/K selection")&&pe(t,o),c[1]?f?(f.p(c,u),u&2&&_(f,1)):(f=Yt(c),f.c(),_(f,1),f.m(e,null)):f&&(oe(),k(f,1,1,()=>{f=null}),re()),(!r||u&4)&&Te(e,"no-cursor",c[2])},i(c){r||(_(f),r=!0)},o(c){k(f),r=!1},d(c){c&&h(e),f&&f.d(),s=!1,l()}}}function ka(a,e,n){const o=Xe();let t=He[0],i=!0;const r=[0,.12],s=[.03,.07],l=v=>{const{f:g,k:$}=v,L=d.map($,s[0],s[1],0,d.width),D=d.map(g,r[0],r[1],d.height,0);return{x:L,y:D}},f=v=>{const{x:g,y:$}=v,L=d.map($,d.height,0,r[0],r[1]),D=d.map(g,0,d.width,s[0],s[1]);return{f:L,k:D}},c=v=>{const g=v.mouseX,$=v.mouseY;if(g<0||$<0||g>v.width||$>v.height)return;const{f:L,k:D}=f({x:v.mouseX,y:v.mouseY});n(0,t={f:L,k:D,name:"custom",type:"manual"}),o("fkupdated",t)},u=v=>{v.noStroke();const g=v.textSize();for(const $ of He){const{x:L,y:D}=l({f:$.f,k:$.k}),b=$.f===t.f&&$.k===t.k;v.circle(L,D,3),v.textSize(b?g*2:g),v.fill(b?[240,240,150]:[255,255,255]),v.text($.name,L-v.textWidth($.name)/2,D-10)}},p=v=>{v.noFill(),v.stroke("red");const{x:g,y:$}=l(t);v.text("F",10,$>10?$-5:$+15),v.line(0,$,v.width,$),v.text("K",g<v.width-10?g+5:g-15,v.height-10),v.line(g,0,g,v.height),v.circle(g,$,10)},m=v=>{const{f:g,k:$}=t,L=`F: ${g.toFixed(4)}`,D=`K: ${$.toFixed(4)}`,b=v.textSize(),O=v.height*.05;v.textStyle(v.BOLD),v.textSize(O),v.fill("white"),v.stroke(0),v.strokeWeight(1),v.text(L,v.width*.05,v.textSize()),v.text(D,v.width*.05,v.textSize()+v.textSize()+6),v.textStyle(v.NORMAL),v.textSize(b)};let d,x=!1;const C=v=>{d=v;let g;v.preload=()=>{g=v.loadImage(Ze+"/parameters_map.png")},v.setup=()=>{v.createCanvas(400,400),v.frameRate(55)},v.draw=()=>{v.background(255),v.tint(150,190),v.image(g,0,0,v.width,v.height),u(v),p(v),m(v),n(2,x=!1),v.mouseIsPressed&&(c(v),n(2,x=!0))}},E=()=>{n(1,i=!i),i||d.remove()};ke(()=>d?.remove());function S(){t=at(this),n(0,t)}return[t,i,x,o,C,E,S,()=>o("fkupdated",t)]}class ya extends Q{constructor(e){super(),J(this,e,ka,$a,ee,{})}}const Sa=`precision mediump float;
attribute vec2 position;
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,Ea=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    gl_FragColor = vec4(A, B, 0.0, 1.0);
}

`,Aa=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float PI = 3.14159265359;
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = sin(iteration*PI/180.0);
    if (val < 0.0) {
        val = -1.0 * val;
    }
    gl_FragColor = vec4(A, B, val, 1.0);
}
`,Da=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (A + B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}

`,za=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(1.0 - val, 1.0 - val, 1.0 - val, 1.0);
}
`,Ba=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}
`,Ca=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    // vec3 color1 = vec3(1.0, 0.0, 0.0);
    // vec3 color2 = vec3(0.0, 1.0, 0.0);
    // vec3 result = color1 * A + color2 * B;

    vec3 color1RGB = vec3(0.639, 0.941, 0.717);
    vec3 color2RGB = vec3(0.929, 0.082, 0.705);

    vec3 color1HSV = rgb2hsv(color1RGB);
    vec3 color2HSV = rgb2hsv(color2RGB);

    float color1Offset = (cos(iteration * 0.001) + 1.0) * 0.5;
    float color1newH = 0.5 * (color1HSV.x + color1Offset);
    vec3 color1newHSV = vec3(color1newH, color1HSV.g, color1HSV.b);

    float color2Offset = (cos(iteration * 0.002)) * 0.5;
    float color2newH = 0.5 * (color2HSV.x + color2Offset + 0.33);
    vec3 color2newHSV = vec3(color2newH, color2HSV.g, color2HSV.b);


    vec3 resultHSV = color1newHSV * A + color2newHSV * B;
    vec3 result = hsv2rgb(resultHSV);

    gl_FragColor = vec4(result, 1.0);
}
`,Ta=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float red = A; // The more A the redder
    float blue = 1.0 - A; // The less A the bleuer

    float green = max(A, B) - min(A, B);

    vec3 result = vec3(red, green, blue);

    gl_FragColor = vec4(result, 1.0);
}
`,Ia=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec3 color1 = vec3(0.0, 0.0, 1.0);
    vec3 color2 = vec3(1.0, 0.0, 0.0);
    vec3 result = vec3(A, 0.0, 1.0-A);

    gl_FragColor = vec4(result, 1.0);
}
`,La=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    if (A > 0.9) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else if (A > 0.4) {
        gl_FragColor = vec4(1.0 - A, 0.0, 0.0, 1.0);
    } else { 
        gl_FragColor = vec4(0.0, A, 0.0, 1.0);
    }
}
`,Ra=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);
    vec4 color = mix(blue, red, A);

    vec4 softRed = vec4(0.8588, 0.2824, 0.3765, 1.0);
    vec4 softBlue = vec4(0.2824, 0.3882, 0.8588, 1.0);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.6);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.4);
    vec4 softColor = mix(softBlue, softRed, 1.0-A);


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(color);
    }

}
`,Pa=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/MATLAB_cool.frag
float colormap_red(float x) {
    return (1.0 + 1.0 / 63.0) * x - 1.0 / 63.0;
}

float colormap_green(float x) {
    return -(1.0 + 1.0 / 63.0) * x + (1.0 + 1.0 / 63.0);
}

vec4 colormap(float x) {
    float r = clamp(colormap_red(x), 0.0, 1.0);
    float g = clamp(colormap_green(x), 0.0, 1.0);
    float b = 1.0;
    return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Fa=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdBu.frag
float colormap_red(float x) {
	if (x < 0.09771832105856419) {
		return 7.60263247863246E+02 * x + 1.02931623931624E+02;
	} else if (x < 0.3017162107441106) {
		return (-2.54380938558548E+02 * x + 4.29911571188803E+02) * x + 1.37642085716717E+02;
	} else if (x < 0.4014205790737471) {
		return 8.67103448276151E+01 * x + 2.18034482758611E+02;
	} else if (x < 0.5019932233215039) {
		return -6.15461538461498E+01 * x + 2.77547692307680E+02;
	} else if (x < 0.5969483882550937) {
		return -3.77588522588624E+02 * x + 4.36198819698878E+02;
	} else if (x < 0.8046060096654594) {
		return (-6.51345897546620E+02 * x + 2.09780968434337E+02) * x + 3.17674951640855E+02;
	} else {
		return -3.08431855203590E+02 * x + 3.12956742081421E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09881640500975222) {
		return 2.41408547008547E+02 * x + 3.50427350427364E-01;
	} else if (x < 0.5000816285610199) {
		return ((((1.98531871433258E+04 * x - 2.64108262469187E+04) * x + 1.10991785969817E+04) * x - 1.92958444776211E+03) * x + 8.39569642882186E+02) * x - 4.82944517518776E+01;
	} else if (x < 0.8922355473041534) {
		return (((6.16712686949223E+03 * x - 1.59084026055125E+04) * x + 1.45172137257997E+04) * x - 5.80944127411621E+03) * x + 1.12477959061948E+03;
	} else {
		return -5.28313797313699E+02 * x + 5.78459299959206E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.1033699568661857) {
		return 1.30256410256410E+02 * x + 3.08518518518519E+01;
	} else if (x < 0.2037526071071625) {
		return 3.38458128078815E+02 * x + 9.33004926108412E+00;
	} else if (x < 0.2973267734050751) {
		return (-1.06345054944861E+02 * x + 5.93327252747168E+02) * x - 3.81852747252658E+01;
	} else if (x < 0.4029109179973602) {
		return 6.68959706959723E+02 * x - 7.00740740740798E+01;
	} else if (x < 0.5006715489526758) {
		return 4.87348695652202E+02 * x + 3.09898550724286E+00;
	} else if (x < 0.6004396902588283) {
		return -6.85799999999829E+01 * x + 2.81436666666663E+02;
	} else if (x < 0.702576607465744) {
		return -1.81331701891043E+02 * x + 3.49137263626287E+02;
	} else if (x < 0.9010407030582428) {
		return (2.06124143164576E+02 * x - 5.78166906665595E+02) * x + 5.26198653917172E+02;
	} else {
		return -7.36990769230737E+02 * x + 8.36652307692262E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Ma=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Ua=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap(1.0 - (A-0.4)*(1.0/0.6));


    if (A > 0.6) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Na=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/transform_seismic.frag
float colormap_f(float x) {
    return ((-2010.0 * x + 2502.5950459) * x - 481.763180924) / 255.0;
}

float colormap_red(float x) {
    if (x < 0.0) {
        return 3.0 / 255.0;
    } else if (x < 0.238) {
        return ((-1810.0 * x + 414.49) * x + 3.87702) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return (344441250.0 / 323659.0 * x - 23422005.0 / 92474.0) / 255.0;
    } else if (x < 25851.0 / 34402.0) {
        return 1.0;
    } else if (x <= 1.0) {
        return (-688.04 * x + 772.02) / 255.0;
    } else {
        return 83.0 / 255.0;
    }
}

float colormap_green(float x) {
    if (x < 0.0) {
        return 0.0;
    } else if (x < 0.238) {
        return 0.0;
    } else if (x < 51611.0 / 108060.0) {
        return colormap_f(x);
    } else if (x < 0.739376978894039) {
        float xx = x - 51611.0 / 108060.0;
        return ((-914.74 * xx - 734.72) * xx + 255.) / 255.0;
    } else {
        return 0.0;
    }
}

float colormap_blue(float x) {
    if (x < 0.0) {
        return 19.0 / 255.0;
    } else if (x < 0.238) {
        float xx = x - 0.238;
        return (((1624.6 * xx + 1191.4) * xx + 1180.2) * xx + 255.0) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return 1.0;
    } else if (x < 174.5 / 256.0) {
        return (-951.67322673866 * x + 709.532730938451) / 255.0;
    } else if (x < 0.745745353439206) {
        return (-705.250074130877 * x + 559.620050530617) / 255.0;
    } else if (x <= 1.0) {
        return ((-399.29 * x + 655.71) * x - 233.25) / 255.0;
    } else {
        return 23.0 / 255.0;
    }
}

vec4 colormap(float x) {
    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Va=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((B-0.1)*(1.0/0.9));


    if (B < 0.1) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,ve={},Oa=a=>{const e={vert:Sa,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{iteration:a.prop("iteration"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}};ve.raw=a({frag:Ea,...e}),ve.A_transform_seismic=a({frag:Na,...e}),ve.A_gradiant1=a({frag:La,...e}),ve.A_gradiant2=a({frag:Ra,...e}),ve.A_MATLAB_cool=a({frag:Pa,...e}),ve.A_IDL_CB_RdBu=a({frag:Fa,...e}),ve.A_IDL_CB_RdYiBu=a({frag:Ma,...e}),ve.A_IDL_CB_BuYiRd=a({frag:Ua,...e}),ve.B_IDL_CB_RdYiBu=a({frag:Va,...e}),ve.grayscale=a({frag:Da,...e}),ve.blackwhite=a({frag:za,...e}),ve.whiteblack=a({frag:Ba,...e}),ve.timebasedblue=a({frag:Aa,...e}),ve.lerp=a({frag:Ca,...e}),ve.mrob=a({frag:Ta,...e}),ve.redblue=a({frag:Ia,...e})},Ha=a=>{const{colorMode:e,inputBuffer:n,iteration:o,outputBuffer:t,zoomState:i}=a;(ve[e]||ve.raw)({inputBuffer:n,iteration:o,outputBuffer:t,pan:[i.panX,i.panY],zoomLevel:i.zoomLevel})},Ka=`precision mediump float;

uniform float radius;
uniform sampler2D prevState;
uniform bool pauseSimulation;
uniform float Da;
uniform float Db;
uniform float f;
uniform float k;

uniform bool penIsActive;
uniform bool eraserIsActive;
uniform float penDensity;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

// https://thebookofshaders.com/10/
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
}

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(radius)).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(radius)).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(radius)).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(radius)).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(radius)).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(radius)).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(radius)).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(radius)).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(radius)).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));


    float rnd = random(uv);
    if (penIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(0.0, 1.0, 0, 1);
    } else if (eraserIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(1.0, 0.0, 0, 1);
    } else if (pauseSimulation) {
        gl_FragColor = vec4(A, B, 0, 1);
    } else {
        gl_FragColor = vec4(newA, newB, 0, 1);
    }
}
`,qa=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
uniform float penRadius;

attribute vec2 position;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

void main() {
    uv = 0.5 * (position + 1.0);
    mouseUv = (mousePosition * zoomLevel) + pan * (1.0 - zoomLevel);
    scaledPenRadius = penRadius * zoomLevel;
    gl_Position = vec4(position, 0, 1);
}
`;let xn;const Ya=(a,e)=>{xn=a({frag:Ka,vert:qa,attributes:{position:[-4,-4,4,-4,0,4]},count:3,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),Da:1,Db:.5,f:a.prop("f"),k:a.prop("k"),radius:e,pauseSimulation:a.prop("pauseSimulation"),mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),penDensity:a.prop("penDensity"),penIsActive:a.prop("penIsActive"),eraserIsActive:a.prop("eraserIsActive"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},Ga=a=>{const{inputBuffer:e,outputBuffer:n,pauseSimulation:o,mouseState:t,simulationParameters:i,worldSize:r}=a;xn({inputBuffer:e,outputBuffer:n,pauseSimulation:o,zoomLevel:t.zoomLevel,pan:[t.panX,t.panY],mousePosition:[t.x,t.y],penRadius:1/2**(r-t.penSize),penDensity:t.penDensity,penIsActive:t.pressedLeft,eraserIsActive:t.pressedRight,...i})},Wa=(a,e)=>a==="randomSpots"?Za(e,.001):a==="middleCircleAndRandomSpots"?Xa(e,.005,.05):a==="empty"?ja(e):Qa(e,.02),Xa=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},ja=a=>Array(a*a).fill(0).map(()=>[0,0,0,1]).flat(),Za=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),Qa=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),Ja=`precision highp float;

attribute vec2 position;

uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,el=`precision highp float;

uniform sampler2D prevState;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float division = 10.0;
    float column = mod(uv.x, 1.0 / division);
    float c = column * division;

    float row = mod(uv.y, 1.0 / division);
    float r = row * division;

    // I haven't found a way to compare the value to an exact value
    // Might be a precision issue, or just that I'm missing something
    if (c < 0.05 || r < 0.05) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
       gl_FragColor = color;
    }
}
`;let _n;const tl=a=>{_n=a({vert:Ja,frag:el,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},nl=a=>{const{inputBuffer:e,outputBuffer:n,zoomState:o}=a;_n({inputBuffer:e,outputBuffer:n,zoomLevel:o.zoomLevel,pan:[o.panX,o.panY]})},ol=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

attribute vec2 position;

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}
`,rl=`precision mediump float;

uniform sampler2D prevState;
uniform vec2 mousePosition;
uniform float penRadius;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float d = distance(uv, mousePosition);
    if (
        (d >= penRadius && d <= penRadius + 0.001) ||
        (uv.x >= mousePosition.x - 0.001 && uv.x <= mousePosition.x + 0.001 && uv.y >= mousePosition.y - 0.01 && uv.y <= mousePosition.y + 0.01) ||
        (uv.x >= mousePosition.x - 0.01 && uv.x <= mousePosition.x + 0.01 && uv.y >= mousePosition.y - 0.001 && uv.y <= mousePosition.y + 0.001))
    {
        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    } else {
        gl_FragColor = color;
    }
}
`;let bn;const il=a=>{bn=a({frag:rl,vert:ol,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}})},al=a=>{const{inputBuffer:e,mouseState:n,outputBuffer:o,worldSize:t}=a;bn({inputBuffer:e,outputBuffer:o,mousePosition:[n.x,n.y],penRadius:1/2**(t-n.penSize),zoomLevel:n.zoomLevel,pan:[n.panX,n.panY]})},ll=a=>{const{controls:e,info:n,mouseState:o,simulationParameters:t}=a,i=document.getElementById("canvas");if(!i)throw new Error("Canvas container not ready");const r=Re({extensions:["OES_texture_float"],canvas:i});n.iteration=0;const s=2**n.worldSize,l=Wa(e.initialConditions,s),f=()=>r.framebuffer({color:r.texture({radius:s,data:l,wrap:"repeat",type:"float"}),depthStencil:!1}),c=Array(2).fill(0).map(f),u=Array(2).fill(0).map(f);return Ya(r,s),Oa(r),tl(r),il(r),r.frame(()=>{e.pause||n.iteration++;let p=c[(n.iteration+1)%2];for(let m=0;m<e.speed;m++){n.iteration++;const d=c[n.iteration%2];p=c[(n.iteration+1)%2],Ga({inputBuffer:d,outputBuffer:p,worldSize:n.worldSize,pauseSimulation:e.pause,mouseState:o,simulationParameters:t})}sl({inputTexture:p,graphicsTextures:u,controls:e,info:n,mouseState:o})}),r},sl=a=>{const{inputTexture:e,graphicsTextures:n,controls:o,info:t,mouseState:i}=a;let r=0;r++;const s=e,l=n[r%2];if(Ha({colorMode:o.colors,inputBuffer:s,iteration:t.iteration,outputBuffer:l,zoomState:i}),o.grid){r++;const u=n[(r+1)%2],p=n[r%2];nl({inputBuffer:u,outputBuffer:p,zoomState:i})}r++;const f=n[(r+1)%2],c=null;al({mouseState:i,worldSize:t.worldSize,inputBuffer:f,outputBuffer:c})},Wt=a=>{if(!a.currentTarget)throw new Error("Event has no currentTarget");const e=a.currentTarget,n=e.getBoundingClientRect(),o=a.clientX-n.left,t=a.clientY-n.top,{width:i,height:r}=e,s=o/i,l=(r-t)/r;return{x:s,y:l}};const{window:fl}=je;function cl(a){let e,n,o,t,i,r,s,l,f,c,u,p,m,d=2**a[0].worldSize+"",x,C,E=2**a[0].worldSize+"",S,M,v=2**(a[0].worldSize+1)+"",g,$,L,D,b,O,X;return n=new ya({}),n.$on("fkupdated",a[7]),{c(){e=z("main"),U(n.$$.fragment),o=q(),t=z("div"),i=q(),r=z("div"),s=z("label"),l=R("World Size:"),f=q(),c=z("input"),u=q(),p=z("span"),m=R("("),x=R(d),C=R(" x "),S=R(E),M=R(" : "),g=R(v),$=R(")"),L=q(),D=z("canvas"),this.h()},l(I){e=B(I,"MAIN",{});var F=T(e);G(n.$$.fragment,F),o=Y(F),t=B(F,"DIV",{id:!0,class:!0}),T(t).forEach(h),i=Y(F),r=B(F,"DIV",{});var te=T(r);s=B(te,"LABEL",{for:!0});var xe=T(s);l=P(xe,"World Size:"),xe.forEach(h),f=Y(te),c=B(te,"INPUT",{id:!0,type:!0,step:!0}),u=Y(te),p=B(te,"SPAN",{});var ae=T(p);m=P(ae,"("),x=P(ae,d),C=P(ae," x "),S=P(ae,E),M=P(ae," : "),g=P(ae,v),$=P(ae,")"),ae.forEach(h),te.forEach(h),L=Y(F),D=B(F,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(D).forEach(h),F.forEach(h),this.h()},h(){y(t,"id","datgui-container"),y(t,"class","svelte-18zf5fr"),y(s,"for","worldSize"),y(c,"id","worldSize"),y(c,"type","number"),y(c,"step","1"),y(D,"id","canvas"),y(D,"width",a[1].width),y(D,"height",a[1].height),y(D,"class","svelte-18zf5fr")},m(I,F){A(I,e,F),N(n,e,null),w(e,o),w(e,t),w(e,i),w(e,r),w(r,s),w(s,l),w(r,f),w(r,c),ye(c,a[0].worldSize),w(r,u),w(r,p),w(p,m),w(p,x),w(p,C),w(p,S),w(p,M),w(p,g),w(p,$),w(e,L),w(e,D),b=!0,O||(X=[Z(fl,"keydown",a[2]),Z(c,"input",a[8]),Z(c,"change",a[6]),Z(D,"mousemove",a[4]),Z(D,"mousedown",we(a[5])),Z(D,"mouseup",a[5]),Z(D,"wheel",a[3]),Z(D,"keydown",we(a[2])),Z(D,"contextmenu",we(ul))],O=!0)},p(I,[F]){F&1&&Ae(c.value)!==I[0].worldSize&&ye(c,I[0].worldSize),(!b||F&1)&&d!==(d=2**I[0].worldSize+"")&&pe(x,d),(!b||F&1)&&E!==(E=2**I[0].worldSize+"")&&pe(S,E),(!b||F&1)&&v!==(v=2**(I[0].worldSize+1)+"")&&pe(g,v)},i(I){b||(_(n.$$.fragment,I),b=!0)},o(I){k(n.$$.fragment,I),b=!1},d(I){I&&h(e),V(n),O=!1,ze(X)}}}const ul=a=>a;function pl(a,e,n){const o={width:Math.min(window.innerWidth,window.innerHeight)*.9,height:Math.min(window.innerWidth,window.innerHeight)*.9},t={colors:"A_transform_seismic",initialConditions:"middleCircleAndRandomSpots",reset:()=>x(),pause:!1,grid:!1,speed:50},i={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:3,penDensity:.3,zoomLevel:1,panX:.5,panY:.5},r={iteration:0,worldSize:8},s={f:He[0].f,k:He[0].k};let l,f;const c=async()=>{const S=await Ie(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);l=new S.GUI({autoPlace:!1,closeOnTop:!0}),l.domElement.id="datgui";const M=document.getElementById("datgui-container");if(!M)throw new Error("Gui container not ready");M.appendChild(l.domElement),l.add(t,"pause").name("Pause"),l.add(t,"grid").name("Debug grid"),l.add(t,"reset").name("Reset simulation"),l.add(t,"colors",["grayscale","blackwhite","whiteblack","raw","timebasedblue","lerp","mrob","redblue","A_gradiant1","A_gradiant2","A_MATLAB_cool","A_IDL_CB_RdBu","A_IDL_CB_RdYiBu","A_IDL_CB_BuYiRd","A_transform_seismic","B_IDL_CB_RdYiBu"]).name("Color scheme");const v={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots",Empty:"empty"};l.add(t,"initialConditions",v).onFinishChange(t.reset).name("Initial conditions");const g=l.add(r,"iteration").listen();g.domElement.style.pointerEvents="none",l.add(t,"speed",1,200).name("Simulation speed"),l.add(i,"penSize",0,r.worldSize).name("Pen size"),l.add(i,"penDensity",0,1).name("Pen density"),l.add(i,"zoomLevel",0,1).name("Zoom level").listen(),l.add(i,"panX",0,1).name("pan x").listen(),l.add(i,"panY",0,1).name("pan y").listen()},u=S=>{if(S.code==="Space"){t.pause=!t.pause,S.preventDefault();return}if(S.code==="KeyR"&&!S.getModifierState("Control")){x(),S.preventDefault();return}},p=S=>{if(!S.getModifierState("Control"))return;const M=Wt(S);i.panX=M.x,i.panY=M.y,S.deltaY>0?i.zoomLevel*=1+i.zoomLevel/2:i.zoomLevel*=1-i.zoomLevel/2,i.zoomLevel>1&&(i.zoomLevel=1),i.zoomLevel<0&&(i.zoomLevel=0),S.preventDefault()},m=S=>{const M=Wt(S);i.x=M.x,i.y=M.y},d=S=>{if(![0,2].includes(S.button)||!["mouseup","mousedown"].includes(S.type))return;let M=S.type==="mousedown";S.button===0&&(i.pressedLeft=M),S.button===2&&(i.pressedRight=M)},x=()=>{isNaN(r.worldSize)||(r.worldSize>11&&n(0,r.worldSize=11,r),r.worldSize<1&&n(0,r.worldSize=1,r),l&&(document.getElementById(l.domElement.id)?.remove(),l.destroy()),f?.destroy(),c(),f=ll({controls:t,info:r,mouseState:i,simulationParameters:s}))},C=S=>{s.f=S.detail.f,s.k=S.detail.k};Ee(()=>{x()}),ke(()=>{l.destroy(),f.destroy()});function E(){r.worldSize=Ae(this.value),n(0,r)}return[r,o,u,p,m,d,x,C,E]}let ml=class extends Q{constructor(e){super(),J(this,e,pl,cl,ee,{})}};const Ke=[{name:"KarlSims",type:"Unknown",f:.055,k:.062},{name:"STX 1",type:"N.A",f:.0353,k:.0614},{name:"STX 2",type:"N.A",f:.0201,k:.0602},{name:"STX 2",type:"N.A",f:.0181,k:.0435},{name:"α 1",type:"alpha",f:.01,k:.047},{name:"α 2",type:"alpha",f:.014,k:.053},{name:"β 1",type:"beta",f:.014,k:.039},{name:"β 2",type:"beta",f:.026,k:.051},{name:"δ 1",type:"delta",f:.03,k:.055},{name:"δ 2",type:"delta",f:.042,k:.059},{name:"ε 1",type:"epsilon",f:.018,k:.055},{name:"ε 2",type:"epsilon",f:.022,k:.059},{name:"η 1",type:"eta",f:.034,k:.063},{name:"γ 1",type:"gamma",f:.022,k:.051},{name:"γ 2",type:"gamma",f:.026,k:.055},{name:"ι 1",type:"iota",f:.046,k:.0594},{name:"κ 1",type:"kappa",f:.082,k:.06},{name:"κ 2",type:"kappa",f:.058,k:.063},{name:"λ 1",type:"lambda",f:.026,k:.061},{name:"λ 2",type:"lambda",f:.034,k:.065},{name:"μ 1",type:"mu",f:.046,k:.065},{name:"μ 2",type:"mu",f:.058,k:.065},{name:"ν 2",type:"nu",f:.046,k:.067},{name:"π 1",type:"pi",f:.062,k:.061},{name:"ρ 1",type:"rho",f:.09,k:.059},{name:"ρ 2",type:"rho",f:.102,k:.055},{name:"σ 1",type:"sigma",f:.09,k:.057},{name:"θ 2",type:"sigma",f:.11,k:.0523},{name:"θ 1",type:"theta",f:.03,k:.057},{name:"θ 2",type:"theta",f:.038,k:.061},{name:"ξ 1",type:"xi",f:.01,k:.041},{name:"ξ 2",type:"xi",f:.014,k:.047},{name:"ζ 1",type:"zeta",f:.022,k:.061},{name:"ζ 2",type:"zeta",f:.026,k:.059}];function Xt(a,e,n){const o=a.slice();return o[18]=e[n],o}function jt(a){let e,n,o,t,i,r,s,l,f,c=Ke,u=[];for(let p=0;p<c.length;p+=1)u[p]=Zt(Xt(a,c,p));return r=new Le({props:{sketch:a[3]}}),{c(){e=z("div"),n=R("Select f and k parameters on the map of use a preset"),o=q(),t=z("select");for(let p=0;p<u.length;p+=1)u[p].c();i=q(),U(r.$$.fragment),this.h()},l(p){e=B(p,"DIV",{});var m=T(e);n=P(m,"Select f and k parameters on the map of use a preset"),m.forEach(h),o=Y(p),t=B(p,"SELECT",{class:!0});var d=T(t);for(let x=0;x<u.length;x+=1)u[x].l(d);d.forEach(h),i=Y(p),G(r.$$.fragment,p),this.h()},h(){y(t,"class","full-width svelte-1qznlxf"),a[0]===void 0&&it(()=>a[5].call(t))},m(p,m){A(p,e,m),w(e,n),A(p,o,m),A(p,t,m);for(let d=0;d<u.length;d+=1)u[d].m(t,null);Oe(t,a[0]),A(p,i,m),N(r,p,m),s=!0,l||(f=[Z(t,"change",a[5]),Z(t,"change",a[6])],l=!0)},p(p,m){if(m&0){c=Ke;let d;for(d=0;d<c.length;d+=1){const x=Xt(p,c,d);u[d]?u[d].p(x,m):(u[d]=Zt(x),u[d].c(),u[d].m(t,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}m&1&&Oe(t,p[0])},i(p){s||(_(r.$$.fragment,p),s=!0)},o(p){k(r.$$.fragment,p),s=!1},d(p){p&&h(e),p&&h(o),p&&h(t),$e(u,p),p&&h(i),V(r,p),l=!1,ze(f)}}}function Zt(a){let e,n=a[18].type+"",o,t,i=a[18].name+"",r,s,l=a[18].f+"",f,c,u=a[18].k+"",p,m;return{c(){e=z("option"),o=R(n),t=R(" - "),r=R(i),s=R(" (f/k "),f=R(l),c=R(" / "),p=R(u),m=R(`)
                `),this.h()},l(d){e=B(d,"OPTION",{});var x=T(e);o=P(x,n),t=P(x," - "),r=P(x,i),s=P(x," (f/k "),f=P(x,l),c=P(x," / "),p=P(x,u),m=P(x,`)
                `),x.forEach(h),this.h()},h(){e.__value=a[18],e.value=e.__value},m(d,x){A(d,e,x),w(e,o),w(e,t),w(e,r),w(e,s),w(e,f),w(e,c),w(e,p),w(e,m)},p:ne,d(d){d&&h(e)}}}function dl(a){let e,n,o=a[1]?"Close":"F/K selection",t,i,r,s,l,f=a[1]&&jt(a);return{c(){e=z("div"),n=z("button"),t=R(o),i=q(),f&&f.c(),this.h()},l(c){e=B(c,"DIV",{id:!0,class:!0});var u=T(e);n=B(u,"BUTTON",{class:!0,id:!0});var p=T(n);t=P(p,o),p.forEach(h),i=Y(u),f&&f.l(u),u.forEach(h),this.h()},h(){y(n,"class","full-width svelte-1qznlxf"),y(n,"id","toggleButton"),y(e,"id","container"),y(e,"class","svelte-1qznlxf"),Te(e,"no-cursor",hl)},m(c,u){A(c,e,u),w(e,n),w(n,t),w(e,i),f&&f.m(e,null),r=!0,s||(l=Z(n,"click",a[4]),s=!0)},p(c,[u]){(!r||u&2)&&o!==(o=c[1]?"Close":"F/K selection")&&pe(t,o),c[1]?f?(f.p(c,u),u&2&&_(f,1)):(f=jt(c),f.c(),_(f,1),f.m(e,null)):f&&(oe(),k(f,1,1,()=>{f=null}),re())},i(c){r||(_(f),r=!0)},o(c){k(f),r=!1},d(c){c&&h(e),f&&f.d(),s=!1,l()}}}let hl=!1;function vl(a,e){let n=!1,o=1/0,t=null;for(let i=0;i<e.length;i++){const r=e[i],s=e[(i+1)%e.length];if(a[0]===r[0]&&a[1]===r[1])return a;r[1]>a[1]!=s[1]>a[1]&&a[0]<(s[0]-r[0])*(a[1]-r[1])/(s[1]-r[1])+r[0]&&(n=!n);const f=gl(a,r,s);f<o&&(o=f,t=xl(a,r,s))}if(n)return a;if(!t)throw new Error("Now closest point found");return t}function gl(a,e,n){const o=[n[0]-e[0],n[1]-e[1]],t=[a[0]-e[0],a[1]-e[1]],i=o[0]*t[0]+o[1]*t[1],r=o[0]*o[0]+o[1]*o[1],s=i/r;let l;return s<0?l=e:s>1?l=n:l=[e[0]+s*o[0],e[1]+s*o[1]],Math.sqrt((a[0]-l[0])**2+(a[1]-l[1])**2)}function xl(a,e,n){const o=[n[0]-e[0],n[1]-e[1]],t=[a[0]-e[0],a[1]-e[1]],i=o[0]*t[0]+o[1]*t[1],r=o[0]*o[0]+o[1]*o[1],s=i/r;let l;return s<0?l=e:s>1?l=n:l=[e[0]+s*o[0],e[1]+s*o[1]],l}function _l(a,e,n){const o=Xe();let t=Ke[0],i=!0;const r=[0,.12],s=[.03,.07],l=[{f:.1045,k:.0553},{f:.0829,k:.0582},{f:.0664,k:.0595},{f:.0511,k:.0594},{f:.0307,k:.0549},{f:.017,k:.0467},{f:.005,k:.0335},{f:.0076,k:.0472},{f:.0166,k:.0594},{f:.0277,k:.0657},{f:.046,k:.0675},{f:.0757,k:.0643},{f:.0949,k:.0594}],f=g=>{const{f:$,k:L}=g,D=C.map(L,s[0],s[1],0,C.width),b=C.map($,r[0],r[1],C.height,0);return{x:D,y:b}},c=g=>{g.noStroke();const $=g.textSize();for(const L of Ke){const{x:D,y:b}=f({f:L.f,k:L.k}),O=L.f===t.f&&L.k===t.k;g.circle(D,b,3),g.textSize(O?$*2:$),g.fill(O?[240,240,150]:[255,255,255]),g.text(L.name,D-g.textWidth(L.name)/2,b-10)}},u=g=>{g.noFill(),g.stroke("red"),g.strokeWeight(1);const{x:$,y:L}=f(t);g.text("F",10,L>10?L-5:L+15),g.line(0,L,g.width,L),g.text("K",$<g.width-10?$+5:$-15,g.height-10),g.line($,0,$,g.height),g.circle($,L,10)},p=g=>{const{f:$,k:L}=t,D=`F: ${$.toFixed(4)}`,b=`K: ${L.toFixed(4)}`,O=g.textSize(),X=g.height*.05;g.textStyle(g.BOLD),g.textSize(X),g.fill("white"),g.stroke(0),g.strokeWeight(1),g.text(D,g.width*.05,g.textSize()),g.text(b,g.width*.05,g.textSize()+g.textSize()+6),g.textStyle(g.NORMAL),g.textSize(O)},m=g=>{for(let $=0;$<l.length;$++){const{x:L,y:D}=f(l[$]),{x:b,y:O}=f(l[($+1)%l.length]);g.fill("white"),g.stroke("white"),g.strokeWeight(1),g.circle(L,D,3),g.circle(b,O,3),g.line(L,D,b,O)}},d=()=>{const g=[t.f,t.k],$=l.map(D=>[D.f,D.k]),L=vl(g,$);n(0,t.f=L[0],t),n(0,t.k=L[1],t)},x=()=>{let{f:g,k:$}=t;const L=C.noise(C.frameCount*.01),D=C.noise(5321+C.frameCount*.01),O=Math.random()<.97?.001:.01;g=g+(D*2-1)*(r[1]-r[0])*O,$=$+(L*2-1)*(s[1]-s[0])*O,n(0,t={f:g,k:$,name:"custom",type:"manual"}),d(),o("fkupdated",t)};let C;const E=g=>{C=g;let $;g.preload=()=>{$=g.loadImage(Ze+"/parameters_map.png")},g.setup=()=>{g.createCanvas(400,400),g.frameRate(55)},g.draw=()=>{g.background(255),g.tint(150,190),g.image($,0,0,g.width,g.height),c(g),m(g),u(g),p(g),x()}},S=()=>{n(1,i=!i),i||C.remove()};ke(()=>C?.remove());function M(){t=at(this),n(0,t)}return[t,i,o,E,S,M,()=>o("fkupdated",t)]}class bl extends Q{constructor(e){super(),J(this,e,_l,dl,ee,{})}}const wl=`precision mediump float;
attribute vec2 position;
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,$l=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    gl_FragColor = vec4(A, B, 0.0, 1.0);
}

`,kl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float PI = 3.14159265359;
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = sin(iteration*PI/180.0);
    if (val < 0.0) {
        val = -1.0 * val;
    }
    gl_FragColor = vec4(A, B, val, 1.0);
}
`,yl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (A + B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}

`,Sl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(1.0 - val, 1.0 - val, 1.0 - val, 1.0);
}
`,El=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}
`,Al=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    // vec3 color1 = vec3(1.0, 0.0, 0.0);
    // vec3 color2 = vec3(0.0, 1.0, 0.0);
    // vec3 result = color1 * A + color2 * B;

    vec3 color1RGB = vec3(0.639, 0.941, 0.717);
    vec3 color2RGB = vec3(0.929, 0.082, 0.705);

    vec3 color1HSV = rgb2hsv(color1RGB);
    vec3 color2HSV = rgb2hsv(color2RGB);

    float color1Offset = (cos(iteration * 0.001) + 1.0) * 0.5;
    float color1newH = 0.5 * (color1HSV.x + color1Offset);
    vec3 color1newHSV = vec3(color1newH, color1HSV.g, color1HSV.b);

    float color2Offset = (cos(iteration * 0.002)) * 0.5;
    float color2newH = 0.5 * (color2HSV.x + color2Offset + 0.33);
    vec3 color2newHSV = vec3(color2newH, color2HSV.g, color2HSV.b);


    vec3 resultHSV = color1newHSV * A + color2newHSV * B;
    vec3 result = hsv2rgb(resultHSV);

    gl_FragColor = vec4(result, 1.0);
}
`,Dl=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float red = A; // The more A the redder
    float blue = 1.0 - A; // The less A the bleuer

    float green = max(A, B) - min(A, B);

    vec3 result = vec3(red, green, blue);

    gl_FragColor = vec4(result, 1.0);
}
`,zl=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec3 color1 = vec3(0.0, 0.0, 1.0);
    vec3 color2 = vec3(1.0, 0.0, 0.0);
    vec3 result = vec3(A, 0.0, 1.0-A);

    gl_FragColor = vec4(result, 1.0);
}
`,Bl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    if (A > 0.9) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else if (A > 0.4) {
        gl_FragColor = vec4(1.0 - A, 0.0, 0.0, 1.0);
    } else { 
        gl_FragColor = vec4(0.0, A, 0.0, 1.0);
    }
}
`,Cl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);
    vec4 color = mix(blue, red, A);

    vec4 softRed = vec4(0.8588, 0.2824, 0.3765, 1.0);
    vec4 softBlue = vec4(0.2824, 0.3882, 0.8588, 1.0);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.6);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.4);
    vec4 softColor = mix(softBlue, softRed, 1.0-A);


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(color);
    }

}
`,Tl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/MATLAB_cool.frag
float colormap_red(float x) {
    return (1.0 + 1.0 / 63.0) * x - 1.0 / 63.0;
}

float colormap_green(float x) {
    return -(1.0 + 1.0 / 63.0) * x + (1.0 + 1.0 / 63.0);
}

vec4 colormap(float x) {
    float r = clamp(colormap_red(x), 0.0, 1.0);
    float g = clamp(colormap_green(x), 0.0, 1.0);
    float b = 1.0;
    return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Il=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdBu.frag
float colormap_red(float x) {
	if (x < 0.09771832105856419) {
		return 7.60263247863246E+02 * x + 1.02931623931624E+02;
	} else if (x < 0.3017162107441106) {
		return (-2.54380938558548E+02 * x + 4.29911571188803E+02) * x + 1.37642085716717E+02;
	} else if (x < 0.4014205790737471) {
		return 8.67103448276151E+01 * x + 2.18034482758611E+02;
	} else if (x < 0.5019932233215039) {
		return -6.15461538461498E+01 * x + 2.77547692307680E+02;
	} else if (x < 0.5969483882550937) {
		return -3.77588522588624E+02 * x + 4.36198819698878E+02;
	} else if (x < 0.8046060096654594) {
		return (-6.51345897546620E+02 * x + 2.09780968434337E+02) * x + 3.17674951640855E+02;
	} else {
		return -3.08431855203590E+02 * x + 3.12956742081421E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09881640500975222) {
		return 2.41408547008547E+02 * x + 3.50427350427364E-01;
	} else if (x < 0.5000816285610199) {
		return ((((1.98531871433258E+04 * x - 2.64108262469187E+04) * x + 1.10991785969817E+04) * x - 1.92958444776211E+03) * x + 8.39569642882186E+02) * x - 4.82944517518776E+01;
	} else if (x < 0.8922355473041534) {
		return (((6.16712686949223E+03 * x - 1.59084026055125E+04) * x + 1.45172137257997E+04) * x - 5.80944127411621E+03) * x + 1.12477959061948E+03;
	} else {
		return -5.28313797313699E+02 * x + 5.78459299959206E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.1033699568661857) {
		return 1.30256410256410E+02 * x + 3.08518518518519E+01;
	} else if (x < 0.2037526071071625) {
		return 3.38458128078815E+02 * x + 9.33004926108412E+00;
	} else if (x < 0.2973267734050751) {
		return (-1.06345054944861E+02 * x + 5.93327252747168E+02) * x - 3.81852747252658E+01;
	} else if (x < 0.4029109179973602) {
		return 6.68959706959723E+02 * x - 7.00740740740798E+01;
	} else if (x < 0.5006715489526758) {
		return 4.87348695652202E+02 * x + 3.09898550724286E+00;
	} else if (x < 0.6004396902588283) {
		return -6.85799999999829E+01 * x + 2.81436666666663E+02;
	} else if (x < 0.702576607465744) {
		return -1.81331701891043E+02 * x + 3.49137263626287E+02;
	} else if (x < 0.9010407030582428) {
		return (2.06124143164576E+02 * x - 5.78166906665595E+02) * x + 5.26198653917172E+02;
	} else {
		return -7.36990769230737E+02 * x + 8.36652307692262E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Ll=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Rl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap(1.0 - (A-0.4)*(1.0/0.6));


    if (A > 0.6) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Pl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/transform_seismic.frag
float colormap_f(float x) {
    return ((-2010.0 * x + 2502.5950459) * x - 481.763180924) / 255.0;
}

float colormap_red(float x) {
    if (x < 0.0) {
        return 3.0 / 255.0;
    } else if (x < 0.238) {
        return ((-1810.0 * x + 414.49) * x + 3.87702) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return (344441250.0 / 323659.0 * x - 23422005.0 / 92474.0) / 255.0;
    } else if (x < 25851.0 / 34402.0) {
        return 1.0;
    } else if (x <= 1.0) {
        return (-688.04 * x + 772.02) / 255.0;
    } else {
        return 83.0 / 255.0;
    }
}

float colormap_green(float x) {
    if (x < 0.0) {
        return 0.0;
    } else if (x < 0.238) {
        return 0.0;
    } else if (x < 51611.0 / 108060.0) {
        return colormap_f(x);
    } else if (x < 0.739376978894039) {
        float xx = x - 51611.0 / 108060.0;
        return ((-914.74 * xx - 734.72) * xx + 255.) / 255.0;
    } else {
        return 0.0;
    }
}

float colormap_blue(float x) {
    if (x < 0.0) {
        return 19.0 / 255.0;
    } else if (x < 0.238) {
        float xx = x - 0.238;
        return (((1624.6 * xx + 1191.4) * xx + 1180.2) * xx + 255.0) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return 1.0;
    } else if (x < 174.5 / 256.0) {
        return (-951.67322673866 * x + 709.532730938451) / 255.0;
    } else if (x < 0.745745353439206) {
        return (-705.250074130877 * x + 559.620050530617) / 255.0;
    } else if (x <= 1.0) {
        return ((-399.29 * x + 655.71) * x - 233.25) / 255.0;
    } else {
        return 23.0 / 255.0;
    }
}

vec4 colormap(float x) {
    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Fl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((B-0.1)*(1.0/0.9));


    if (B < 0.1) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,ge={},Ml=a=>{const e={vert:wl,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{iteration:a.prop("iteration"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}};ge.raw=a({frag:$l,...e}),ge.A_transform_seismic=a({frag:Pl,...e}),ge.A_gradiant1=a({frag:Bl,...e}),ge.A_gradiant2=a({frag:Cl,...e}),ge.A_MATLAB_cool=a({frag:Tl,...e}),ge.A_IDL_CB_RdBu=a({frag:Il,...e}),ge.A_IDL_CB_RdYiBu=a({frag:Ll,...e}),ge.A_IDL_CB_BuYiRd=a({frag:Rl,...e}),ge.B_IDL_CB_RdYiBu=a({frag:Fl,...e}),ge.grayscale=a({frag:yl,...e}),ge.blackwhite=a({frag:Sl,...e}),ge.whiteblack=a({frag:El,...e}),ge.timebasedblue=a({frag:kl,...e}),ge.lerp=a({frag:Al,...e}),ge.mrob=a({frag:Dl,...e}),ge.redblue=a({frag:zl,...e})},Ul=a=>{const{colorMode:e,inputBuffer:n,iteration:o,outputBuffer:t,zoomState:i}=a;(ge[e]||ge.raw)({inputBuffer:n,iteration:o,outputBuffer:t,pan:[i.panX,i.panY],zoomLevel:i.zoomLevel})},Nl=`precision mediump float;

uniform float radius;
uniform sampler2D prevState;
uniform bool pauseSimulation;
uniform float Da;
uniform float Db;
uniform float f;
uniform float k;

uniform bool penIsActive;
uniform bool eraserIsActive;
uniform float penDensity;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

// https://thebookofshaders.com/10/
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
}

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(radius)).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(radius)).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(radius)).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(radius)).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(radius)).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(radius)).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(radius)).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(radius)).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(radius)).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));


    float rnd = random(uv);
    if (penIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(0.0, 1.0, 0, 1);
    } else if (eraserIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(1.0, 0.0, 0, 1);
    } else if (pauseSimulation) {
        gl_FragColor = vec4(A, B, 0, 1);
    } else {
        gl_FragColor = vec4(newA, newB, 0, 1);
    }
}
`,Vl=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
uniform float penRadius;

attribute vec2 position;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

void main() {
    uv = 0.5 * (position + 1.0);
    mouseUv = (mousePosition * zoomLevel) + pan * (1.0 - zoomLevel);
    scaledPenRadius = penRadius * zoomLevel;
    gl_Position = vec4(position, 0, 1);
}
`;let wn;const Ol=(a,e)=>{wn=a({frag:Nl,vert:Vl,attributes:{position:[-4,-4,4,-4,0,4]},count:3,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),Da:1,Db:.5,f:a.prop("f"),k:a.prop("k"),radius:e,pauseSimulation:a.prop("pauseSimulation"),mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),penDensity:a.prop("penDensity"),penIsActive:a.prop("penIsActive"),eraserIsActive:a.prop("eraserIsActive"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},Hl=a=>{const{inputBuffer:e,outputBuffer:n,pauseSimulation:o,mouseState:t,simulationParameters:i,worldSize:r}=a;wn({inputBuffer:e,outputBuffer:n,pauseSimulation:o,zoomLevel:t.zoomLevel,pan:[t.panX,t.panY],mousePosition:[t.x,t.y],penRadius:1/2**(r-t.penSize),penDensity:t.penDensity,penIsActive:t.pressedLeft,eraserIsActive:t.pressedRight,...i})},Kl=(a,e)=>a==="randomSpots"?Gl(e,.001):a==="middleCircleAndRandomSpots"?ql(e,.005,.05):a==="empty"?Yl(e):Wl(e,.02),ql=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},Yl=a=>Array(a*a).fill(0).map(()=>[0,0,0,1]).flat(),Gl=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),Wl=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),Xl=`precision highp float;

attribute vec2 position;

uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,jl=`precision highp float;

uniform sampler2D prevState;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float division = 10.0;
    float column = mod(uv.x, 1.0 / division);
    float c = column * division;

    float row = mod(uv.y, 1.0 / division);
    float r = row * division;

    // I haven't found a way to compare the value to an exact value
    // Might be a precision issue, or just that I'm missing something
    if (c < 0.05 || r < 0.05) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
       gl_FragColor = color;
    }
}
`;let $n;const Zl=a=>{$n=a({vert:Xl,frag:jl,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},Ql=a=>{const{inputBuffer:e,outputBuffer:n,zoomState:o}=a;$n({inputBuffer:e,outputBuffer:n,zoomLevel:o.zoomLevel,pan:[o.panX,o.panY]})},Jl=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

attribute vec2 position;

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}
`,es=`precision mediump float;

uniform sampler2D prevState;
uniform vec2 mousePosition;
uniform float penRadius;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float d = distance(uv, mousePosition);
    if (
        (d >= penRadius && d <= penRadius + 0.001) ||
        (uv.x >= mousePosition.x - 0.001 && uv.x <= mousePosition.x + 0.001 && uv.y >= mousePosition.y - 0.01 && uv.y <= mousePosition.y + 0.01) ||
        (uv.x >= mousePosition.x - 0.01 && uv.x <= mousePosition.x + 0.01 && uv.y >= mousePosition.y - 0.001 && uv.y <= mousePosition.y + 0.001))
    {
        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    } else {
        gl_FragColor = color;
    }
}
`;let kn;const ts=a=>{kn=a({frag:es,vert:Jl,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}})},ns=a=>{const{inputBuffer:e,mouseState:n,outputBuffer:o,worldSize:t}=a;kn({inputBuffer:e,outputBuffer:o,mousePosition:[n.x,n.y],penRadius:1/2**(t-n.penSize),zoomLevel:n.zoomLevel,pan:[n.panX,n.panY]})},os=a=>{const{controls:e,info:n,mouseState:o,simulationParameters:t}=a,i=document.getElementById("canvas");if(!i)throw new Error("Canvas container not ready");const r=Re({extensions:["OES_texture_float"],canvas:i});n.iteration=0;const s=2**n.worldSize,l=Kl(e.initialConditions,s),f=()=>r.framebuffer({color:r.texture({radius:s,data:l,wrap:"repeat",type:"float"}),depthStencil:!1}),c=Array(2).fill(0).map(f),u=Array(2).fill(0).map(f);return Ol(r,s),Ml(r),Zl(r),ts(r),r.frame(()=>{e.pause||n.iteration++;let p=c[(n.iteration+1)%2];for(let m=0;m<e.speed;m++){n.iteration++;const d=c[n.iteration%2];p=c[(n.iteration+1)%2],Hl({inputBuffer:d,outputBuffer:p,worldSize:n.worldSize,pauseSimulation:e.pause,mouseState:o,simulationParameters:t})}rs({inputTexture:p,graphicsTextures:u,controls:e,info:n,mouseState:o})}),r},rs=a=>{const{inputTexture:e,graphicsTextures:n,controls:o,info:t,mouseState:i}=a;let r=0;r++;const s=e;let l=n[r%2];if(!o.grid&&!o.pen&&(l=null),Ul({colorMode:o.colors,inputBuffer:s,iteration:t.iteration,outputBuffer:l,zoomState:i}),o.grid){r++;const f=n[(r+1)%2];let c=n[r%2];o.pen||(c=null),Ql({inputBuffer:f,outputBuffer:c,zoomState:i})}if(o.pen){r++;const f=n[(r+1)%2],c=null;ns({mouseState:i,worldSize:t.worldSize,inputBuffer:f,outputBuffer:c})}};const{window:is}=je;function as(a){let e,n,o,t,i,r,s,l,f,c,u,p,m,d=2**a[0].worldSize+"",x,C,E=2**a[0].worldSize+"",S,M,v=2**(a[0].worldSize+1)+"",g,$,L,D,b,O,X;return n=new bl({}),n.$on("fkupdated",a[4]),{c(){e=z("main"),U(n.$$.fragment),o=q(),t=z("div"),i=q(),r=z("div"),s=z("label"),l=R("World Size:"),f=q(),c=z("input"),u=q(),p=z("span"),m=R("("),x=R(d),C=R(" x "),S=R(E),M=R(" : "),g=R(v),$=R(")"),L=q(),D=z("canvas"),this.h()},l(I){e=B(I,"MAIN",{});var F=T(e);G(n.$$.fragment,F),o=Y(F),t=B(F,"DIV",{id:!0,class:!0}),T(t).forEach(h),i=Y(F),r=B(F,"DIV",{});var te=T(r);s=B(te,"LABEL",{for:!0});var xe=T(s);l=P(xe,"World Size:"),xe.forEach(h),f=Y(te),c=B(te,"INPUT",{id:!0,type:!0,step:!0}),u=Y(te),p=B(te,"SPAN",{});var ae=T(p);m=P(ae,"("),x=P(ae,d),C=P(ae," x "),S=P(ae,E),M=P(ae," : "),g=P(ae,v),$=P(ae,")"),ae.forEach(h),te.forEach(h),L=Y(F),D=B(F,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(D).forEach(h),F.forEach(h),this.h()},h(){y(t,"id","datgui-container"),y(t,"class","svelte-18zf5fr"),y(s,"for","worldSize"),y(c,"id","worldSize"),y(c,"type","number"),y(c,"step","1"),y(D,"id","canvas"),y(D,"width",a[1].width),y(D,"height",a[1].height),y(D,"class","svelte-18zf5fr")},m(I,F){A(I,e,F),N(n,e,null),w(e,o),w(e,t),w(e,i),w(e,r),w(r,s),w(s,l),w(r,f),w(r,c),ye(c,a[0].worldSize),w(r,u),w(r,p),w(p,m),w(p,x),w(p,C),w(p,S),w(p,M),w(p,g),w(p,$),w(e,L),w(e,D),b=!0,O||(X=[Z(is,"keydown",a[2]),Z(c,"input",a[5]),Z(c,"change",a[3]),Z(D,"contextmenu",we(ls))],O=!0)},p(I,[F]){F&1&&Ae(c.value)!==I[0].worldSize&&ye(c,I[0].worldSize),(!b||F&1)&&d!==(d=2**I[0].worldSize+"")&&pe(x,d),(!b||F&1)&&E!==(E=2**I[0].worldSize+"")&&pe(S,E),(!b||F&1)&&v!==(v=2**(I[0].worldSize+1)+"")&&pe(g,v)},i(I){b||(_(n.$$.fragment,I),b=!0)},o(I){k(n.$$.fragment,I),b=!1},d(I){I&&h(e),V(n),O=!1,ze(X)}}}const ls=a=>a;function ss(a,e,n){const o={width:Math.min(window.innerWidth,window.innerHeight)*.9,height:Math.min(window.innerWidth,window.innerHeight)*.9},t={colors:"A_transform_seismic",initialConditions:"middleCircleAndRandomSpots",reset:()=>d(),pause:!1,grid:!1,pen:!1,speed:50},i={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:3,penDensity:.3,zoomLevel:1,panX:.5,panY:.5},r={iteration:0,worldSize:8},s={f:Ke[0].f,k:Ke[0].k};let l,f;const c=async()=>{const E=await Ie(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);l=new E.GUI({autoPlace:!1,closeOnTop:!0}),l.domElement.id="datgui";const S=document.getElementById("datgui-container");if(!S)throw new Error("Gui container not ready");S.appendChild(l.domElement),l.add(t,"pause").name("Pause"),l.add(t,"grid").name("Debug grid"),l.add(t,"pen").name("Show pen"),l.add(t,"reset").name("Reset simulation"),l.add(t,"colors",["grayscale","blackwhite","whiteblack","raw","timebasedblue","lerp","mrob","redblue","A_gradiant1","A_gradiant2","A_MATLAB_cool","A_IDL_CB_RdBu","A_IDL_CB_RdYiBu","A_IDL_CB_BuYiRd","A_transform_seismic","B_IDL_CB_RdYiBu"]).name("Color scheme");const M={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots",Empty:"empty"};l.add(t,"initialConditions",M).onFinishChange(t.reset).name("Initial conditions");const v=l.add(r,"iteration").listen();v.domElement.style.pointerEvents="none",l.add(t,"speed",1,200).name("Simulation speed").listen(),l.add(i,"penSize",0,r.worldSize).name("Pen size").listen(),l.add(i,"penDensity",0,1).name("Pen density"),l.add(i,"zoomLevel",0,1).name("Zoom level").listen(),l.add(i,"panX",0,1).name("pan x").listen(),l.add(i,"panY",0,1).name("pan y").listen()},u=E=>{if(E.code==="Space"){t.pause=!t.pause,E.preventDefault();return}if(E.code==="KeyR"&&!E.getModifierState("Control")){d(),E.preventDefault();return}};let p;const m=()=>{i.x=Math.random(),i.y=Math.random(),i.penSize=Math.random()*3,i.pressedLeft=!0,setTimeout(()=>i.pressedLeft=!1,500),p=setTimeout(m,Math.random()*5e3)},d=()=>{isNaN(r.worldSize)||(r.worldSize>11&&n(0,r.worldSize=11,r),r.worldSize<1&&n(0,r.worldSize=1,r),l&&(document.getElementById(l.domElement.id)?.remove(),l.destroy()),f?.destroy(),c(),f=os({controls:t,info:r,mouseState:i,simulationParameters:s}),p&&clearTimeout(p),m())},x=E=>{s.f=E.detail.f,s.k=E.detail.k,s.f>.03?t.speed=50:t.speed=2};Ee(()=>{d()}),ke(()=>{l.destroy(),f.destroy()});function C(){r.worldSize=Ae(this.value),n(0,r)}return[r,o,u,d,x,C]}let fs=class extends Q{constructor(e){super(),J(this,e,ss,as,ee,{})}};function Qt(a,e,n){const o=a.slice();return o[1]=e[n],o}function Jt(a,e,n){const o=a.slice();return o[1]=e[n],o}function cs(a){let e=a[1].title+"",n;return{c(){n=R(e)},l(o){n=P(o,e)},m(o,t){A(o,n,t)},p:ne,d(o){o&&h(n)}}}function en(a){let e,n;return e=new Ue({props:{$$slots:{default:[cs]},$$scope:{ctx:a}}}),{c(){U(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){N(e,o,t),n=!0},p(o,t){const i={};t&64&&(i.$$scope={dirty:t,ctx:o}),e.$set(i)},i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){V(e,o)}}}function us(a){let e,n,o=a[0],t=[];for(let r=0;r<o.length;r+=1)t[r]=en(Jt(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&1){o=r[0];let l;for(l=0;l<o.length;l+=1){const f=Jt(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=en(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){$e(t,r),r&&h(e)}}}function ps(a){let e,n,o;var t=a[1].component;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&U(e.$$.fragment),n=q()},l(r){e&&G(e.$$.fragment,r),n=Y(r)},m(r,s){e&&N(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=r[1].component)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{V(l,1)}),re()}t?(e=ie(t,i()),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){e&&V(e,r),r&&h(n)}}}function tn(a){let e,n;return e=new Me({props:{$$slots:{default:[ps]},$$scope:{ctx:a}}}),{c(){U(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){N(e,o,t),n=!0},p(o,t){const i={};t&64&&(i.$$scope={dirty:t,ctx:o}),e.$set(i)},i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){V(e,o)}}}function ms(a){let e,n,o,t;e=new rn({props:{$$slots:{default:[us]},$$scope:{ctx:a}}});let i=a[0],r=[];for(let l=0;l<i.length;l+=1)r[l]=tn(Qt(a,i,l));const s=l=>k(r[l],1,1,()=>{r[l]=null});return{c(){U(e.$$.fragment),n=q();for(let l=0;l<r.length;l+=1)r[l].c();o=K()},l(l){G(e.$$.fragment,l),n=Y(l);for(let f=0;f<r.length;f+=1)r[f].l(l);o=K()},m(l,f){N(e,l,f),A(l,n,f);for(let c=0;c<r.length;c+=1)r[c].m(l,f);A(l,o,f),t=!0},p(l,f){const c={};if(f&64&&(c.$$scope={dirty:f,ctx:l}),e.$set(c),f&1){i=l[0];let u;for(u=0;u<i.length;u+=1){const p=Qt(l,i,u);r[u]?(r[u].p(p,f),_(r[u],1)):(r[u]=tn(p),r[u].c(),_(r[u],1),r[u].m(o.parentNode,o))}for(oe(),u=i.length;u<r.length;u+=1)s(u);re()}},i(l){if(!t){_(e.$$.fragment,l);for(let f=0;f<i.length;f+=1)_(r[f]);t=!0}},o(l){k(e.$$.fragment,l),r=r.filter(Boolean);for(let f=0;f<r.length;f+=1)k(r[f]);t=!1},d(l){V(e,l),l&&h(n),$e(r,l),l&&h(o)}}}function ds(a){let e,n,o,t,i,r,s,l,f,c,u,p,m;return p=new on({props:{$$slots:{default:[ms]},$$scope:{ctx:a}}}),{c(){e=z("p"),n=R(`Here is a list of the various iterations I have made before I got the final version of this
    project.`),o=q(),t=z("div"),i=z("p"),r=R(`Some of the previous versions have a bug and the code is not cleaned up properly when the
        page unload. Which make that when navigating between different versions it is possible to
        end up in a state where several simulation are running in parallel.`),s=q(),l=z("p"),f=R(`To avoid this kind of issues make sure the refresh the page each time you select a new
        version`),c=q(),u=z("div"),U(p.$$.fragment),this.h()},l(d){e=B(d,"P",{});var x=T(e);n=P(x,`Here is a list of the various iterations I have made before I got the final version of this
    project.`),x.forEach(h),o=Y(d),t=B(d,"DIV",{class:!0});var C=T(t);i=B(C,"P",{});var E=T(i);r=P(E,`Some of the previous versions have a bug and the code is not cleaned up properly when the
        page unload. Which make that when navigating between different versions it is possible to
        end up in a state where several simulation are running in parallel.`),E.forEach(h),s=Y(C),l=B(C,"P",{});var S=T(l);f=P(S,`To avoid this kind of issues make sure the refresh the page each time you select a new
        version`),S.forEach(h),C.forEach(h),c=Y(d),u=B(d,"DIV",{});var M=T(u);G(p.$$.fragment,M),M.forEach(h),this.h()},h(){y(t,"class","warning")},m(d,x){A(d,e,x),w(e,n),A(d,o,x),A(d,t,x),w(t,i),w(i,r),w(t,s),w(t,l),w(l,f),A(d,c,x),A(d,u,x),N(p,u,null),m=!0},p(d,[x]){const C={};x&64&&(C.$$scope={dirty:x,ctx:d}),p.$set(C)},i(d){m||(_(p.$$.fragment,d),m=!0)},o(d){k(p.$$.fragment,d),m=!1},d(d){d&&h(e),d&&h(o),d&&h(t),d&&h(c),d&&h(u),V(p)}}}function hs(a){return[[{title:"Auto visualizer",component:fs},{title:"V7",component:ml},{title:"Parameters map",component:rt},{title:"V6",component:wa},{title:"V5",component:ua},{title:"V4",component:ia},{title:"V3",component:na},{title:"V2",component:Yi},{title:"V1",component:Pi}]]}class nn extends Q{constructor(e){super(),J(this,e,hs,ds,ee,{})}}function vs(a){let e;return{c(){e=R("About")},l(n){e=P(n,"About")},m(n,o){A(n,e,o)},d(n){n&&h(e)}}}function gs(a){let e;return{c(){e=R("Manual")},l(n){e=P(n,"Manual")},m(n,o){A(n,e,o)},d(n){n&&h(e)}}}function xs(a){let e;return{c(){e=R("Auto")},l(n){e=P(n,"Auto")},m(n,o){A(n,e,o)},d(n){n&&h(e)}}}function _s(a){let e;return{c(){e=R("Parameters map")},l(n){e=P(n,"Parameters map")},m(n,o){A(n,e,o)},d(n){n&&h(e)}}}function bs(a){let e;return{c(){e=R("Previous versions")},l(n){e=P(n,"Previous versions")},m(n,o){A(n,e,o)},d(n){n&&h(e)}}}function ws(a){let e,n,o,t,i,r,s,l,f,c;return e=new Ue({props:{$$slots:{default:[vs]},$$scope:{ctx:a}}}),o=new Ue({props:{$$slots:{default:[gs]},$$scope:{ctx:a}}}),i=new Ue({props:{$$slots:{default:[xs]},$$scope:{ctx:a}}}),s=new Ue({props:{$$slots:{default:[_s]},$$scope:{ctx:a}}}),f=new Ue({props:{$$slots:{default:[bs]},$$scope:{ctx:a}}}),{c(){U(e.$$.fragment),n=q(),U(o.$$.fragment),t=q(),U(i.$$.fragment),r=q(),U(s.$$.fragment),l=q(),U(f.$$.fragment)},l(u){G(e.$$.fragment,u),n=Y(u),G(o.$$.fragment,u),t=Y(u),G(i.$$.fragment,u),r=Y(u),G(s.$$.fragment,u),l=Y(u),G(f.$$.fragment,u)},m(u,p){N(e,u,p),A(u,n,p),N(o,u,p),A(u,t,p),N(i,u,p),A(u,r,p),N(s,u,p),A(u,l,p),N(f,u,p),c=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),e.$set(m);const d={};p&1&&(d.$$scope={dirty:p,ctx:u}),o.$set(d);const x={};p&1&&(x.$$scope={dirty:p,ctx:u}),i.$set(x);const C={};p&1&&(C.$$scope={dirty:p,ctx:u}),s.$set(C);const E={};p&1&&(E.$$scope={dirty:p,ctx:u}),f.$set(E)},i(u){c||(_(e.$$.fragment,u),_(o.$$.fragment,u),_(i.$$.fragment,u),_(s.$$.fragment,u),_(f.$$.fragment,u),c=!0)},o(u){k(e.$$.fragment,u),k(o.$$.fragment,u),k(i.$$.fragment,u),k(s.$$.fragment,u),k(f.$$.fragment,u),c=!1},d(u){V(e,u),u&&h(n),V(o,u),u&&h(t),V(i,u),u&&h(r),V(s,u),u&&h(l),V(f,u)}}}function $s(a){let e,n,o;var t=zt;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&U(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&N(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=zt)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{V(l,1)}),re()}t?(e=ie(t,i()),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&V(e,r)}}}function ks(a){let e,n,o;var t=Pt;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&U(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&N(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=Pt)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{V(l,1)}),re()}t?(e=ie(t,i()),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&V(e,r)}}}function ys(a){let e,n,o;var t=Ct;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&U(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&N(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=Ct)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{V(l,1)}),re()}t?(e=ie(t,i()),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&V(e,r)}}}function Ss(a){let e,n,o;var t=rt;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&U(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&N(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=rt)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{V(l,1)}),re()}t?(e=ie(t,i()),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&V(e,r)}}}function Es(a){let e,n,o;var t=nn;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&U(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&N(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=nn)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{V(l,1)}),re()}t?(e=ie(t,i()),U(e.$$.fragment),_(e.$$.fragment,1),N(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&V(e,r)}}}function As(a){let e,n,o,t,i,r,s,l,f,c,u,p;return e=new rn({props:{$$slots:{default:[ws]},$$scope:{ctx:a}}}),o=new Me({props:{$$slots:{default:[$s]},$$scope:{ctx:a}}}),i=new Me({props:{$$slots:{default:[ks]},$$scope:{ctx:a}}}),s=new Me({props:{$$slots:{default:[ys]},$$scope:{ctx:a}}}),f=new Me({props:{$$slots:{default:[Ss]},$$scope:{ctx:a}}}),u=new Me({props:{$$slots:{default:[Es]},$$scope:{ctx:a}}}),{c(){U(e.$$.fragment),n=q(),U(o.$$.fragment),t=q(),U(i.$$.fragment),r=q(),U(s.$$.fragment),l=q(),U(f.$$.fragment),c=q(),U(u.$$.fragment)},l(m){G(e.$$.fragment,m),n=Y(m),G(o.$$.fragment,m),t=Y(m),G(i.$$.fragment,m),r=Y(m),G(s.$$.fragment,m),l=Y(m),G(f.$$.fragment,m),c=Y(m),G(u.$$.fragment,m)},m(m,d){N(e,m,d),A(m,n,d),N(o,m,d),A(m,t,d),N(i,m,d),A(m,r,d),N(s,m,d),A(m,l,d),N(f,m,d),A(m,c,d),N(u,m,d),p=!0},p(m,d){const x={};d&1&&(x.$$scope={dirty:d,ctx:m}),e.$set(x);const C={};d&1&&(C.$$scope={dirty:d,ctx:m}),o.$set(C);const E={};d&1&&(E.$$scope={dirty:d,ctx:m}),i.$set(E);const S={};d&1&&(S.$$scope={dirty:d,ctx:m}),s.$set(S);const M={};d&1&&(M.$$scope={dirty:d,ctx:m}),f.$set(M);const v={};d&1&&(v.$$scope={dirty:d,ctx:m}),u.$set(v)},i(m){p||(_(e.$$.fragment,m),_(o.$$.fragment,m),_(i.$$.fragment,m),_(s.$$.fragment,m),_(f.$$.fragment,m),_(u.$$.fragment,m),p=!0)},o(m){k(e.$$.fragment,m),k(o.$$.fragment,m),k(i.$$.fragment,m),k(s.$$.fragment,m),k(f.$$.fragment,m),k(u.$$.fragment,m),p=!1},d(m){V(e,m),m&&h(n),V(o,m),m&&h(t),V(i,m),m&&h(r),V(s,m),m&&h(l),V(f,m),m&&h(c),V(u,m)}}}function Ds(a){let e,n,o;return n=new on({props:{$$slots:{default:[As]},$$scope:{ctx:a}}}),{c(){e=z("div"),U(n.$$.fragment)},l(t){e=B(t,"DIV",{});var i=T(e);G(n.$$.fragment,i),i.forEach(h)},m(t,i){A(t,e,i),N(n,e,null),o=!0},p(t,[i]){const r={};i&1&&(r.$$scope={dirty:i,ctx:t}),n.$set(r)},i(t){o||(_(n.$$.fragment,t),o=!0)},o(t){k(n.$$.fragment,t),o=!1},d(t){t&&h(e),V(n)}}}class zs extends Q{constructor(e){super(),J(this,e,null,Ds,ee,{})}}function Bs(a){let e,n;return e=new zs({}),{c(){U(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){N(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){V(e,o)}}}class Cs extends Q{constructor(e){super(),J(this,e,null,Bs,ee,{})}}function Ts(a){let e,n;return e=new Cs({}),{c(){U(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){N(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){V(e,o)}}}class Zs extends Q{constructor(e){super(),J(this,e,null,Ts,ee,{})}}export{Zs as default};
