import{o as $e,S as Q,i as J,s as ee,e as K,b as A,g as oe,t as k,d as re,f as _,h,X as ct,Y as ze,Z as yn,L as ke,w as N,x as G,y as U,_ as qe,$ as Ye,z as O,v as ie,a as q,c as Y,q as R,r as P,u as pe,B as ne,V as Sn,C as se,k as B,l as z,m as T,n as y,E as fe,F as ce,G as ue,a0 as et,D as w,a1 as En,a2 as An,a3 as Ge,T as Dn,a4 as Bn,U as Ie,K as Z,Q as ye,O as Se,a5 as we,P as Ae,M as Be,a6 as je,I as it,J as Ve,N as at}from"../../../chunks/index-4570ff94.js";import{T as on,a as rn,b as Me,c as Ne}from"../../../chunks/TabPanel-171143ae.js";import{b as Ze}from"../../../chunks/paths-b4419565.js";import{_ as Te}from"../../../chunks/preload-helper-41c905a7.js";import{R as Le}from"../../../chunks/regl-89b00fbf.js";function zn(){const a=console.warn;console.warn=e=>{e.includes("unknown prop")||e.includes("unexpected slot")||a(e)},$e(()=>{console.warn=a})}function ut(a,e,n){const o=a.slice();return o[18]=e[n],o}function pt(a,e,n){const o=a.slice();return o[18]=e[n],o}function mt(a,e,n){const o=a.slice();return o[10]=e[n],o}function dt(a,e,n){const o=a.slice();return o[13]=e[n],o[15]=n,o}function ht(a,e,n){const o=a.slice();return o[16]=e[n],o[15]=n,o}function vt(a,e,n){const o=a.slice();return o[7]=e[n],o}function Cn(a){let e,n,o,t;const i=[Rn,Ln,In],r=[];function s(l,f){return l[0]==="table"?0:l[0]==="list"?1:2}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,f){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function Tn(a){let e,n,o=a[1],t=[];for(let r=0;r<o.length;r+=1)t[r]=$t(vt(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&34){o=r[1];let l;for(l=0;l<o.length;l+=1){const f=vt(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=$t(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){ke(t,r),r&&h(e)}}}function In(a){let e,n,o;const t=[a[6]];var i=a[5][a[0]];function r(s){let l={$$slots:{default:[Mn]},$$scope:{ctx:s}};for(let f=0;f<t.length;f+=1)l=ze(l,t[f]);return{props:l}}return i&&(e=ie(i,r(a))),{c(){e&&N(e.$$.fragment),n=K()},l(s){e&&G(e.$$.fragment,s),n=K()},m(s,l){e&&U(e,s,l),A(s,n,l),o=!0},p(s,l){const f=l&64?qe(t,[Ye(s[6])]):{};if(l&8388706&&(f.$$scope={dirty:l,ctx:s}),i!==(i=s[5][s[0]])){if(e){oe();const c=e;k(c.$$.fragment,1,0,()=>{O(c,1)}),re()}i?(e=ie(i,r(s)),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}else i&&e.$set(f)},i(s){o||(e&&_(e.$$.fragment,s),o=!0)},o(s){e&&k(e.$$.fragment,s),o=!1},d(s){s&&h(n),e&&O(e,s)}}}function Ln(a){let e,n,o,t;const i=[Un,Nn],r=[];function s(l,f){return l[4]?0:1}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,f){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function Rn(a){let e,n,o;var t=a[5].table;function i(r){return{props:{$$slots:{default:[Zn]},$$scope:{ctx:r}}}}return t&&(e=ie(t,i(a))),{c(){e&&N(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&U(e,r,s),A(r,n,s),o=!0},p(r,s){const l={};if(s&8388716&&(l.$$scope={dirty:s,ctx:r}),t!==(t=r[5].table)){if(e){oe();const f=e;k(f.$$.fragment,1,0,()=>{O(f,1)}),re()}t?(e=ie(t,i(r)),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}else t&&e.$set(l)},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&O(e,r)}}}function Pn(a){let e=a[6].raw+"",n;return{c(){n=R(e)},l(o){n=P(o,e)},m(o,t){A(o,n,t)},p(o,t){t&64&&e!==(e=o[6].raw+"")&&pe(n,e)},i:ne,o:ne,d(o){o&&h(n)}}}function Fn(a){let e,n;return e=new Re({props:{tokens:a[1],renderers:a[5]}}),{c(){N(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){U(e,o,t),n=!0},p(o,t){const i={};t&2&&(i.tokens=o[1]),t&32&&(i.renderers=o[5]),e.$set(i)},i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){O(e,o)}}}function Mn(a){let e,n,o,t;const i=[Fn,Pn],r=[];function s(l,f){return l[1]?0:1}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,f){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function Nn(a){let e,n,o;const t=[{ordered:a[4]},a[6]];var i=a[5].list;function r(s){let l={$$slots:{default:[Vn]},$$scope:{ctx:s}};for(let f=0;f<t.length;f+=1)l=ze(l,t[f]);return{props:l}}return i&&(e=ie(i,r(a))),{c(){e&&N(e.$$.fragment),n=K()},l(s){e&&G(e.$$.fragment,s),n=K()},m(s,l){e&&U(e,s,l),A(s,n,l),o=!0},p(s,l){const f=l&80?qe(t,[l&16&&{ordered:s[4]},l&64&&Ye(s[6])]):{};if(l&8388704&&(f.$$scope={dirty:l,ctx:s}),i!==(i=s[5].list)){if(e){oe();const c=e;k(c.$$.fragment,1,0,()=>{O(c,1)}),re()}i?(e=ie(i,r(s)),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}else i&&e.$set(f)},i(s){o||(e&&_(e.$$.fragment,s),o=!0)},o(s){e&&k(e.$$.fragment,s),o=!1},d(s){s&&h(n),e&&O(e,s)}}}function Un(a){let e,n,o;const t=[{ordered:a[4]},a[6]];var i=a[5].list;function r(s){let l={$$slots:{default:[Kn]},$$scope:{ctx:s}};for(let f=0;f<t.length;f+=1)l=ze(l,t[f]);return{props:l}}return i&&(e=ie(i,r(a))),{c(){e&&N(e.$$.fragment),n=K()},l(s){e&&G(e.$$.fragment,s),n=K()},m(s,l){e&&U(e,s,l),A(s,n,l),o=!0},p(s,l){const f=l&80?qe(t,[l&16&&{ordered:s[4]},l&64&&Ye(s[6])]):{};if(l&8388704&&(f.$$scope={dirty:l,ctx:s}),i!==(i=s[5].list)){if(e){oe();const c=e;k(c.$$.fragment,1,0,()=>{O(c,1)}),re()}i?(e=ie(i,r(s)),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}else i&&e.$set(f)},i(s){o||(e&&_(e.$$.fragment,s),o=!0)},o(s){e&&k(e.$$.fragment,s),o=!1},d(s){s&&h(n),e&&O(e,s)}}}function On(a){let e,n,o;return e=new Re({props:{tokens:a[18].tokens,renderers:a[5]}}),{c(){N(e.$$.fragment),n=q()},l(t){G(e.$$.fragment,t),n=Y(t)},m(t,i){U(e,t,i),A(t,n,i),o=!0},p(t,i){const r={};i&64&&(r.tokens=t[18].tokens),i&32&&(r.renderers=t[5]),e.$set(r)},i(t){o||(_(e.$$.fragment,t),o=!0)},o(t){k(e.$$.fragment,t),o=!1},d(t){O(e,t),t&&h(n)}}}function gt(a){let e,n,o;const t=[a[18]];var i=a[5].unorderedlistitem||a[5].listitem;function r(s){let l={$$slots:{default:[On]},$$scope:{ctx:s}};for(let f=0;f<t.length;f+=1)l=ze(l,t[f]);return{props:l}}return i&&(e=ie(i,r(a))),{c(){e&&N(e.$$.fragment),n=K()},l(s){e&&G(e.$$.fragment,s),n=K()},m(s,l){e&&U(e,s,l),A(s,n,l),o=!0},p(s,l){const f=l&64?qe(t,[Ye(s[18])]):{};if(l&8388704&&(f.$$scope={dirty:l,ctx:s}),i!==(i=s[5].unorderedlistitem||s[5].listitem)){if(e){oe();const c=e;k(c.$$.fragment,1,0,()=>{O(c,1)}),re()}i?(e=ie(i,r(s)),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}else i&&e.$set(f)},i(s){o||(e&&_(e.$$.fragment,s),o=!0)},o(s){e&&k(e.$$.fragment,s),o=!1},d(s){s&&h(n),e&&O(e,s)}}}function Vn(a){let e,n,o=a[6].items,t=[];for(let r=0;r<o.length;r+=1)t[r]=gt(ut(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&96){o=r[6].items;let l;for(l=0;l<o.length;l+=1){const f=ut(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=gt(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){ke(t,r),r&&h(e)}}}function Hn(a){let e,n,o;return e=new Re({props:{tokens:a[18].tokens,renderers:a[5]}}),{c(){N(e.$$.fragment),n=q()},l(t){G(e.$$.fragment,t),n=Y(t)},m(t,i){U(e,t,i),A(t,n,i),o=!0},p(t,i){const r={};i&64&&(r.tokens=t[18].tokens),i&32&&(r.renderers=t[5]),e.$set(r)},i(t){o||(_(e.$$.fragment,t),o=!0)},o(t){k(e.$$.fragment,t),o=!1},d(t){O(e,t),t&&h(n)}}}function xt(a){let e,n,o;const t=[a[18]];var i=a[5].orderedlistitem||a[5].listitem;function r(s){let l={$$slots:{default:[Hn]},$$scope:{ctx:s}};for(let f=0;f<t.length;f+=1)l=ze(l,t[f]);return{props:l}}return i&&(e=ie(i,r(a))),{c(){e&&N(e.$$.fragment),n=K()},l(s){e&&G(e.$$.fragment,s),n=K()},m(s,l){e&&U(e,s,l),A(s,n,l),o=!0},p(s,l){const f=l&64?qe(t,[Ye(s[18])]):{};if(l&8388704&&(f.$$scope={dirty:l,ctx:s}),i!==(i=s[5].orderedlistitem||s[5].listitem)){if(e){oe();const c=e;k(c.$$.fragment,1,0,()=>{O(c,1)}),re()}i?(e=ie(i,r(s)),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}else i&&e.$set(f)},i(s){o||(e&&_(e.$$.fragment,s),o=!0)},o(s){e&&k(e.$$.fragment,s),o=!1},d(s){s&&h(n),e&&O(e,s)}}}function Kn(a){let e,n,o=a[6].items,t=[];for(let r=0;r<o.length;r+=1)t[r]=xt(pt(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&96){o=r[6].items;let l;for(l=0;l<o.length;l+=1){const f=pt(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=xt(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){ke(t,r),r&&h(e)}}}function qn(a){let e,n,o;return e=new Re({props:{tokens:a[16].tokens,renderers:a[5]}}),{c(){N(e.$$.fragment),n=q()},l(t){G(e.$$.fragment,t),n=Y(t)},m(t,i){U(e,t,i),A(t,n,i),o=!0},p(t,i){const r={};i&4&&(r.tokens=t[16].tokens),i&32&&(r.renderers=t[5]),e.$set(r)},i(t){o||(_(e.$$.fragment,t),o=!0)},o(t){k(e.$$.fragment,t),o=!1},d(t){O(e,t),t&&h(n)}}}function _t(a){let e,n,o;var t=a[5].tablecell;function i(r){return{props:{header:!0,align:r[6].align[r[15]]||"center",$$slots:{default:[qn]},$$scope:{ctx:r}}}}return t&&(e=ie(t,i(a))),{c(){e&&N(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&U(e,r,s),A(r,n,s),o=!0},p(r,s){const l={};if(s&64&&(l.align=r[6].align[r[15]]||"center"),s&8388644&&(l.$$scope={dirty:s,ctx:r}),t!==(t=r[5].tablecell)){if(e){oe();const f=e;k(f.$$.fragment,1,0,()=>{O(f,1)}),re()}t?(e=ie(t,i(r)),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}else t&&e.$set(l)},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&O(e,r)}}}function Yn(a){let e,n,o=a[2],t=[];for(let r=0;r<o.length;r+=1)t[r]=_t(ht(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&100){o=r[2];let l;for(l=0;l<o.length;l+=1){const f=ht(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=_t(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){ke(t,r),r&&h(e)}}}function Gn(a){let e,n,o;var t=a[5].tablerow;function i(r){return{props:{$$slots:{default:[Yn]},$$scope:{ctx:r}}}}return t&&(e=ie(t,i(a))),{c(){e&&N(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&U(e,r,s),A(r,n,s),o=!0},p(r,s){const l={};if(s&8388708&&(l.$$scope={dirty:s,ctx:r}),t!==(t=r[5].tablerow)){if(e){oe();const f=e;k(f.$$.fragment,1,0,()=>{O(f,1)}),re()}t?(e=ie(t,i(r)),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}else t&&e.$set(l)},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&O(e,r)}}}function Wn(a){let e,n;return e=new Re({props:{tokens:a[13].tokens,renderers:a[5]}}),{c(){N(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){U(e,o,t),n=!0},p(o,t){const i={};t&8&&(i.tokens=o[13].tokens),t&32&&(i.renderers=o[5]),e.$set(i)},i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){O(e,o)}}}function bt(a){let e,n,o;var t=a[5].tablecell;function i(r){return{props:{header:!1,align:r[6].align[r[15]]||"center",$$slots:{default:[Wn]},$$scope:{ctx:r}}}}return t&&(e=ie(t,i(a))),{c(){e&&N(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&U(e,r,s),A(r,n,s),o=!0},p(r,s){const l={};if(s&64&&(l.align=r[6].align[r[15]]||"center"),s&8388648&&(l.$$scope={dirty:s,ctx:r}),t!==(t=r[5].tablecell)){if(e){oe();const f=e;k(f.$$.fragment,1,0,()=>{O(f,1)}),re()}t?(e=ie(t,i(r)),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}else t&&e.$set(l)},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&O(e,r)}}}function Xn(a){let e,n,o=a[10],t=[];for(let r=0;r<o.length;r+=1)t[r]=bt(dt(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=q()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=Y(r)},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&104){o=r[10];let l;for(l=0;l<o.length;l+=1){const f=dt(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=bt(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){ke(t,r),r&&h(e)}}}function wt(a){let e,n,o;var t=a[5].tablerow;function i(r){return{props:{$$slots:{default:[Xn]},$$scope:{ctx:r}}}}return t&&(e=ie(t,i(a))),{c(){e&&N(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&U(e,r,s),A(r,n,s),o=!0},p(r,s){const l={};if(s&8388712&&(l.$$scope={dirty:s,ctx:r}),t!==(t=r[5].tablerow)){if(e){oe();const f=e;k(f.$$.fragment,1,0,()=>{O(f,1)}),re()}t?(e=ie(t,i(r)),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}else t&&e.$set(l)},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&O(e,r)}}}function jn(a){let e,n,o=a[3],t=[];for(let r=0;r<o.length;r+=1)t[r]=wt(mt(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&104){o=r[3];let l;for(l=0;l<o.length;l+=1){const f=mt(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=wt(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){ke(t,r),r&&h(e)}}}function Zn(a){let e,n,o,t,i;var r=a[5].tablehead;function s(c){return{props:{$$slots:{default:[Gn]},$$scope:{ctx:c}}}}r&&(e=ie(r,s(a)));var l=a[5].tablebody;function f(c){return{props:{$$slots:{default:[jn]},$$scope:{ctx:c}}}}return l&&(o=ie(l,f(a))),{c(){e&&N(e.$$.fragment),n=q(),o&&N(o.$$.fragment),t=K()},l(c){e&&G(e.$$.fragment,c),n=Y(c),o&&G(o.$$.fragment,c),t=K()},m(c,u){e&&U(e,c,u),A(c,n,u),o&&U(o,c,u),A(c,t,u),i=!0},p(c,u){const p={};if(u&8388708&&(p.$$scope={dirty:u,ctx:c}),r!==(r=c[5].tablehead)){if(e){oe();const d=e;k(d.$$.fragment,1,0,()=>{O(d,1)}),re()}r?(e=ie(r,s(c)),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}else r&&e.$set(p);const m={};if(u&8388712&&(m.$$scope={dirty:u,ctx:c}),l!==(l=c[5].tablebody)){if(o){oe();const d=o;k(d.$$.fragment,1,0,()=>{O(d,1)}),re()}l?(o=ie(l,f(c)),N(o.$$.fragment),_(o.$$.fragment,1),U(o,t.parentNode,t)):o=null}else l&&o.$set(m)},i(c){i||(e&&_(e.$$.fragment,c),o&&_(o.$$.fragment,c),i=!0)},o(c){e&&k(e.$$.fragment,c),o&&k(o.$$.fragment,c),i=!1},d(c){e&&O(e,c),c&&h(n),c&&h(t),o&&O(o,c)}}}function $t(a){let e,n;const o=[a[7],{renderers:a[5]}];let t={};for(let i=0;i<o.length;i+=1)t=ze(t,o[i]);return e=new Re({props:t}),{c(){N(e.$$.fragment)},l(i){G(e.$$.fragment,i)},m(i,r){U(e,i,r),n=!0},p(i,r){const s=r&34?qe(o,[r&2&&Ye(i[7]),r&32&&{renderers:i[5]}]):{};e.$set(s)},i(i){n||(_(e.$$.fragment,i),n=!0)},o(i){k(e.$$.fragment,i),n=!1},d(i){O(e,i)}}}function Qn(a){let e,n,o,t;const i=[Tn,Cn],r=[];function s(l,f){return l[0]?l[5][l[0]]?1:-1:0}return~(e=s(a))&&(n=r[e]=i[e](a)),{c(){n&&n.c(),o=K()},l(l){n&&n.l(l),o=K()},m(l,f){~e&&r[e].m(l,f),A(l,o,f),t=!0},p(l,[f]){let c=e;e=s(l),e===c?~e&&r[e].p(l,f):(n&&(oe(),k(r[c],1,1,()=>{r[c]=null}),re()),~e?(n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o)):n=null)},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){~e&&r[e].d(l),l&&h(o)}}}function Jn(a,e,n){const o=["type","tokens","header","rows","ordered","renderers"];let t=ct(e,o),{type:i=void 0}=e,{tokens:r=void 0}=e,{header:s=void 0}=e,{rows:l=void 0}=e,{ordered:f=!1}=e,{renderers:c}=e;return zn(),a.$$set=u=>{e=ze(ze({},e),yn(u)),n(6,t=ct(e,o)),"type"in u&&n(0,i=u.type),"tokens"in u&&n(1,r=u.tokens),"header"in u&&n(2,s=u.header),"rows"in u&&n(3,l=u.rows),"ordered"in u&&n(4,f=u.ordered),"renderers"in u&&n(5,c=u.renderers)},[i,r,s,l,f,c,t]}let Re=class extends Q{constructor(e){super(),J(this,e,Jn,Qn,ee,{type:0,tokens:1,header:2,rows:3,ordered:4,renderers:5})}};function an(){return{async:!1,baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,hooks:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1}}let Pe=an();function e0(a){Pe=a}const ln=/[&<>"']/,t0=new RegExp(ln.source,"g"),sn=/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,n0=new RegExp(sn.source,"g"),o0={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},kt=a=>o0[a];function be(a,e){if(e){if(ln.test(a))return a.replace(t0,kt)}else if(sn.test(a))return a.replace(n0,kt);return a}const r0=/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;function fn(a){return a.replace(r0,(e,n)=>(n=n.toLowerCase(),n==="colon"?":":n.charAt(0)==="#"?n.charAt(1)==="x"?String.fromCharCode(parseInt(n.substring(2),16)):String.fromCharCode(+n.substring(1)):""))}const i0=/(^|[^\[])\^/g;function le(a,e){a=typeof a=="string"?a:a.source,e=e||"";const n={replace:(o,t)=>(t=t.source||t,t=t.replace(i0,"$1"),a=a.replace(o,t),n),getRegex:()=>new RegExp(a,e)};return n}const a0=/[^\w:]/g,l0=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;function yt(a,e,n){if(a){let o;try{o=decodeURIComponent(fn(n)).replace(a0,"").toLowerCase()}catch{return null}if(o.indexOf("javascript:")===0||o.indexOf("vbscript:")===0||o.indexOf("data:")===0)return null}e&&!l0.test(n)&&(n=u0(e,n));try{n=encodeURI(n).replace(/%25/g,"%")}catch{return null}return n}const Qe={},s0=/^[^:]+:\/*[^/]*$/,f0=/^([^:]+:)[\s\S]*$/,c0=/^([^:]+:\/*[^/]*)[\s\S]*$/;function u0(a,e){Qe[" "+a]||(s0.test(a)?Qe[" "+a]=a+"/":Qe[" "+a]=Je(a,"/",!0)),a=Qe[" "+a];const n=a.indexOf(":")===-1;return e.substring(0,2)==="//"?n?e:a.replace(f0,"$1")+e:e.charAt(0)==="/"?n?e:a.replace(c0,"$1")+e:a+e}const tt={exec:function(){}};function St(a,e){const n=a.replace(/\|/g,(i,r,s)=>{let l=!1,f=r;for(;--f>=0&&s[f]==="\\";)l=!l;return l?"|":" |"}),o=n.split(/ \|/);let t=0;if(o[0].trim()||o.shift(),o.length>0&&!o[o.length-1].trim()&&o.pop(),o.length>e)o.splice(e);else for(;o.length<e;)o.push("");for(;t<o.length;t++)o[t]=o[t].trim().replace(/\\\|/g,"|");return o}function Je(a,e,n){const o=a.length;if(o===0)return"";let t=0;for(;t<o;){const i=a.charAt(o-t-1);if(i===e&&!n)t++;else if(i!==e&&n)t++;else break}return a.slice(0,o-t)}function p0(a,e){if(a.indexOf(e[1])===-1)return-1;const n=a.length;let o=0,t=0;for(;t<n;t++)if(a[t]==="\\")t++;else if(a[t]===e[0])o++;else if(a[t]===e[1]&&(o--,o<0))return t;return-1}function m0(a){a&&a.sanitize&&!a.silent&&console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options")}function Et(a,e){if(e<1)return"";let n="";for(;e>1;)e&1&&(n+=a),e>>=1,a+=a;return n+a}function At(a,e,n,o){const t=e.href,i=e.title?be(e.title):null,r=a[1].replace(/\\([\[\]])/g,"$1");if(a[0].charAt(0)!=="!"){o.state.inLink=!0;const s={type:"link",raw:n,href:t,title:i,text:r,tokens:o.inlineTokens(r)};return o.state.inLink=!1,s}return{type:"image",raw:n,href:t,title:i,text:be(r)}}function d0(a,e){const n=a.match(/^(\s+)(?:```)/);if(n===null)return e;const o=n[1];return e.split(`
`).map(t=>{const i=t.match(/^\s+/);if(i===null)return t;const[r]=i;return r.length>=o.length?t.slice(o.length):t}).join(`
`)}class lt{constructor(e){this.options=e||Pe}space(e){const n=this.rules.block.newline.exec(e);if(n&&n[0].length>0)return{type:"space",raw:n[0]}}code(e){const n=this.rules.block.code.exec(e);if(n){const o=n[0].replace(/^ {1,4}/gm,"");return{type:"code",raw:n[0],codeBlockStyle:"indented",text:this.options.pedantic?o:Je(o,`
`)}}}fences(e){const n=this.rules.block.fences.exec(e);if(n){const o=n[0],t=d0(o,n[3]||"");return{type:"code",raw:o,lang:n[2]?n[2].trim().replace(this.rules.inline._escapes,"$1"):n[2],text:t}}}heading(e){const n=this.rules.block.heading.exec(e);if(n){let o=n[2].trim();if(/#$/.test(o)){const t=Je(o,"#");(this.options.pedantic||!t||/ $/.test(t))&&(o=t.trim())}return{type:"heading",raw:n[0],depth:n[1].length,text:o,tokens:this.lexer.inline(o)}}}hr(e){const n=this.rules.block.hr.exec(e);if(n)return{type:"hr",raw:n[0]}}blockquote(e){const n=this.rules.block.blockquote.exec(e);if(n){const o=n[0].replace(/^ *>[ \t]?/gm,""),t=this.lexer.state.top;this.lexer.state.top=!0;const i=this.lexer.blockTokens(o);return this.lexer.state.top=t,{type:"blockquote",raw:n[0],tokens:i,text:o}}}list(e){let n=this.rules.block.list.exec(e);if(n){let o,t,i,r,s,l,f,c,u,p,m,d,g=n[1].trim();const C=g.length>1,E={type:"list",raw:"",ordered:C,start:C?+g.slice(0,-1):"",loose:!1,items:[]};g=C?`\\d{1,9}\\${g.slice(-1)}`:`\\${g}`,this.options.pedantic&&(g=C?g:"[*+-]");const S=new RegExp(`^( {0,3}${g})((?:[	 ][^\\n]*)?(?:\\n|$))`);for(;e&&(d=!1,!(!(n=S.exec(e))||this.rules.block.hr.test(e)));){if(o=n[0],e=e.substring(o.length),c=n[2].split(`
`,1)[0].replace(/^\t+/,v=>" ".repeat(3*v.length)),u=e.split(`
`,1)[0],this.options.pedantic?(r=2,m=c.trimLeft()):(r=n[2].search(/[^ ]/),r=r>4?1:r,m=c.slice(r),r+=n[1].length),l=!1,!c&&/^ *$/.test(u)&&(o+=u+`
`,e=e.substring(u.length+1),d=!0),!d){const v=new RegExp(`^ {0,${Math.min(3,r-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),x=new RegExp(`^ {0,${Math.min(3,r-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),$=new RegExp(`^ {0,${Math.min(3,r-1)}}(?:\`\`\`|~~~)`),L=new RegExp(`^ {0,${Math.min(3,r-1)}}#`);for(;e&&(p=e.split(`
`,1)[0],u=p,this.options.pedantic&&(u=u.replace(/^ {1,4}(?=( {4})*[^ ])/g,"  ")),!($.test(u)||L.test(u)||v.test(u)||x.test(e)));){if(u.search(/[^ ]/)>=r||!u.trim())m+=`
`+u.slice(r);else{if(l||c.search(/[^ ]/)>=4||$.test(c)||L.test(c)||x.test(c))break;m+=`
`+u}!l&&!u.trim()&&(l=!0),o+=p+`
`,e=e.substring(p.length+1),c=u.slice(r)}}E.loose||(f?E.loose=!0:/\n *\n *$/.test(o)&&(f=!0)),this.options.gfm&&(t=/^\[[ xX]\] /.exec(m),t&&(i=t[0]!=="[ ] ",m=m.replace(/^\[[ xX]\] +/,""))),E.items.push({type:"list_item",raw:o,task:!!t,checked:i,loose:!1,text:m}),E.raw+=o}E.items[E.items.length-1].raw=o.trimRight(),E.items[E.items.length-1].text=m.trimRight(),E.raw=E.raw.trimRight();const M=E.items.length;for(s=0;s<M;s++)if(this.lexer.state.top=!1,E.items[s].tokens=this.lexer.blockTokens(E.items[s].text,[]),!E.loose){const v=E.items[s].tokens.filter($=>$.type==="space"),x=v.length>0&&v.some($=>/\n.*\n/.test($.raw));E.loose=x}if(E.loose)for(s=0;s<M;s++)E.items[s].loose=!0;return E}}html(e){const n=this.rules.block.html.exec(e);if(n){const o={type:"html",raw:n[0],pre:!this.options.sanitizer&&(n[1]==="pre"||n[1]==="script"||n[1]==="style"),text:n[0]};if(this.options.sanitize){const t=this.options.sanitizer?this.options.sanitizer(n[0]):be(n[0]);o.type="paragraph",o.text=t,o.tokens=this.lexer.inline(t)}return o}}def(e){const n=this.rules.block.def.exec(e);if(n){const o=n[1].toLowerCase().replace(/\s+/g," "),t=n[2]?n[2].replace(/^<(.*)>$/,"$1").replace(this.rules.inline._escapes,"$1"):"",i=n[3]?n[3].substring(1,n[3].length-1).replace(this.rules.inline._escapes,"$1"):n[3];return{type:"def",tag:o,raw:n[0],href:t,title:i}}}table(e){const n=this.rules.block.table.exec(e);if(n){const o={type:"table",header:St(n[1]).map(t=>({text:t})),align:n[2].replace(/^ *|\| *$/g,"").split(/ *\| */),rows:n[3]&&n[3].trim()?n[3].replace(/\n[ \t]*$/,"").split(`
`):[]};if(o.header.length===o.align.length){o.raw=n[0];let t=o.align.length,i,r,s,l;for(i=0;i<t;i++)/^ *-+: *$/.test(o.align[i])?o.align[i]="right":/^ *:-+: *$/.test(o.align[i])?o.align[i]="center":/^ *:-+ *$/.test(o.align[i])?o.align[i]="left":o.align[i]=null;for(t=o.rows.length,i=0;i<t;i++)o.rows[i]=St(o.rows[i],o.header.length).map(f=>({text:f}));for(t=o.header.length,r=0;r<t;r++)o.header[r].tokens=this.lexer.inline(o.header[r].text);for(t=o.rows.length,r=0;r<t;r++)for(l=o.rows[r],s=0;s<l.length;s++)l[s].tokens=this.lexer.inline(l[s].text);return o}}}lheading(e){const n=this.rules.block.lheading.exec(e);if(n)return{type:"heading",raw:n[0],depth:n[2].charAt(0)==="="?1:2,text:n[1],tokens:this.lexer.inline(n[1])}}paragraph(e){const n=this.rules.block.paragraph.exec(e);if(n){const o=n[1].charAt(n[1].length-1)===`
`?n[1].slice(0,-1):n[1];return{type:"paragraph",raw:n[0],text:o,tokens:this.lexer.inline(o)}}}text(e){const n=this.rules.block.text.exec(e);if(n)return{type:"text",raw:n[0],text:n[0],tokens:this.lexer.inline(n[0])}}escape(e){const n=this.rules.inline.escape.exec(e);if(n)return{type:"escape",raw:n[0],text:be(n[1])}}tag(e){const n=this.rules.inline.tag.exec(e);if(n)return!this.lexer.state.inLink&&/^<a /i.test(n[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&/^<\/a>/i.test(n[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(n[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(n[0])&&(this.lexer.state.inRawBlock=!1),{type:this.options.sanitize?"text":"html",raw:n[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,text:this.options.sanitize?this.options.sanitizer?this.options.sanitizer(n[0]):be(n[0]):n[0]}}link(e){const n=this.rules.inline.link.exec(e);if(n){const o=n[2].trim();if(!this.options.pedantic&&/^</.test(o)){if(!/>$/.test(o))return;const r=Je(o.slice(0,-1),"\\");if((o.length-r.length)%2===0)return}else{const r=p0(n[2],"()");if(r>-1){const l=(n[0].indexOf("!")===0?5:4)+n[1].length+r;n[2]=n[2].substring(0,r),n[0]=n[0].substring(0,l).trim(),n[3]=""}}let t=n[2],i="";if(this.options.pedantic){const r=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(t);r&&(t=r[1],i=r[3])}else i=n[3]?n[3].slice(1,-1):"";return t=t.trim(),/^</.test(t)&&(this.options.pedantic&&!/>$/.test(o)?t=t.slice(1):t=t.slice(1,-1)),At(n,{href:t&&t.replace(this.rules.inline._escapes,"$1"),title:i&&i.replace(this.rules.inline._escapes,"$1")},n[0],this.lexer)}}reflink(e,n){let o;if((o=this.rules.inline.reflink.exec(e))||(o=this.rules.inline.nolink.exec(e))){let t=(o[2]||o[1]).replace(/\s+/g," ");if(t=n[t.toLowerCase()],!t){const i=o[0].charAt(0);return{type:"text",raw:i,text:i}}return At(o,t,o[0],this.lexer)}}emStrong(e,n,o=""){let t=this.rules.inline.emStrong.lDelim.exec(e);if(!t||t[3]&&o.match(/[\p{L}\p{N}]/u))return;const i=t[1]||t[2]||"";if(!i||i&&(o===""||this.rules.inline.punctuation.exec(o))){const r=t[0].length-1;let s,l,f=r,c=0;const u=t[0][0]==="*"?this.rules.inline.emStrong.rDelimAst:this.rules.inline.emStrong.rDelimUnd;for(u.lastIndex=0,n=n.slice(-1*e.length+r);(t=u.exec(n))!=null;){if(s=t[1]||t[2]||t[3]||t[4]||t[5]||t[6],!s)continue;if(l=s.length,t[3]||t[4]){f+=l;continue}else if((t[5]||t[6])&&r%3&&!((r+l)%3)){c+=l;continue}if(f-=l,f>0)continue;l=Math.min(l,l+f+c);const p=e.slice(0,r+t.index+(t[0].length-s.length)+l);if(Math.min(r,l)%2){const d=p.slice(1,-1);return{type:"em",raw:p,text:d,tokens:this.lexer.inlineTokens(d)}}const m=p.slice(2,-2);return{type:"strong",raw:p,text:m,tokens:this.lexer.inlineTokens(m)}}}}codespan(e){const n=this.rules.inline.code.exec(e);if(n){let o=n[2].replace(/\n/g," ");const t=/[^ ]/.test(o),i=/^ /.test(o)&&/ $/.test(o);return t&&i&&(o=o.substring(1,o.length-1)),o=be(o,!0),{type:"codespan",raw:n[0],text:o}}}br(e){const n=this.rules.inline.br.exec(e);if(n)return{type:"br",raw:n[0]}}del(e){const n=this.rules.inline.del.exec(e);if(n)return{type:"del",raw:n[0],text:n[2],tokens:this.lexer.inlineTokens(n[2])}}autolink(e,n){const o=this.rules.inline.autolink.exec(e);if(o){let t,i;return o[2]==="@"?(t=be(this.options.mangle?n(o[1]):o[1]),i="mailto:"+t):(t=be(o[1]),i=t),{type:"link",raw:o[0],text:t,href:i,tokens:[{type:"text",raw:t,text:t}]}}}url(e,n){let o;if(o=this.rules.inline.url.exec(e)){let t,i;if(o[2]==="@")t=be(this.options.mangle?n(o[0]):o[0]),i="mailto:"+t;else{let r;do r=o[0],o[0]=this.rules.inline._backpedal.exec(o[0])[0];while(r!==o[0]);t=be(o[0]),o[1]==="www."?i="http://"+o[0]:i=o[0]}return{type:"link",raw:o[0],text:t,href:i,tokens:[{type:"text",raw:t,text:t}]}}}inlineText(e,n){const o=this.rules.inline.text.exec(e);if(o){let t;return this.lexer.state.inRawBlock?t=this.options.sanitize?this.options.sanitizer?this.options.sanitizer(o[0]):be(o[0]):o[0]:t=be(this.options.smartypants?n(o[0]):o[0]),{type:"text",raw:o[0],text:t}}}}const W={newline:/^(?: *(?:\n|$))+/,code:/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,fences:/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,hr:/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,heading:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,html:"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",def:/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,table:tt,lheading:/^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,_paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,text:/^[^\n]+/};W._label=/(?!\s*\])(?:\\.|[^\[\]\\])+/;W._title=/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;W.def=le(W.def).replace("label",W._label).replace("title",W._title).getRegex();W.bullet=/(?:[*+-]|\d{1,9}[.)])/;W.listItemStart=le(/^( *)(bull) */).replace("bull",W.bullet).getRegex();W.list=le(W.list).replace(/bull/g,W.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+W.def.source+")").getRegex();W._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";W._comment=/<!--(?!-?>)[\s\S]*?(?:-->|$)/;W.html=le(W.html,"i").replace("comment",W._comment).replace("tag",W._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();W.paragraph=le(W._paragraph).replace("hr",W.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",W._tag).getRegex();W.blockquote=le(W.blockquote).replace("paragraph",W.paragraph).getRegex();W.normal={...W};W.gfm={...W.normal,table:"^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"};W.gfm.table=le(W.gfm.table).replace("hr",W.hr).replace("heading"," {0,3}#{1,6} ").replace("blockquote"," {0,3}>").replace("code"," {4}[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",W._tag).getRegex();W.gfm.paragraph=le(W._paragraph).replace("hr",W.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("table",W.gfm.table).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",W._tag).getRegex();W.pedantic={...W.normal,html:le(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",W._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:tt,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:le(W.normal._paragraph).replace("hr",W.hr).replace("heading",` *#{1,6} *[^
]`).replace("lheading",W.lheading).replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").getRegex()};const H={escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:tt,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(ref)\]/,nolink:/^!?\[(ref)\](?:\[\])?/,reflinkSearch:"reflink|nolink(?!\\()",emStrong:{lDelim:/^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,rDelimAst:/^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,rDelimUnd:/^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/},code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br:/^( {2,}|\\)\n(?!\s*$)/,del:tt,text:/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,punctuation:/^([\spunctuation])/};H._punctuation="!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";H.punctuation=le(H.punctuation).replace(/punctuation/g,H._punctuation).getRegex();H.blockSkip=/\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;H.escapedEmSt=/(?:^|[^\\])(?:\\\\)*\\[*_]/g;H._comment=le(W._comment).replace("(?:-->|$)","-->").getRegex();H.emStrong.lDelim=le(H.emStrong.lDelim).replace(/punct/g,H._punctuation).getRegex();H.emStrong.rDelimAst=le(H.emStrong.rDelimAst,"g").replace(/punct/g,H._punctuation).getRegex();H.emStrong.rDelimUnd=le(H.emStrong.rDelimUnd,"g").replace(/punct/g,H._punctuation).getRegex();H._escapes=/\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;H._scheme=/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;H._email=/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;H.autolink=le(H.autolink).replace("scheme",H._scheme).replace("email",H._email).getRegex();H._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;H.tag=le(H.tag).replace("comment",H._comment).replace("attribute",H._attribute).getRegex();H._label=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;H._href=/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;H._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;H.link=le(H.link).replace("label",H._label).replace("href",H._href).replace("title",H._title).getRegex();H.reflink=le(H.reflink).replace("label",H._label).replace("ref",W._label).getRegex();H.nolink=le(H.nolink).replace("ref",W._label).getRegex();H.reflinkSearch=le(H.reflinkSearch,"g").replace("reflink",H.reflink).replace("nolink",H.nolink).getRegex();H.normal={...H};H.pedantic={...H.normal,strong:{start:/^__|\*\*/,middle:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,endAst:/\*\*(?!\*)/g,endUnd:/__(?!_)/g},em:{start:/^_|\*/,middle:/^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,endAst:/\*(?!\*)/g,endUnd:/_(?!_)/g},link:le(/^!?\[(label)\]\((.*?)\)/).replace("label",H._label).getRegex(),reflink:le(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",H._label).getRegex()};H.gfm={...H.normal,escape:le(H.escape).replace("])","~|])").getRegex(),_extended_email:/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,url:/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/};H.gfm.url=le(H.gfm.url,"i").replace("email",H.gfm._extended_email).getRegex();H.breaks={...H.gfm,br:le(H.br).replace("{2,}","*").getRegex(),text:le(H.gfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()};function h0(a){return a.replace(/---/g,"—").replace(/--/g,"–").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1‘").replace(/'/g,"’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1“").replace(/"/g,"”").replace(/\.{3}/g,"…")}function Dt(a){let e="",n,o;const t=a.length;for(n=0;n<t;n++)o=a.charCodeAt(n),Math.random()>.5&&(o="x"+o.toString(16)),e+="&#"+o+";";return e}class De{constructor(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||Pe,this.options.tokenizer=this.options.tokenizer||new lt,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};const n={block:W.normal,inline:H.normal};this.options.pedantic?(n.block=W.pedantic,n.inline=H.pedantic):this.options.gfm&&(n.block=W.gfm,this.options.breaks?n.inline=H.breaks:n.inline=H.gfm),this.tokenizer.rules=n}static get rules(){return{block:W,inline:H}}static lex(e,n){return new De(n).lex(e)}static lexInline(e,n){return new De(n).inlineTokens(e)}lex(e){e=e.replace(/\r\n|\r/g,`
`),this.blockTokens(e,this.tokens);let n;for(;n=this.inlineQueue.shift();)this.inlineTokens(n.src,n.tokens);return this.tokens}blockTokens(e,n=[]){this.options.pedantic?e=e.replace(/\t/g,"    ").replace(/^ +$/gm,""):e=e.replace(/^( *)(\t+)/gm,(s,l,f)=>l+"    ".repeat(f.length));let o,t,i,r;for(;e;)if(!(this.options.extensions&&this.options.extensions.block&&this.options.extensions.block.some(s=>(o=s.call({lexer:this},e,n))?(e=e.substring(o.raw.length),n.push(o),!0):!1))){if(o=this.tokenizer.space(e)){e=e.substring(o.raw.length),o.raw.length===1&&n.length>0?n[n.length-1].raw+=`
`:n.push(o);continue}if(o=this.tokenizer.code(e)){e=e.substring(o.raw.length),t=n[n.length-1],t&&(t.type==="paragraph"||t.type==="text")?(t.raw+=`
`+o.raw,t.text+=`
`+o.text,this.inlineQueue[this.inlineQueue.length-1].src=t.text):n.push(o);continue}if(o=this.tokenizer.fences(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.heading(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.hr(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.blockquote(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.list(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.html(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.def(e)){e=e.substring(o.raw.length),t=n[n.length-1],t&&(t.type==="paragraph"||t.type==="text")?(t.raw+=`
`+o.raw,t.text+=`
`+o.raw,this.inlineQueue[this.inlineQueue.length-1].src=t.text):this.tokens.links[o.tag]||(this.tokens.links[o.tag]={href:o.href,title:o.title});continue}if(o=this.tokenizer.table(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.lheading(e)){e=e.substring(o.raw.length),n.push(o);continue}if(i=e,this.options.extensions&&this.options.extensions.startBlock){let s=1/0;const l=e.slice(1);let f;this.options.extensions.startBlock.forEach(function(c){f=c.call({lexer:this},l),typeof f=="number"&&f>=0&&(s=Math.min(s,f))}),s<1/0&&s>=0&&(i=e.substring(0,s+1))}if(this.state.top&&(o=this.tokenizer.paragraph(i))){t=n[n.length-1],r&&t.type==="paragraph"?(t.raw+=`
`+o.raw,t.text+=`
`+o.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=t.text):n.push(o),r=i.length!==e.length,e=e.substring(o.raw.length);continue}if(o=this.tokenizer.text(e)){e=e.substring(o.raw.length),t=n[n.length-1],t&&t.type==="text"?(t.raw+=`
`+o.raw,t.text+=`
`+o.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=t.text):n.push(o);continue}if(e){const s="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(s);break}else throw new Error(s)}}return this.state.top=!0,n}inline(e,n=[]){return this.inlineQueue.push({src:e,tokens:n}),n}inlineTokens(e,n=[]){let o,t,i,r=e,s,l,f;if(this.tokens.links){const c=Object.keys(this.tokens.links);if(c.length>0)for(;(s=this.tokenizer.rules.inline.reflinkSearch.exec(r))!=null;)c.includes(s[0].slice(s[0].lastIndexOf("[")+1,-1))&&(r=r.slice(0,s.index)+"["+Et("a",s[0].length-2)+"]"+r.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;(s=this.tokenizer.rules.inline.blockSkip.exec(r))!=null;)r=r.slice(0,s.index)+"["+Et("a",s[0].length-2)+"]"+r.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;(s=this.tokenizer.rules.inline.escapedEmSt.exec(r))!=null;)r=r.slice(0,s.index+s[0].length-2)+"++"+r.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex),this.tokenizer.rules.inline.escapedEmSt.lastIndex--;for(;e;)if(l||(f=""),l=!1,!(this.options.extensions&&this.options.extensions.inline&&this.options.extensions.inline.some(c=>(o=c.call({lexer:this},e,n))?(e=e.substring(o.raw.length),n.push(o),!0):!1))){if(o=this.tokenizer.escape(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.tag(e)){e=e.substring(o.raw.length),t=n[n.length-1],t&&o.type==="text"&&t.type==="text"?(t.raw+=o.raw,t.text+=o.text):n.push(o);continue}if(o=this.tokenizer.link(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.reflink(e,this.tokens.links)){e=e.substring(o.raw.length),t=n[n.length-1],t&&o.type==="text"&&t.type==="text"?(t.raw+=o.raw,t.text+=o.text):n.push(o);continue}if(o=this.tokenizer.emStrong(e,r,f)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.codespan(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.br(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.del(e)){e=e.substring(o.raw.length),n.push(o);continue}if(o=this.tokenizer.autolink(e,Dt)){e=e.substring(o.raw.length),n.push(o);continue}if(!this.state.inLink&&(o=this.tokenizer.url(e,Dt))){e=e.substring(o.raw.length),n.push(o);continue}if(i=e,this.options.extensions&&this.options.extensions.startInline){let c=1/0;const u=e.slice(1);let p;this.options.extensions.startInline.forEach(function(m){p=m.call({lexer:this},u),typeof p=="number"&&p>=0&&(c=Math.min(c,p))}),c<1/0&&c>=0&&(i=e.substring(0,c+1))}if(o=this.tokenizer.inlineText(i,h0)){e=e.substring(o.raw.length),o.raw.slice(-1)!=="_"&&(f=o.raw.slice(-1)),l=!0,t=n[n.length-1],t&&t.type==="text"?(t.raw+=o.raw,t.text+=o.text):n.push(o);continue}if(e){const c="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(c);break}else throw new Error(c)}}return n}}class st{constructor(e){this.options=e||Pe}code(e,n,o){const t=(n||"").match(/\S*/)[0];if(this.options.highlight){const i=this.options.highlight(e,t);i!=null&&i!==e&&(o=!0,e=i)}return e=e.replace(/\n$/,"")+`
`,t?'<pre><code class="'+this.options.langPrefix+be(t)+'">'+(o?e:be(e,!0))+`</code></pre>
`:"<pre><code>"+(o?e:be(e,!0))+`</code></pre>
`}blockquote(e){return`<blockquote>
${e}</blockquote>
`}html(e){return e}heading(e,n,o,t){if(this.options.headerIds){const i=this.options.headerPrefix+t.slug(o);return`<h${n} id="${i}">${e}</h${n}>
`}return`<h${n}>${e}</h${n}>
`}hr(){return this.options.xhtml?`<hr/>
`:`<hr>
`}list(e,n,o){const t=n?"ol":"ul",i=n&&o!==1?' start="'+o+'"':"";return"<"+t+i+`>
`+e+"</"+t+`>
`}listitem(e){return`<li>${e}</li>
`}checkbox(e){return"<input "+(e?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "}paragraph(e){return`<p>${e}</p>
`}table(e,n){return n&&(n=`<tbody>${n}</tbody>`),`<table>
<thead>
`+e+`</thead>
`+n+`</table>
`}tablerow(e){return`<tr>
${e}</tr>
`}tablecell(e,n){const o=n.header?"th":"td";return(n.align?`<${o} align="${n.align}">`:`<${o}>`)+e+`</${o}>
`}strong(e){return`<strong>${e}</strong>`}em(e){return`<em>${e}</em>`}codespan(e){return`<code>${e}</code>`}br(){return this.options.xhtml?"<br/>":"<br>"}del(e){return`<del>${e}</del>`}link(e,n,o){if(e=yt(this.options.sanitize,this.options.baseUrl,e),e===null)return o;let t='<a href="'+e+'"';return n&&(t+=' title="'+n+'"'),t+=">"+o+"</a>",t}image(e,n,o){if(e=yt(this.options.sanitize,this.options.baseUrl,e),e===null)return o;let t=`<img src="${e}" alt="${o}"`;return n&&(t+=` title="${n}"`),t+=this.options.xhtml?"/>":">",t}text(e){return e}}class cn{strong(e){return e}em(e){return e}codespan(e){return e}del(e){return e}html(e){return e}text(e){return e}link(e,n,o){return""+o}image(e,n,o){return""+o}br(){return""}}class ft{constructor(){this.seen={}}serialize(e){return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig,"").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,"").replace(/\s/g,"-")}getNextSafeSlug(e,n){let o=e,t=0;if(this.seen.hasOwnProperty(o)){t=this.seen[e];do t++,o=e+"-"+t;while(this.seen.hasOwnProperty(o))}return n||(this.seen[e]=t,this.seen[o]=0),o}slug(e,n={}){const o=this.serialize(e);return this.getNextSafeSlug(o,n.dryrun)}}class Ce{constructor(e){this.options=e||Pe,this.options.renderer=this.options.renderer||new st,this.renderer=this.options.renderer,this.renderer.options=this.options,this.textRenderer=new cn,this.slugger=new ft}static parse(e,n){return new Ce(n).parse(e)}static parseInline(e,n){return new Ce(n).parseInline(e)}parse(e,n=!0){let o="",t,i,r,s,l,f,c,u,p,m,d,g,C,E,S,M,v,x,$;const L=e.length;for(t=0;t<L;t++){if(m=e[t],this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[m.type]&&($=this.options.extensions.renderers[m.type].call({parser:this},m),$!==!1||!["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(m.type))){o+=$||"";continue}switch(m.type){case"space":continue;case"hr":{o+=this.renderer.hr();continue}case"heading":{o+=this.renderer.heading(this.parseInline(m.tokens),m.depth,fn(this.parseInline(m.tokens,this.textRenderer)),this.slugger);continue}case"code":{o+=this.renderer.code(m.text,m.lang,m.escaped);continue}case"table":{for(u="",c="",s=m.header.length,i=0;i<s;i++)c+=this.renderer.tablecell(this.parseInline(m.header[i].tokens),{header:!0,align:m.align[i]});for(u+=this.renderer.tablerow(c),p="",s=m.rows.length,i=0;i<s;i++){for(f=m.rows[i],c="",l=f.length,r=0;r<l;r++)c+=this.renderer.tablecell(this.parseInline(f[r].tokens),{header:!1,align:m.align[r]});p+=this.renderer.tablerow(c)}o+=this.renderer.table(u,p);continue}case"blockquote":{p=this.parse(m.tokens),o+=this.renderer.blockquote(p);continue}case"list":{for(d=m.ordered,g=m.start,C=m.loose,s=m.items.length,p="",i=0;i<s;i++)S=m.items[i],M=S.checked,v=S.task,E="",S.task&&(x=this.renderer.checkbox(M),C?S.tokens.length>0&&S.tokens[0].type==="paragraph"?(S.tokens[0].text=x+" "+S.tokens[0].text,S.tokens[0].tokens&&S.tokens[0].tokens.length>0&&S.tokens[0].tokens[0].type==="text"&&(S.tokens[0].tokens[0].text=x+" "+S.tokens[0].tokens[0].text)):S.tokens.unshift({type:"text",text:x}):E+=x),E+=this.parse(S.tokens,C),p+=this.renderer.listitem(E,v,M);o+=this.renderer.list(p,d,g);continue}case"html":{o+=this.renderer.html(m.text);continue}case"paragraph":{o+=this.renderer.paragraph(this.parseInline(m.tokens));continue}case"text":{for(p=m.tokens?this.parseInline(m.tokens):m.text;t+1<L&&e[t+1].type==="text";)m=e[++t],p+=`
`+(m.tokens?this.parseInline(m.tokens):m.text);o+=n?this.renderer.paragraph(p):p;continue}default:{const D='Token with "'+m.type+'" type was not found.';if(this.options.silent){console.error(D);return}else throw new Error(D)}}}return o}parseInline(e,n){n=n||this.renderer;let o="",t,i,r;const s=e.length;for(t=0;t<s;t++){if(i=e[t],this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[i.type]&&(r=this.options.extensions.renderers[i.type].call({parser:this},i),r!==!1||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(i.type))){o+=r||"";continue}switch(i.type){case"escape":{o+=n.text(i.text);break}case"html":{o+=n.html(i.text);break}case"link":{o+=n.link(i.href,i.title,this.parseInline(i.tokens,n));break}case"image":{o+=n.image(i.href,i.title,i.text);break}case"strong":{o+=n.strong(this.parseInline(i.tokens,n));break}case"em":{o+=n.em(this.parseInline(i.tokens,n));break}case"codespan":{o+=n.codespan(i.text);break}case"br":{o+=n.br();break}case"del":{o+=n.del(this.parseInline(i.tokens,n));break}case"text":{o+=n.text(i.text);break}default:{const l='Token with "'+i.type+'" type was not found.';if(this.options.silent){console.error(l);return}else throw new Error(l)}}}return o}}class ot{constructor(e){this.options=e||Pe}static passThroughHooks=new Set(["preprocess","postprocess"]);preprocess(e){return e}postprocess(e){return e}}function v0(a,e,n){return o=>{if(o.message+=`
Please report this to https://github.com/markedjs/marked.`,a){const t="<p>An error occurred:</p><pre>"+be(o.message+"",!0)+"</pre>";if(e)return Promise.resolve(t);if(n){n(null,t);return}return t}if(e)return Promise.reject(o);if(n){n(o);return}throw o}}function un(a,e){return(n,o,t)=>{typeof o=="function"&&(t=o,o=null);const i={...o};o={...j.defaults,...i};const r=v0(o.silent,o.async,t);if(typeof n>"u"||n===null)return r(new Error("marked(): input parameter is undefined or null"));if(typeof n!="string")return r(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected"));if(m0(o),o.hooks&&(o.hooks.options=o),t){const s=o.highlight;let l;try{o.hooks&&(n=o.hooks.preprocess(n)),l=a(n,o)}catch(u){return r(u)}const f=function(u){let p;if(!u)try{o.walkTokens&&j.walkTokens(l,o.walkTokens),p=e(l,o),o.hooks&&(p=o.hooks.postprocess(p))}catch(m){u=m}return o.highlight=s,u?r(u):t(null,p)};if(!s||s.length<3||(delete o.highlight,!l.length))return f();let c=0;j.walkTokens(l,function(u){u.type==="code"&&(c++,setTimeout(()=>{s(u.text,u.lang,function(p,m){if(p)return f(p);m!=null&&m!==u.text&&(u.text=m,u.escaped=!0),c--,c===0&&f()})},0))}),c===0&&f();return}if(o.async)return Promise.resolve(o.hooks?o.hooks.preprocess(n):n).then(s=>a(s,o)).then(s=>o.walkTokens?Promise.all(j.walkTokens(s,o.walkTokens)).then(()=>s):s).then(s=>e(s,o)).then(s=>o.hooks?o.hooks.postprocess(s):s).catch(r);try{o.hooks&&(n=o.hooks.preprocess(n));const s=a(n,o);o.walkTokens&&j.walkTokens(s,o.walkTokens);let l=e(s,o);return o.hooks&&(l=o.hooks.postprocess(l)),l}catch(s){return r(s)}}}function j(a,e,n){return un(De.lex,Ce.parse)(a,e,n)}j.options=j.setOptions=function(a){return j.defaults={...j.defaults,...a},e0(j.defaults),j};j.getDefaults=an;j.defaults=Pe;j.use=function(...a){const e=j.defaults.extensions||{renderers:{},childTokens:{}};a.forEach(n=>{const o={...n};if(o.async=j.defaults.async||o.async||!1,n.extensions&&(n.extensions.forEach(t=>{if(!t.name)throw new Error("extension name required");if(t.renderer){const i=e.renderers[t.name];i?e.renderers[t.name]=function(...r){let s=t.renderer.apply(this,r);return s===!1&&(s=i.apply(this,r)),s}:e.renderers[t.name]=t.renderer}if(t.tokenizer){if(!t.level||t.level!=="block"&&t.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");e[t.level]?e[t.level].unshift(t.tokenizer):e[t.level]=[t.tokenizer],t.start&&(t.level==="block"?e.startBlock?e.startBlock.push(t.start):e.startBlock=[t.start]:t.level==="inline"&&(e.startInline?e.startInline.push(t.start):e.startInline=[t.start]))}t.childTokens&&(e.childTokens[t.name]=t.childTokens)}),o.extensions=e),n.renderer){const t=j.defaults.renderer||new st;for(const i in n.renderer){const r=t[i];t[i]=(...s)=>{let l=n.renderer[i].apply(t,s);return l===!1&&(l=r.apply(t,s)),l}}o.renderer=t}if(n.tokenizer){const t=j.defaults.tokenizer||new lt;for(const i in n.tokenizer){const r=t[i];t[i]=(...s)=>{let l=n.tokenizer[i].apply(t,s);return l===!1&&(l=r.apply(t,s)),l}}o.tokenizer=t}if(n.hooks){const t=j.defaults.hooks||new ot;for(const i in n.hooks){const r=t[i];ot.passThroughHooks.has(i)?t[i]=s=>{if(j.defaults.async)return Promise.resolve(n.hooks[i].call(t,s)).then(f=>r.call(t,f));const l=n.hooks[i].call(t,s);return r.call(t,l)}:t[i]=(...s)=>{let l=n.hooks[i].apply(t,s);return l===!1&&(l=r.apply(t,s)),l}}o.hooks=t}if(n.walkTokens){const t=j.defaults.walkTokens;o.walkTokens=function(i){let r=[];return r.push(n.walkTokens.call(this,i)),t&&(r=r.concat(t.call(this,i))),r}}j.setOptions(o)})};j.walkTokens=function(a,e){let n=[];for(const o of a)switch(n=n.concat(e.call(j,o)),o.type){case"table":{for(const t of o.header)n=n.concat(j.walkTokens(t.tokens,e));for(const t of o.rows)for(const i of t)n=n.concat(j.walkTokens(i.tokens,e));break}case"list":{n=n.concat(j.walkTokens(o.items,e));break}default:j.defaults.extensions&&j.defaults.extensions.childTokens&&j.defaults.extensions.childTokens[o.type]?j.defaults.extensions.childTokens[o.type].forEach(function(t){n=n.concat(j.walkTokens(o[t],e))}):o.tokens&&(n=n.concat(j.walkTokens(o.tokens,e)))}return n};j.parseInline=un(De.lexInline,Ce.parseInline);j.Parser=Ce;j.parser=Ce.parse;j.Renderer=st;j.TextRenderer=cn;j.Lexer=De;j.lexer=De.lex;j.Tokenizer=lt;j.Slugger=ft;j.Hooks=ot;j.parse=j;j.options;j.setOptions;j.use;j.walkTokens;j.parseInline;Ce.parse;De.lex;const pn={};function g0(a){let e;return{c(){e=R(a[1])},l(n){e=P(n,a[1])},m(n,o){A(n,e,o)},p(n,o){o&2&&pe(e,n[1])},i:ne,o:ne,d(n){n&&h(e)}}}function x0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=B("h6"),t&&t.c(),this.h()},l(i){e=z(i,"H6",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function _0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=B("h5"),t&&t.c(),this.h()},l(i){e=z(i,"H5",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function b0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=B("h4"),t&&t.c(),this.h()},l(i){e=z(i,"H4",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function w0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=B("h3"),t&&t.c(),this.h()},l(i){e=z(i,"H3",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function $0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=B("h2"),t&&t.c(),this.h()},l(i){e=z(i,"H2",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function k0(a){let e,n;const o=a[5].default,t=se(o,a,a[4],null);return{c(){e=B("h1"),t&&t.c(),this.h()},l(i){e=z(i,"H1",{id:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"id",a[2])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&16)&&fe(t,o,i,i[4],n?ue(o,i[4],r,null):ce(i[4]),null),(!n||r&4)&&y(e,"id",i[2])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function y0(a){let e,n,o,t;const i=[k0,$0,w0,b0,_0,x0,g0],r=[];function s(l,f){return l[0]===1?0:l[0]===2?1:l[0]===3?2:l[0]===4?3:l[0]===5?4:l[0]===6?5:6}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,[f]){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function S0(a,e,n){let o,{$$slots:t={},$$scope:i}=e,{depth:r}=e,{raw:s}=e,{text:l}=e;const{slug:f,getOptions:c}=Sn(pn),u=c();return a.$$set=p=>{"depth"in p&&n(0,r=p.depth),"raw"in p&&n(1,s=p.raw),"text"in p&&n(3,l=p.text),"$$scope"in p&&n(4,i=p.$$scope)},a.$$.update=()=>{a.$$.dirty&8&&n(2,o=u.headerIds?u.headerPrefix+f(l):void 0)},[r,s,o,l,i,t]}class E0 extends Q{constructor(e){super(),J(this,e,S0,y0,ee,{depth:0,raw:1,text:3})}}function A0(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=B("p"),t&&t.c()},l(i){e=z(i,"P",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function D0(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class B0 extends Q{constructor(e){super(),J(this,e,D0,A0,ee,{})}}function z0(a){let e;const n=a[3].default,o=se(n,a,a[2],null);return{c(){o&&o.c()},l(t){o&&o.l(t)},m(t,i){o&&o.m(t,i),e=!0},p(t,[i]){o&&o.p&&(!e||i&4)&&fe(o,n,t,t[2],e?ue(n,t[2],i,null):ce(t[2]),null)},i(t){e||(_(o,t),e=!0)},o(t){k(o,t),e=!1},d(t){o&&o.d(t)}}}function C0(a,e,n){let{$$slots:o={},$$scope:t}=e,{text:i}=e,{raw:r}=e;return a.$$set=s=>{"text"in s&&n(0,i=s.text),"raw"in s&&n(1,r=s.raw),"$$scope"in s&&n(2,t=s.$$scope)},[i,r,t,o]}class T0 extends Q{constructor(e){super(),J(this,e,C0,z0,ee,{text:0,raw:1})}}function I0(a){let e,n;return{c(){e=B("img"),this.h()},l(o){e=z(o,"IMG",{src:!0,title:!0,alt:!0}),this.h()},h(){et(e.src,n=a[0])||y(e,"src",n),y(e,"title",a[1]),y(e,"alt",a[2])},m(o,t){A(o,e,t)},p(o,[t]){t&1&&!et(e.src,n=o[0])&&y(e,"src",n),t&2&&y(e,"title",o[1]),t&4&&y(e,"alt",o[2])},i:ne,o:ne,d(o){o&&h(e)}}}function L0(a,e,n){let{href:o=""}=e,{title:t=void 0}=e,{text:i=""}=e;return a.$$set=r=>{"href"in r&&n(0,o=r.href),"title"in r&&n(1,t=r.title),"text"in r&&n(2,i=r.text)},[o,t,i]}class R0 extends Q{constructor(e){super(),J(this,e,L0,I0,ee,{href:0,title:1,text:2})}}function P0(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=B("a"),t&&t.c(),this.h()},l(i){e=z(i,"A",{href:!0,title:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"href",a[0]),y(e,"title",a[1])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null),(!n||r&1)&&y(e,"href",i[0]),(!n||r&2)&&y(e,"title",i[1])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function F0(a,e,n){let{$$slots:o={},$$scope:t}=e,{href:i=""}=e,{title:r=void 0}=e;return a.$$set=s=>{"href"in s&&n(0,i=s.href),"title"in s&&n(1,r=s.title),"$$scope"in s&&n(2,t=s.$$scope)},[i,r,t,o]}class M0 extends Q{constructor(e){super(),J(this,e,F0,P0,ee,{href:0,title:1})}}function N0(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=B("em"),t&&t.c()},l(i){e=z(i,"EM",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function U0(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class O0 extends Q{constructor(e){super(),J(this,e,U0,N0,ee,{})}}function V0(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=B("del"),t&&t.c()},l(i){e=z(i,"DEL",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function H0(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class K0 extends Q{constructor(e){super(),J(this,e,H0,V0,ee,{})}}function q0(a){let e,n=a[0].replace(/`/g,"")+"",o;return{c(){e=B("code"),o=R(n)},l(t){e=z(t,"CODE",{});var i=T(e);o=P(i,n),i.forEach(h)},m(t,i){A(t,e,i),w(e,o)},p(t,[i]){i&1&&n!==(n=t[0].replace(/`/g,"")+"")&&pe(o,n)},i:ne,o:ne,d(t){t&&h(e)}}}function Y0(a,e,n){let{raw:o}=e;return a.$$set=t=>{"raw"in t&&n(0,o=t.raw)},[o]}class G0 extends Q{constructor(e){super(),J(this,e,Y0,q0,ee,{raw:0})}}function W0(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=B("strong"),t&&t.c()},l(i){e=z(i,"STRONG",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function X0(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class j0 extends Q{constructor(e){super(),J(this,e,X0,W0,ee,{})}}function Z0(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=B("table"),t&&t.c()},l(i){e=z(i,"TABLE",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function Q0(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class J0 extends Q{constructor(e){super(),J(this,e,Q0,Z0,ee,{})}}function eo(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=B("thead"),t&&t.c()},l(i){e=z(i,"THEAD",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function to(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class no extends Q{constructor(e){super(),J(this,e,to,eo,ee,{})}}function oo(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=B("tbody"),t&&t.c()},l(i){e=z(i,"TBODY",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function ro(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class io extends Q{constructor(e){super(),J(this,e,ro,oo,ee,{})}}function ao(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=B("tr"),t&&t.c()},l(i){e=z(i,"TR",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function lo(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class so extends Q{constructor(e){super(),J(this,e,lo,ao,ee,{})}}function fo(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=B("td"),t&&t.c(),this.h()},l(i){e=z(i,"TD",{align:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"align",a[1])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null),(!n||r&2)&&y(e,"align",i[1])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function co(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=B("th"),t&&t.c(),this.h()},l(i){e=z(i,"TH",{align:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"align",a[1])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null),(!n||r&2)&&y(e,"align",i[1])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function uo(a){let e,n,o,t;const i=[co,fo],r=[];function s(l,f){return l[0]?0:1}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,[f]){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function po(a,e,n){let{$$slots:o={},$$scope:t}=e,{header:i}=e,{align:r}=e;return a.$$set=s=>{"header"in s&&n(0,i=s.header),"align"in s&&n(1,r=s.align),"$$scope"in s&&n(2,t=s.$$scope)},[i,r,t,o]}class mo extends Q{constructor(e){super(),J(this,e,po,uo,ee,{header:0,align:1})}}function ho(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=B("ul"),t&&t.c()},l(i){e=z(i,"UL",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function vo(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=B("ol"),t&&t.c(),this.h()},l(i){e=z(i,"OL",{start:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"start",a[1])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,r){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null),(!n||r&2)&&y(e,"start",i[1])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function go(a){let e,n,o,t;const i=[vo,ho],r=[];function s(l,f){return l[0]?0:1}return e=s(a),n=r[e]=i[e](a),{c(){n.c(),o=K()},l(l){n.l(l),o=K()},m(l,f){r[e].m(l,f),A(l,o,f),t=!0},p(l,[f]){let c=e;e=s(l),e===c?r[e].p(l,f):(oe(),k(r[c],1,1,()=>{r[c]=null}),re(),n=r[e],n?n.p(l,f):(n=r[e]=i[e](l),n.c()),_(n,1),n.m(o.parentNode,o))},i(l){t||(_(n),t=!0)},o(l){k(n),t=!1},d(l){r[e].d(l),l&&h(o)}}}function xo(a,e,n){let{$$slots:o={},$$scope:t}=e,{ordered:i}=e,{start:r}=e;return a.$$set=s=>{"ordered"in s&&n(0,i=s.ordered),"start"in s&&n(1,r=s.start),"$$scope"in s&&n(2,t=s.$$scope)},[i,r,t,o]}class _o extends Q{constructor(e){super(),J(this,e,xo,go,ee,{ordered:0,start:1})}}function bo(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=B("li"),t&&t.c()},l(i){e=z(i,"LI",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function wo(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class $o extends Q{constructor(e){super(),J(this,e,wo,bo,ee,{})}}function ko(a){let e;return{c(){e=B("hr")},l(n){e=z(n,"HR",{})},m(n,o){A(n,e,o)},p:ne,i:ne,o:ne,d(n){n&&h(e)}}}class yo extends Q{constructor(e){super(),J(this,e,null,ko,ee,{})}}function So(a){let e,n;return{c(){e=new En(!1),n=K(),this.h()},l(o){e=An(o,!1),n=K(),this.h()},h(){e.a=n},m(o,t){e.m(a[0],o,t),A(o,n,t)},p(o,[t]){t&1&&e.p(o[0])},i:ne,o:ne,d(o){o&&h(n),o&&e.d()}}}function Eo(a,e,n){let{text:o}=e;return a.$$set=t=>{"text"in t&&n(0,o=t.text)},[o]}class Ao extends Q{constructor(e){super(),J(this,e,Eo,So,ee,{text:0})}}function Do(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=B("blockquote"),t&&t.c()},l(i){e=z(i,"BLOCKQUOTE",{});var r=T(e);t&&t.l(r),r.forEach(h)},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function Bo(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class zo extends Q{constructor(e){super(),J(this,e,Bo,Do,ee,{})}}function Co(a){let e,n,o;return{c(){e=B("pre"),n=B("code"),o=R(a[1]),this.h()},l(t){e=z(t,"PRE",{class:!0});var i=T(e);n=z(i,"CODE",{});var r=T(n);o=P(r,a[1]),r.forEach(h),i.forEach(h),this.h()},h(){y(e,"class",a[0])},m(t,i){A(t,e,i),w(e,n),w(n,o)},p(t,[i]){i&2&&pe(o,t[1]),i&1&&y(e,"class",t[0])},i:ne,o:ne,d(t){t&&h(e)}}}function To(a,e,n){let{lang:o}=e,{text:t}=e;return a.$$set=i=>{"lang"in i&&n(0,o=i.lang),"text"in i&&n(1,t=i.text)},[o,t]}class Io extends Q{constructor(e){super(),J(this,e,To,Co,ee,{lang:0,text:1})}}function Lo(a){let e,n;const o=a[1].default,t=se(o,a,a[0],null);return{c(){e=B("br"),t&&t.c()},l(i){e=z(i,"BR",{}),t&&t.l(i)},m(i,r){A(i,e,r),t&&t.m(i,r),n=!0},p(i,[r]){t&&t.p&&(!n||r&1)&&fe(t,o,i,i[0],n?ue(o,i[0],r,null):ce(i[0]),null)},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function Ro(a,e,n){let{$$slots:o={},$$scope:t}=e;return a.$$set=i=>{"$$scope"in i&&n(0,t=i.$$scope)},[t,o]}class Po extends Q{constructor(e){super(),J(this,e,Ro,Lo,ee,{})}}const Fo={heading:E0,paragraph:B0,text:T0,image:R0,link:M0,em:O0,strong:j0,codespan:G0,del:K0,table:J0,tablehead:no,tablebody:io,tablerow:so,tablecell:mo,list:_o,orderedlistitem:null,unorderedlistitem:null,listitem:$o,hr:yo,html:Ao,blockquote:zo,code:Io,br:Po},Mo={baseUrl:null,breaks:!1,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartLists:!1,smartypants:!1,tokenizer:null,xhtml:!1};function No(a){let e,n;return e=new Re({props:{tokens:a[0],renderers:a[1]}}),{c(){N(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){U(e,o,t),n=!0},p(o,[t]){const i={};t&1&&(i.tokens=o[0]),t&2&&(i.renderers=o[1]),e.$set(i)},i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){O(e,o)}}}function Uo(a,e,n){let o,t,i,r,{source:s=[]}=e,{renderers:l={}}=e,{options:f={}}=e,{isInline:c=!1}=e;const u=Ge();let p,m,d;return Dn(pn,{slug:g=>t?t.slug(g):"",getOptions:()=>i}),$e(()=>{n(7,d=!0)}),a.$$set=g=>{"source"in g&&n(2,s=g.source),"renderers"in g&&n(3,l=g.renderers),"options"in g&&n(4,f=g.options),"isInline"in g&&n(5,c=g.isInline)},a.$$.update=()=>{a.$$.dirty&4&&n(8,o=Array.isArray(s)),a.$$.dirty&4&&(t=s?new ft:void 0),a.$$.dirty&16&&n(9,i={...Mo,...f}),a.$$.dirty&869&&(o?n(0,p=s):(n(6,m=new De(i)),n(0,p=c?m.inlineTokens(s):m.lex(s)),u("parsed",{tokens:p}))),a.$$.dirty&8&&n(1,r={...Fo,...l}),a.$$.dirty&385&&d&&!o&&u("parsed",{tokens:p})},[p,r,s,l,f,c,m,d,o,i]}class Oo extends Q{constructor(e){super(),J(this,e,Uo,No,ee,{source:2,renderers:3,options:4,isInline:5})}}function Vo(a){let e,n;return{c(){e=B("img"),this.h()},l(o){e=z(o,"IMG",{src:!0,title:!0,alt:!0,class:!0}),this.h()},h(){et(e.src,n=a[0])||y(e,"src",n),y(e,"title",a[1]),y(e,"alt",a[2]),y(e,"class","svelte-1pemytu")},m(o,t){A(o,e,t)},p(o,[t]){t&1&&!et(e.src,n=o[0])&&y(e,"src",n),t&2&&y(e,"title",o[1]),t&4&&y(e,"alt",o[2])},i:ne,o:ne,d(o){o&&h(e)}}}function Ho(a,e,n){let{href:o=""}=e,{title:t=void 0}=e,{text:i=""}=e;return a.$$set=r=>{"href"in r&&n(0,o=r.href),"title"in r&&n(1,t=r.title),"text"in r&&n(2,i=r.text)},[o,t,i]}class Ko extends Q{constructor(e){super(),J(this,e,Ho,Vo,ee,{href:0,title:1,text:2})}}function qo(a){let e,n;const o=a[3].default,t=se(o,a,a[2],null);return{c(){e=B("a"),t&&t.c(),this.h()},l(i){e=z(i,"A",{target:!0,rel:!0,href:!0,title:!0});var r=T(e);t&&t.l(r),r.forEach(h),this.h()},h(){y(e,"target","_blank"),y(e,"rel","noopener noreferrer"),y(e,"href",a[0]),y(e,"title",a[1])},m(i,r){A(i,e,r),t&&t.m(e,null),n=!0},p(i,[r]){t&&t.p&&(!n||r&4)&&fe(t,o,i,i[2],n?ue(o,i[2],r,null):ce(i[2]),null),(!n||r&1)&&y(e,"href",i[0]),(!n||r&2)&&y(e,"title",i[1])},i(i){n||(_(t,i),n=!0)},o(i){k(t,i),n=!1},d(i){i&&h(e),t&&t.d(i)}}}function Yo(a,e,n){let{$$slots:o={},$$scope:t}=e,{href:i=""}=e,{title:r=void 0}=e;return a.$$set=s=>{"href"in s&&n(0,i=s.href),"title"in s&&n(1,r=s.title),"$$scope"in s&&n(2,t=s.$$scope)},[i,r,t,o]}class Go extends Q{constructor(e){super(),J(this,e,Yo,qo,ee,{href:0,title:1})}}const Wo=`# Gray-Scott model for Reaction-Diffusion systems

This page contains my experiementations aroud [reaction-diffusion systems](https://en.wikipedia.org/wiki/Reaction%E2%80%93diffusion_system).

## What is this?

For this project I wanted to learn more about reaction-diffusion systems. The systems I have been considering are mathematical models corresponding to a physical system in which two chemical substances react with each other while also diffusing in the environment.

The main parameters for these simulations are the \`f\` and \`k\` variables. I explain more in details what they correspond to in the next sections, for now just keep in mind that varying \`f\` and \`k\` make the simulation generate different kinds of patterns.

The application contains 4 tabs you can explore.

### Auto
This is my "artistic" stake at this simulation. The \`f\` and \`k\` parameters are contiually changing to automatically generate different kinds of patterns. A mecanism also regularly regenerates some amount of solution so that there is as few stable states as possible. You don't have to do anything, just load the tab and watch funny colors move on the screen.

You can use the menu on the let to tweak how fast the \`f\` and \`k\` parameters change and how much they change each time.

There are several configurations to try out and which give various results:

- Increasing the change magnitude impacts the stability of the system. Small change magnitudes keeps \`f\` and \`k\` in a smaller area so the diversity of patterns generated is reduced, on the other hand larger magnitudes will create larger changes in the parameters space so it might create situations where the one of the chemical reacts with all of the other leaving a uniform colored texture.

- Increasing the change rate makes the parameters get updated more often which might leave more time for configurations to stabilize and display all of their features.

### Manual

This is an interactive view of the model.

The menu on the left allows the user to change the \`f\` and \`k\` parameters of the simulation and see how they influence the reaction. In the center screen the user can drop some amout of solution by moving the mouse around and clicking the left mouse button, the solution can also be removed with the right mouse button. The user can also zoom in the simulation by holding the \`Ctrl\` button and scrolling with the mouse wheel (note that there is a bug in the zoom mecanism which move the simulation around when zooming in/out). Finally the menu on the left allows the user to tweak various parameters like the color scheme used, the speed of the simulation, and the initial conditions, the pen setting to add or remove the solution, etc...

Unlike the Auto tab, this simulation runs a configuration continuously and let the user tweak the parameters as they want. This is a good tool to understand how each parameter impacts the simulation. A few tips to get interesting patterns:

- Don't change the \`f\` and \`k\` values too quickly, abrupt changes tend to stabilize the system very quickly.
- In the selection menu on the left try the orange area of the parameters map is the area which tends to produce more patterns. By moving around you'll find that there are a few differnt areas: the bottom left tends to produce largely chaotic patterns, a little bit higher and on the right we find patterns ressembling cells divisions, higher up are worms on the left and dots on the right with different characteristics as we go higher on the \`f\` axis.
- If the simulation stabilize completely either use the mouse to add new chemical, hit \`r\` to reset the world or move \`fk\` around.

You can try to find many different patterns like the following:

![pattern1]({baseUrl}/reaction_diffusion_about/pattern1.png)
![pattern2]({baseUrl}/reaction_diffusion_about/pattern2.png)
![pattern3]({baseUrl}/reaction_diffusion_about/pattern3.png)
![pattern4]({baseUrl}/reaction_diffusion_about/pattern4.png)
![pattern5]({baseUrl}/reaction_diffusion_about/pattern5.png)

### Parameters map
I used this tab to generate the parameters map used in the simulation parameters menu. By default the settings are lower compared to those I used to generate the final parameter map. Here the difference with the other tabs is that the \`f\` and \`k\` parameters of the simulation are uniform on the grid, they vary accross the screen to show the different possible patterns.

### Previous versions
It took me several iterations to get the results shown in the other tabs. This tab regroups my different iterations.

## Gray-Scott model

The Gray-Scott model is a simulation of two chemicals reacting together. Here the chemicals are named U and V.

The environement is represented with a 2D grid in which each pixel holds a level of concentration of each chemical. The simulation consist of updating the grid following these equations (picture taken [here](https://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/)):

![gray scott equations]({baseUrl}/reaction_diffusion_about/gray-scott-equations.gif)

The chemical reaction section shows that when 1 unit of U and 2 units of V are in contact they react to become 3 units of V. The second part showing the V produces P is not really considered in the implementation, P only represents a byproduct of the reaction which is necessary for the math to work but doesn't really impacts the simulation.

The equations show 3 things:

- Both chemicals diffuse over time and the diffusion from one spot depends on the concentration of the chemical in the surrounding spots
- The chenicals react together and the impact their concentration (which makes sense if 1 U and 2 V create 3 V then during the reaction the concentration of U diminishes and the concentration of P increases)
- \`f\` and \`k\` are respectively a "feed rate" and a "kill rate" which allow the model to keep evolving.

[Karlsims](https://karlsims.com/rd.html) as the clearest explaination of these equations.

The way that I represents this system in my head is as follow:

- Let's have two tanks containing the solutions one on top of the other.
- Both tanks are separated by a semi porous membrane which only allow the U solution from the bottom to go the tank above containing V.
- What we see in my simulation is the surface of the top tank while the U solution is slowly introduced to the V and both react together.

## Turing patterns

The reason why this model is so fascinating is because it gives us a glance at how ordered patterns can emerge from the randomness of nature. This concept which was theorized in 1952 by Alan Turing and is named [Turing patterns](https://en.wikipedia.org/wiki/Turing_pattern)

This is hard to reproduce exact existing patterns because nature is complex whereas this model is quite simple but here are a few similarities I have found:

This are two [madrepora corals](https://en.wikipedia.org/wiki/Madrepora) I took in picture at [La Grande galerie de l'Évolution](https://fr.wikipedia.org/wiki/Grande_galerie_de_l%27%C3%89volution) in Paris:

![madrepore_museum_spots.JPEG]({baseUrl}/reaction_diffusion_about/gallery/madrepore_museum_spots.JPEG)
![madrepore_simulation_spots.png]({baseUrl}/reaction_diffusion_about/gallery/madrepore_simulation_spots.png)
![madrepore_museum_stripes.png]({baseUrl}/reaction_diffusion_about/gallery/madrepore_museum_stripes.png)
![madrepore_simulation_stripes1.png]({baseUrl}/reaction_diffusion_about/gallery/madrepore_simulation_stripes1.png)
![madrepore_simulation_stripes2.png]({baseUrl}/reaction_diffusion_about/gallery/madrepore_simulation_stripes2.png)

This is a puffer fish picture from wikipedia ([[1]](https://commons.wikimedia.org/wiki/File:Giant_Puffer_fish_skin_pattern.JPG) [[2]](https://en.wikipedia.org/wiki/File:Giant_Pufferfish_skin_pattern_detail.jpg))

![800px-Giant_Puffer_fish_skin_pattern.JPG]({baseUrl}/reaction_diffusion_about/gallery/800px-Giant_Puffer_fish_skin_pattern.JPG)
![Giant_Pufferfish_skin_pattern_detail.jpg]({baseUrl}/reaction_diffusion_about/gallery/Giant_Pufferfish_skin_pattern_detail.jpg)
![tbd_simulation_stripes.png]({baseUrl}/reaction_diffusion_about/gallery/tbd_simulation_stripes.png)
![tbd_simulation_stripes_spots.png]({baseUrl}/reaction_diffusion_about/gallery/tbd_simulation_stripes_spots.png)

Here are some behavior ressembling to cells mitosis

![cells_division.gif]({baseUrl}/reaction_diffusion_about/gallery/cells_division.gif)
![cells_division2.gif]({baseUrl}/reaction_diffusion_about/gallery/cells_division2.gif)

A fish [from shutterstock](https://www.shutterstock.com/image-photo/goldspotted-rabbitfish-siganus-punctatus-bali-521298034) not sure which specy this is:

![fish_spots.jpg]({baseUrl}/reaction_diffusion_about/gallery/fish_spots.jpg)
![tbd_simulation_regular_spots.png]({baseUrl}/reaction_diffusion_about/gallery/tbd_simulation_regular_spots.png)

## Resources

Here are some resources I have used to document myself to create this project:

### Gray-Scott model
- Karlsims tutorial about Reaction-diffusion, very good introduction and good explanation of the formula
  https://karlsims.com/rd.html
- Mrob list of a lot of interesting parameter classes
  https://www.mrob.com/pub/comp/xmorphia/pearson-classes.html#eta
- Mrob Uskate parameter space
  https://mrob.com/pub/comp/xmorphia/uskate-world.html
- A very good high level introduction to reaction diffusion with some great analogies with the particule approach. Lot of interesting links.
  https://www.redblobgames.com/x/2202-turing-patterns/
- Redblobgames implementation of the parameter map visualisation
  https://www.redblobgames.com/x/2203-reaction-diffusion/art/parameter-map.html
- Good schema of the experience, one clue about the color map and a parameter space graph visualisation
  https://itp.uni-frankfurt.de/~gros/StudentProjects/Applets_2014_GrayScott/
- A scientific paper "Spatially localized structures in the Gray-Scott model"
  https://royalsocietypublishing.org/doi/10.1098/rsta.2017.0375

### Color maps
- General approach to color maps. Lot of visual representations of colormaps. The interesting one here is the diverging method.
  https://matplotlib.org/stable/tutorials/colors/colormaps.html#diverging

### Other implementations

- https://www.redblobgames.com/x/2203-reaction-diffusion/
- https://www.mrob.com/pub/comp/xmorphia/ogl/index.html
- interesting colormaps and flows implemented. The interface is interesting.
    https://www.karlsims.com/rdtool.html
- Good interface to tweak colors
    https://pmneila.github.io/jsexp/grayscott/

## History of the project

### Prototyping with P5.js (v1, v2, v3)
In versions v1, v2 and v3 were mostly prototyping to validate that I was understanding the math behind the model and the general idea of the simulation.

These versions use the [p5.js](https://p5js.org/) framework to render and update the simulation. The world is represented by a 2D array in typescript and the update is a simple nested for loop iterating on each item of the grid and applying the formula.

The main difference between these 3 versions is the way I was updating the grid. In v1 I started with a very naive approach where I recreated the grid on each iteration. In v3 the algorithm is smarter, I create two grids when I built the world and then each update reads from one of the grids and writes to the other one which is then used by p5 to draw the canvas.

### Dabbling with WebGL (v4)

With the 3 previous versions I validated I understood the model and in v4 I started to make the simulation larger by using the GPU to update the world instead of doing that on the CPU in typescript. This was my first experience with [regl](https://github.com/regl-project/regl) which is an incredibly cool framework to make working with WebGL much easier. This version was laying the fundations for my WebGL simulation: First, in typescript we generate a grid representing the world and we generate two WebGL texture where each pixel is an item of the generated grid.

For each pixel we only generate a value on the red and green channels. Each value is comprised between \`0.0\` and \`1.0\` and corresponds to the concentration of each solution in each discrete position of the world.

Once this is done we create two regl commands:

- The \`update\` command which is responsible for reading from one of the created texture and updating the new state in the other texture.
- The \`draw\` command which simply takes the last updated texture and draws it directly on the canvas. The texture is drawn "raw" as in the red and green channels are used directly in the shader.

\`\`\`glsl
precision mediump float;
uniform sampler2D prevState;
varying vec2 uv;
void main() {
    vec2 state = texture2D(prevState, uv).rg;
    gl_FragColor = vec4(state, 0, 1);
}
\`\`\`

### Adding basic controls to the simulation (v5)

Once my simulation started to work properly on the GPU I wanted to add some interactivity. This was an interesting phase for two reasons:

First it was the opportunity to play with [dat.gui](https://github.com/dataarts/dat.gui/). This is a library which allows to easily create a graphical interface to modify the properties of a javascript object. I had already experimented with this library in my [previous game of life project]({baseUrl}/gameoflife)

In this simulation I added the following settings:

- A very crude manual selection of \`f\` and \`k\` parameters, allowing me to better grasp the impact of the feed rate and kill rate.
- Some additional preset seletions for \`f\` and \`k\`. I took these preset from the examples in [Robert Munafo's extended pearsons classification](https://www.mrob.com/pub/comp/xmorphia/pearson-classes.html). The fact that the classes I took from Robert's website were producing results similar to his own visualization was an encouraging sign that I was going in the right direction.
- A setting allowing to use different initial conditions for the world. It is useful because this version doesn't allow to modify the world with the mouse so having different starting worlds allowed me to test different \`f\` and \`k\` parameters.
- Some basic settings like the ability to pause and reset the simulation or see the current iteration number.

### Using the mouse to change the world (v6)

v6 saw a big improvement in my way to handle the glsl code for my shaders: instead of writing the shader code directly in the initialization of the regl commands (as it's shown in [regl's examples](https://github.com/regl-project/regl/blob/gh-pages/example/basic.js)) I created a mechanism which allows me to write the shader code in separate \`.glsl\` files which are imported in the typescript code and then injected in the regl commands properties.

Having a better separated code allowed me to pass more uniforms to my shaders and particularly to passe the mouse state to the update shader. Now the shader takes the position of the mouse as well as the state of each mouse button as uniforms. This way when updating each pixel if the pixel is close enough from the mouse and the button is pressed we can override the new value of the pixel (and ignore the value coming from the simulation) that allows to artifically increase the concentration of one of the solution on specific spots of the world.

### Zoom and \`fk\` selection (v7)

In v7 I focused on the UI of the application. A lot of things changed on this iteration.

Firstly I reworked the regl code and created two separate pipelines for the simulation itself and for its rendering. The simulation pipeline is basically the same one as in the previous versions.

The graphic pipeline is pretty different:

This version introduce a system where I use several texture to apply different transformations to the simulation texture before displaying it on the screen:

- Step 1 "Zoom": In the vertex shader of the graphical pipeline I pass as uniforms the state of the zoom (i.e. the zoom level and the pan on the x and y axis). These uniforms allows me to draw only the parts of the texture which are currently in a zoomed in area.
- Step 2 "Colors": To make the simulation more visally appealing the first stage takes the raw red and green channels of the simulation texture and transform them to use a wider spectrum of colors. Since regl makes the glsl code quite modular I was able to create different fragment shaders applying different color palettes.
- Step 3 "Grid": To help me debugging the implementation of my zoom mecanism I added a step which overlays a grid on the resulting texture. The goal was to have a grid with a fixed sized which would better show the resolution of the zoom.
- Step 4 "Cursor": To make the mouse drawing more intuitive I add another overlay showing the area which the cursor will drawn on.

This approach has the big advantage of keeping my code very modular and making it easier to implement the different steps. The main drawback is that it requires to keep one texture for each step of the pipeline which has an impact on the GPU. An alternative solution would be to do all the transformations in the same shader but I haven't experimented with that already and I'm not sure what are the best practices for this topic.

I also created the interface to select \`f\` and \`k\` on the parameters map. To do that, the first step was to create another type of simulation largely based on my previous experiements but where the \`f\` and \`k\` parameters are varying among the world. This way when initializing the world with small concentrations of the solutions and letting the simulation run for a few hundreds of thousands of iteration we get a nice map like this one

![parameter map]({baseUrl}/parameters_map.png)

Some inpsiration I had for the parameters map:

- [mrob](https://mrob.com/pub/comp/xmorphia/uskate-world.html)
- [RebBlobGames](https://www.redblobgames.com/x/2203-reaction-diffusion/art/parameter-map.html)

### "Auto Visualizer" (v8)

My last goal for this project was to create an infinite visualization based on the simulation. The issue with the raw simulation is that most of the parameters classes tend to create stable states after a number of iterations. Stable states are interesting to study the Gray-Scott system but they get boring quickly so I created the Auto Visualizer based on two ideas:

First the \`f\` and \`k\` parameters need to change regularly to create new patterns but they need to change slowly. A big step between two values of (f, k) often tend to destroy all the concentrations of chemicals. So reusing the menu component I created to select f and k, I added a bounding box of the values which create the most interesting patterns and then used a noise function to make the parameters vary slowly and consistenly over time.

Even when changing \`f\` and \`k\` the chemicals tends to disappear from the system so I have a mecanism which simulates the user clicking on the screen to add more chemical.
`;function Xo(a){let e,n;return e=new Oo({props:{source:a[0],renderers:{image:Ko,link:Go}}}),{c(){N(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){U(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){O(e,o)}}}function jo(a){return[Wo.replaceAll("{baseUrl}",Ze)]}class Bt extends Q{constructor(e){super(),J(this,e,jo,Xo,ee,{})}}function Zo(a){let e,n,o;return{c(){e=B("div"),this.h()},l(t){e=z(t,"DIV",{style:!0,class:!0}),T(e).forEach(h),this.h()},h(){y(e,"style",a[0]),y(e,"class","m-0")},m(t,i){A(t,e,i),n||(o=Bn(a[1].call(null,e)),n=!0)},p(t,[i]){i&1&&y(e,"style",t[0])},i:ne,o:ne,d(t){t&&h(e),n=!1,o()}}}function Qo(a,e){return e.forEach(([n,o])=>a[n]=o),a}function Jo(a,e,n){let{target:o=void 0}=e,{sketch:t=void 0}=e,{parentDivStyle:i="display: block;"}=e,{debug:r=!1}=e,s;const l=Ge(),f={ref(){l("ref",o)},instance(){l("instance",s)}};function c(u){return n(2,o=u),{destroy(){n(2,o=void 0)}}}return $e(async()=>{const u=await Te(()=>import("../../../chunks/p5.min-b96f42d1.js").then(g=>g.p),["../../../chunks/p5.min-b96f42d1.js","../../../chunks/regl-89b00fbf.js"],import.meta.url),{default:p}=u,d=Object.entries(u).filter(([g,C])=>C instanceof Function&&g[0]!=="_"&&g!=="default");r&&console.log("available p5 native classes",d),s=new p(g=>(g=Qo(g,d),r&&console.log("p5 instance",g),window._p5Instance=g,t(g)),o),f.ref(),f.instance()}),a.$$set=u=>{"target"in u&&n(2,o=u.target),"sketch"in u&&n(3,t=u.sketch),"parentDivStyle"in u&&n(0,i=u.parentDivStyle),"debug"in u&&n(4,r=u.debug)},[i,c,o,t,r]}class Fe extends Q{constructor(e){super(),J(this,e,Jo,Zo,ee,{target:2,sketch:3,parentDivStyle:0,debug:4})}}const Ee=[{name:"KarlSims",type:"Unknown",f:.055,k:.062},{name:"STX 1",type:"N.A",f:.0353,k:.0614},{name:"STX 2",type:"N.A",f:.0201,k:.0602},{name:"STX 2",type:"N.A",f:.0181,k:.0435},{name:"α 1",type:"alpha",f:.01,k:.047},{name:"α 2",type:"alpha",f:.014,k:.053},{name:"β 1",type:"beta",f:.014,k:.039},{name:"β 2",type:"beta",f:.026,k:.051},{name:"δ 1",type:"delta",f:.03,k:.055},{name:"δ 2",type:"delta",f:.042,k:.059},{name:"ε 1",type:"epsilon",f:.018,k:.055},{name:"ε 2",type:"epsilon",f:.022,k:.059},{name:"η 1",type:"eta",f:.034,k:.063},{name:"γ 1",type:"gamma",f:.022,k:.051},{name:"γ 2",type:"gamma",f:.026,k:.055},{name:"ι 1",type:"iota",f:.046,k:.0594},{name:"κ 1",type:"kappa",f:.082,k:.06},{name:"κ 2",type:"kappa",f:.058,k:.063},{name:"λ 1",type:"lambda",f:.026,k:.061},{name:"λ 2",type:"lambda",f:.034,k:.065},{name:"μ 1",type:"mu",f:.046,k:.065},{name:"μ 2",type:"mu",f:.058,k:.065},{name:"ν 2",type:"nu",f:.046,k:.067},{name:"π 1",type:"pi",f:.062,k:.061},{name:"ρ 1",type:"rho",f:.09,k:.059},{name:"ρ 2",type:"rho",f:.102,k:.055},{name:"σ 1",type:"sigma",f:.09,k:.057},{name:"θ 2",type:"sigma",f:.11,k:.0523},{name:"θ 1",type:"theta",f:.03,k:.057},{name:"θ 2",type:"theta",f:.038,k:.061},{name:"ξ 1",type:"xi",f:.01,k:.041},{name:"ξ 2",type:"xi",f:.014,k:.047},{name:"ζ 1",type:"zeta",f:.022,k:.061},{name:"ζ 2",type:"zeta",f:.026,k:.059}];function zt(a){let e,n,o,t,i,r,s,l,f=a[1].toFixed(2)+"",c,u,p,m,d,g,C,E=a[2].toFixed(2)+"",S,M,v,x;return v=new Fe({props:{sketch:a[4]}}),{c(){e=B("div"),n=R(`Modify the change rate to change how fast the selector walks around the parameters space
            and the change magnitude to change how big each step taken by the selector is.`),o=q(),t=B("div"),i=B("label"),r=R("changeMag"),s=q(),l=B("span"),c=R(f),u=q(),p=B("div"),m=B("label"),d=R("changeRate"),g=q(),C=B("span"),S=R(E),M=q(),N(v.$$.fragment),this.h()},l($){e=z($,"DIV",{});var L=T(e);n=P(L,`Modify the change rate to change how fast the selector walks around the parameters space
            and the change magnitude to change how big each step taken by the selector is.`),L.forEach(h),o=Y($),t=z($,"DIV",{});var D=T(t);i=z(D,"LABEL",{for:!0});var b=T(i);r=P(b,"changeMag"),b.forEach(h),s=Y(D),l=z(D,"SPAN",{id:!0}),T(l).forEach(h),c=P(D,f),D.forEach(h),u=Y($),p=z($,"DIV",{});var V=T(p);m=z(V,"LABEL",{for:!0});var X=T(m);d=P(X,"changeRate"),X.forEach(h),g=Y(V),C=z(V,"SPAN",{id:!0}),T(C).forEach(h),S=P(V,E),V.forEach(h),M=Y($),G(v.$$.fragment,$),this.h()},h(){y(i,"for","changeMag"),y(l,"id","changeMag"),y(m,"for","changeRate"),y(C,"id","changeRate")},m($,L){A($,e,L),w(e,n),A($,o,L),A($,t,L),w(t,i),w(i,r),w(t,s),w(t,l),w(t,c),A($,u,L),A($,p,L),w(p,m),w(m,d),w(p,g),w(p,C),w(p,S),A($,M,L),U(v,$,L),x=!0},p($,L){(!x||L&2)&&f!==(f=$[1].toFixed(2)+"")&&pe(c,f),(!x||L&4)&&E!==(E=$[2].toFixed(2)+"")&&pe(S,E)},i($){x||(_(v.$$.fragment,$),x=!0)},o($){k(v.$$.fragment,$),x=!1},d($){$&&h(e),$&&h(o),$&&h(t),$&&h(u),$&&h(p),$&&h(M),O(v,$)}}}function er(a){let e,n,o=a[0]?"Close":"F/K selection",t,i,r,s,l,f=a[0]&&zt(a);return{c(){e=B("div"),n=B("button"),t=R(o),i=q(),f&&f.c(),this.h()},l(c){e=z(c,"DIV",{id:!0,class:!0});var u=T(e);n=z(u,"BUTTON",{class:!0,id:!0});var p=T(n);t=P(p,o),p.forEach(h),i=Y(u),f&&f.l(u),u.forEach(h),this.h()},h(){y(n,"class","full-width svelte-vk9dfi"),y(n,"id","toggleButton"),y(e,"id","container"),y(e,"class","svelte-vk9dfi"),Ie(e,"no-cursor",a[3])},m(c,u){A(c,e,u),w(e,n),w(n,t),w(e,i),f&&f.m(e,null),r=!0,s||(l=Z(n,"click",a[5]),s=!0)},p(c,[u]){(!r||u&1)&&o!==(o=c[0]?"Close":"F/K selection")&&pe(t,o),c[0]?f?(f.p(c,u),u&1&&_(f,1)):(f=zt(c),f.c(),_(f,1),f.m(e,null)):f&&(oe(),k(f,1,1,()=>{f=null}),re()),(!r||u&8)&&Ie(e,"no-cursor",c[3])},i(c){r||(_(f),r=!0)},o(c){k(f),r=!1},d(c){c&&h(e),f&&f.d(),s=!1,l()}}}function tr(a,e){let n=!1,o=1/0,t=null;for(let i=0;i<e.length;i++){const r=e[i],s=e[(i+1)%e.length];if(a[0]===r[0]&&a[1]===r[1])return a;r[1]>a[1]!=s[1]>a[1]&&a[0]<(s[0]-r[0])*(a[1]-r[1])/(s[1]-r[1])+r[0]&&(n=!n);const f=nr(a,r,s);f<o&&(o=f,t=or(a,r,s))}if(n)return a;if(!t)throw new Error("Now closest point found");return t}function nr(a,e,n){const o=[n[0]-e[0],n[1]-e[1]],t=[a[0]-e[0],a[1]-e[1]],i=o[0]*t[0]+o[1]*t[1],r=o[0]*o[0]+o[1]*o[1],s=i/r;let l;return s<0?l=e:s>1?l=n:l=[e[0]+s*o[0],e[1]+s*o[1]],Math.sqrt((a[0]-l[0])**2+(a[1]-l[1])**2)}function or(a,e,n){const o=[n[0]-e[0],n[1]-e[1]],t=[a[0]-e[0],a[1]-e[1]],i=o[0]*t[0]+o[1]*t[1],r=o[0]*o[0]+o[1]*o[1],s=i/r;let l;return s<0?l=e:s>1?l=n:l=[e[0]+s*o[0],e[1]+s*o[1]],l}function rr(a,e,n){const o=Ge();let t=Ee[0],i=!0,r=1,s=100;const l=[0,.12],f=[.03,.07],c={f:.0433,k:.0621},u=[{f:.1045,k:.0553},{f:.0829,k:.0582},{f:.0664,k:.0595},{f:.0511,k:.0594},{f:.0307,k:.0549},{f:.017,k:.0467},{f:.005,k:.0335},{f:.0076,k:.0472},{f:.0166,k:.0594},{f:.0277,k:.0657},{f:.046,k:.0675},{f:.0757,k:.0643},{f:.0949,k:.0594}],p=b=>{const{f:V,k:X}=b,I=x.map(X,f[0],f[1],0,x.width),F=x.map(V,l[0],l[1],x.height,0);return{x:I,y:F}},m=b=>{const{x:V,y:X}=b,I=x.map(X,x.height,0,l[0],l[1]),F=x.map(V,0,x.width,f[0],f[1]);return{f:I,k:F}},d=b=>{const V=b.mouseX,X=b.mouseY;if(V<0||X<0||V>b.width||X>b.height)return;const{f:I,k:F}=m({x:b.mouseX,y:b.mouseY});t={f:I,k:F,name:"custom",type:"manual"},o("fkupdated",t)},g=b=>{b.noStroke();const V=b.textSize();for(const X of Ee){const{x:I,y:F}=p({f:X.f,k:X.k}),te=X.f===t.f&&X.k===t.k;b.circle(I,F,3),b.textSize(te?V*2:V),b.fill(te?[240,240,150]:[255,255,255]),b.text(X.name,I-b.textWidth(X.name)/2,F-10)}},C=b=>{b.noFill(),b.stroke("red"),b.strokeWeight(1);const{x:V,y:X}=p(t);b.text("F",10,X>10?X-5:X+15),b.line(0,X,b.width,X),b.text("K",V<b.width-10?V+5:V-15,b.height-10),b.line(V,0,V,b.height),b.circle(V,X,10)},E=b=>{const{f:V,k:X}=t,I=`F: ${V.toFixed(4)}`,F=`K: ${X.toFixed(4)}`,te=b.textSize(),xe=b.height*.05;b.textStyle(b.BOLD),b.textSize(xe),b.fill("white"),b.stroke(0),b.strokeWeight(1),b.text(I,b.width*.05,b.textSize()),b.text(F,b.width*.05,b.textSize()+b.textSize()+6),b.textStyle(b.NORMAL),b.textSize(te)},S=b=>{for(let V=0;V<u.length;V++){const{x:X,y:I}=p(u[V]),{x:F,y:te}=p(u[(V+1)%u.length]);b.fill("white"),b.stroke("white"),b.strokeWeight(1),b.circle(X,I,3),b.circle(F,te,3),b.line(X,I,F,te)}},M=()=>{const b=[t.f,t.k],V=u.map(I=>[I.f,I.k]),X=tr(b,V);t.f=X[0],t.k=X[1]},v=()=>{let{f:b,k:V}=t;const X=x.noise(x.frameCount*.01),I=x.noise(5321+x.frameCount*.01),te=Math.random()<.97?.001:.01;b=b+(I*2-1)*(l[1]-l[0])*te*r,V=V+(X*2-1)*(f[1]-f[0])*te*r;const xe={f:b-c.f,k:V-c.k};b=b-xe.f*.001*(r/2),V=V-xe.k*.001*(r/2),t={f:b,k:V,name:"custom",type:"manual"},M(),o("fkupdated",t)};let x,$=!1;const L=b=>{x=b;let V,X,I;b.preload=()=>{V=b.loadImage(Ze+"/parameters_map.png")},b.setup=()=>{b.createCanvas(400,400),b.frameRate(55),X=b.createSlider(0,5,2,0);const F=b.select("#changeMag");if(!F)throw new Error("changeMag slider container not ready");X.parent(F),I=b.createSlider(1,500,100,1);const te=b.select("#changeRate");if(!te)throw new Error("changeRate slider container not ready");I.parent(te)},b.draw=()=>{b.background(255),b.tint(150,190),b.image(V,0,0,b.width,b.height),g(b),S(b),C(b),E(b),b.frameCount%s===0&&v(),n(3,$=!1),b.mouseIsPressed&&(d(b),n(3,$=!0)),n(1,r=Number(X.value())),n(2,s=Number(I.value()))}},D=()=>{n(0,i=!i),i||x.remove()};return ye(()=>x?.remove()),[i,r,s,$,L,D]}let ir=class extends Q{constructor(e){super(),J(this,e,rr,er,ee,{})}};const ar=`precision mediump float;
attribute vec2 position;
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,lr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    gl_FragColor = vec4(A, B, 0.0, 1.0);
}

`,sr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float PI = 3.14159265359;
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = sin(iteration*PI/180.0);
    if (val < 0.0) {
        val = -1.0 * val;
    }
    gl_FragColor = vec4(A, B, val, 1.0);
}
`,fr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (A + B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}

`,cr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(1.0 - val, 1.0 - val, 1.0 - val, 1.0);
}
`,ur=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}
`,pr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    // vec3 color1 = vec3(1.0, 0.0, 0.0);
    // vec3 color2 = vec3(0.0, 1.0, 0.0);
    // vec3 result = color1 * A + color2 * B;

    vec3 color1RGB = vec3(0.639, 0.941, 0.717);
    vec3 color2RGB = vec3(0.929, 0.082, 0.705);

    vec3 color1HSV = rgb2hsv(color1RGB);
    vec3 color2HSV = rgb2hsv(color2RGB);

    float color1Offset = (cos(iteration * 0.001) + 1.0) * 0.5;
    float color1newH = 0.5 * (color1HSV.x + color1Offset);
    vec3 color1newHSV = vec3(color1newH, color1HSV.g, color1HSV.b);

    float color2Offset = (cos(iteration * 0.002)) * 0.5;
    float color2newH = 0.5 * (color2HSV.x + color2Offset + 0.33);
    vec3 color2newHSV = vec3(color2newH, color2HSV.g, color2HSV.b);


    vec3 resultHSV = color1newHSV * A + color2newHSV * B;
    vec3 result = hsv2rgb(resultHSV);

    gl_FragColor = vec4(result, 1.0);
}
`,mr=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float red = A; // The more A the redder
    float blue = 1.0 - A; // The less A the bleuer

    float green = max(A, B) - min(A, B);

    vec3 result = vec3(red, green, blue);

    gl_FragColor = vec4(result, 1.0);
}
`,dr=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec3 color1 = vec3(0.0, 0.0, 1.0);
    vec3 color2 = vec3(1.0, 0.0, 0.0);
    vec3 result = vec3(A, 0.0, 1.0-A);

    gl_FragColor = vec4(result, 1.0);
}
`,hr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    if (A > 0.9) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else if (A > 0.4) {
        gl_FragColor = vec4(1.0 - A, 0.0, 0.0, 1.0);
    } else { 
        gl_FragColor = vec4(0.0, A, 0.0, 1.0);
    }
}
`,vr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);
    vec4 color = mix(blue, red, A);

    vec4 softRed = vec4(0.8588, 0.2824, 0.3765, 1.0);
    vec4 softBlue = vec4(0.2824, 0.3882, 0.8588, 1.0);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.6);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.4);
    vec4 softColor = mix(softBlue, softRed, 1.0-A);


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(color);
    }

}
`,gr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/MATLAB_cool.frag
float colormap_red(float x) {
    return (1.0 + 1.0 / 63.0) * x - 1.0 / 63.0;
}

float colormap_green(float x) {
    return -(1.0 + 1.0 / 63.0) * x + (1.0 + 1.0 / 63.0);
}

vec4 colormap(float x) {
    float r = clamp(colormap_red(x), 0.0, 1.0);
    float g = clamp(colormap_green(x), 0.0, 1.0);
    float b = 1.0;
    return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,xr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/MATLAB_parula.frag
 vec4 colormap(float x) {
    if (x < 0.0) {
        return vec4(0.0, 0.0, 0.0, 0.0);
    } else if (1.0 < x) {
        return vec4(0.0, 0.0, 0.0, 0.0);
    }
    if (x < 3.1250000000000000e-02) {
        float dx = x - 1.5625000000000000e-02;
        return ((vec4(-1.4151576683620706e+02,  2.4271369358056621e+01,  4.5510373586485706e+01, 1.0) * dx
               + vec4( 0.0000000000000000e+00,  0.0000000000000000e+00,  0.0000000000000000e+00, 1.0)) * dx
               + vec4( 2.6007355728658488e-01,  1.4968553250962457e+00,  3.0913652594248364e+00, 1.0)) * dx
               + vec4( 2.0810000000000001e-01,  1.6630000000000000e-01,  5.2920000000000000e-01, 1.0);
    } else if (x < 4.6875000000000000e-02) {
        float dx = x - 3.1250000000000000e-02;
        return ((vec4(-5.1390461057291191e+01,  1.2211762733842230e+01, -1.2843448884986955e+01, 1.0) * dx
               + vec4(-6.6335515704472066e+00,  1.1377204386589042e+00,  2.1332987618665173e+00, 1.0)) * dx
               + vec4( 1.5642431399834725e-01,  1.5146322069502911e+00,  3.1246980525790007e+00, 1.0)) * dx
               + vec4( 2.1162380952380999e-01,  1.8978095238095199e-01,  5.7767619047619101e-01, 1.0);
    } else if (x < 6.2500000000000000e-02) {
        float dx = x - 4.6875000000000000e-02;
        return ((vec4(-1.4725107464858192e+02,  1.3014608277362621e+01,  5.8634219534912217e+00, 1.0) * dx
               + vec4(-9.0424794325077311e+00,  1.7101468168077587e+00,  1.5312620953827538e+00, 1.0)) * dx
               + vec4(-8.8513670422823654e-02,  1.5591301328169576e+00,  3.1819568159735203e+00, 1.0)) * dx
               + vec4( 2.1225238095238100e-01,  2.1377142857142900e-01,  6.2697142857142896e-01, 1.0);
    } else if (x < 7.8125000000000000e-02) {
        float dx = x - 6.2500000000000000e-02;
        return ((vec4(-2.1469400225321081e+02, -1.4338005366630648e+01, -4.1817857976177763e+01, 1.0) * dx
               + vec4(-1.5944873556660008e+01,  2.3202065798091316e+00,  1.8061099994526548e+00, 1.0)) * dx
               + vec4(-4.7894106087856969e-01,  1.6221044046390967e+00,  3.2341032549553237e+00, 1.0)) * dx
               + vec4( 2.0810000000000001e-01,  2.3860000000000001e-01,  6.7708571428571396e-01, 1.0);
    } else if (x < 9.3750000000000000e-02) {
        float dx = x - 7.8125000000000000e-02;
        return ((vec4(-2.8846495443400278e+02,  2.0037550842697090e+02,  1.1771734328417965e+02, 1.0) * dx
               + vec4(-2.6008654912279265e+01,  1.6481125782483199e+00, -1.5410209318067788e-01, 1.0)) * dx
               + vec4(-1.1344649432057459e+00,  1.6841093914837442e+00,  3.2599158784908235e+00, 1.0)) * dx
               + vec4( 1.9590476190476200e-01,  2.6445714285714300e-01,  7.2789999999999999e-01, 1.0);
    } else if (x < 1.0937500000000000e-01) {
        float dx = x - 9.3750000000000000e-02;
        return ((vec4(-5.4509738001026233e+02,  5.1696771659011155e+01, -6.5374637230314454e+02, 1.0) * dx
               + vec4(-3.9530449651373146e+01,  1.1040714535762580e+01,  5.3638983732652425e+00, 1.0)) * dx
               + vec4(-2.1585134520128149e+00,  1.8823723151401646e+00,  3.3413189453671448e+00, 1.0)) * dx
               + vec4( 1.7072857142857101e-01,  2.9193809523809500e-01,  7.7924761904761897e-01, 1.0);
    } else if (x < 1.2500000000000000e-01) {
        float dx = x - 1.0937500000000000e-01;
        return ((vec4( 2.3639968744743715e+03, -8.1036503315845437e+02, -8.1573269216733058e+02, 1.0) * dx
               + vec4(-6.5081889339354191e+01,  1.3464000707278728e+01, -2.5280462828444659e+01, 1.0)) * dx
               + vec4(-3.7930812487429293e+00,  2.2652584908126849e+00,  3.0301226257549660e+00, 1.0)) * dx
               + vec4( 1.2527142857142901e-01,  3.2424285714285700e-01,  8.3027142857142899e-01, 1.0);
    } else if (x < 1.4062500000000000e-01) {
        float dx = x - 1.2500000000000000e-01;
        return ((vec4( 1.4125902630655582e+03,  2.5375056097507152e+02,  9.0826266478267496e+02, 1.0) * dx
               + vec4( 4.5730464151631985e+01, -2.4521860222023822e+01, -6.3517932773788282e+01, 1.0)) * dx
               + vec4(-4.0954472673010889e+00,  2.0924794358947931e+00,  1.6426476944700765e+00, 1.0)) * dx
               + vec4( 5.9133333333333399e-02,  3.5983333333333301e-01,  8.6833333333333296e-01, 1.0);
    } else if (x < 1.5625000000000000e-01) {
        float dx = x - 1.4062500000000000e-01;
        return ((vec4(-1.9850459267366693e+03,  1.4738473211499172e+02,  2.4976683303608979e+02, 1.0) * dx
               + vec4( 1.1194563273283002e+02, -1.2627302676317344e+01, -2.0943120362100398e+01, 1.0)) * dx
               + vec4(-1.6317582534813697e+00,  1.5120237656082123e+00,  3.2294373922181602e-01, 1.0)) * dx
               + vec4( 1.1695238095238101e-02,  3.8750952380952403e-01,  8.8195714285714299e-01, 1.0);
    } else if (x < 1.7187500000000000e-01) {
        float dx = x - 1.5625000000000000e-01;
        return ((vec4(-1.3211246088080517e+02,  6.1731462945951478e+01,  9.6199145930320853e+01, 1.0) * dx
               + vec4( 1.8896604917048652e+01, -5.7186433584271068e+00, -9.2353000635336890e+00, 1.0)) * dx
               + vec4( 4.1265170979798449e-01,  1.2253683588153301e+00, -1.4859407992871662e-01, 1.0)) * dx
               + vec4( 5.9571428571428596e-03,  4.0861428571428599e-01,  8.8284285714285704e-01, 1.0);
    } else if (x < 1.8750000000000000e-01) {
        float dx = x - 1.7187500000000000e-01;
        return ((vec4(-2.4276114402580023e+02,  1.8878292291818184e+01,  5.4500811814199913e+01, 1.0) * dx
               + vec4( 1.2703833313260910e+01, -2.8249810328356313e+00, -4.7259650980498993e+00, 1.0)) * dx
               + vec4( 9.0640855714657143e-01,  1.0918742277018498e+00, -3.6673884807846019e-01, 1.0)) * dx
               + vec4( 1.6514285714285700e-02,  4.2659999999999998e-01,  8.7863333333333304e-01, 1.0);
    } else if (x < 2.0312500000000000e-01) {
        float dx = x - 1.8750000000000000e-01;
        return ((vec4(-2.4875702015890445e+02,  2.7531596458333780e+01,  1.1605149669749400e+01, 1.0) * dx
               + vec4( 1.3244046870515243e+00, -1.9400610816566539e+00, -2.1712395442592785e+00, 1.0)) * dx
               + vec4( 1.1255997759014531e+00,  1.0174204446629080e+00, -4.7450767061454108e-01, 1.0)) * dx
               + vec4( 3.2852380952381001e-02,  4.4304285714285702e-01,  8.7195714285714299e-01, 1.0);
    } else if (x < 2.1875000000000000e-01) {
        float dx = x - 2.0312500000000000e-01;
        return ((vec4( 6.6879357994795782e+01,  3.3156266362545779e+00,  3.1398894268734253e+01, 1.0) * dx
               + vec4(-1.0336080632897122e+01, -6.4951749767225808e-01, -1.6272481534897754e+00, 1.0)) * dx
               + vec4( 9.8479233924761567e-01,  9.7695827936089374e-01, -5.3385904089187008e-01, 1.0)) * dx
               + vec4( 4.9814285714285700e-02,  4.5857142857142902e-01,  8.6405714285714297e-01, 1.0);
    } else if (x < 2.3437500000000000e-01) {
        float dx = x - 2.1875000000000000e-01;
        return ((vec4(-3.7807546774099214e+00,  2.9110963663947160e+01,  2.0085673255558202e+01, 1.0) * dx
               + vec4(-7.2011107268910699e+00, -4.9409749909782474e-01, -1.5542498464285720e-01, 1.0)) * dx
               + vec4( 7.1077372425092522e-01,  9.5908929503636120e-01, -5.6171330867519242e-01, 1.0)) * dx
               + vec4( 6.2933333333333299e-02,  4.7369047619047600e-01,  8.5543809523809500e-01, 1.0);
    } else if (x < 2.5000000000000000e-01) {
        float dx = x - 2.3437500000000000e-01;
        return ((vec4(-1.8052110713761824e+01,  7.5676044216235097e+00,  2.6820241280346455e+01, 1.0) * dx
               + vec4(-7.3783336023946600e+00,  8.7047892264969851e-01,  7.8609094921143352e-01, 1.0)) * dx
               + vec4( 4.8296990660583561e-01,  9.6497025477935916e-01, -5.5185915297880839e-01, 1.0)) * dx
               + vec4( 7.2266666666666701e-02,  4.8866666666666703e-01,  8.4670000000000001e-01, 1.0);
    } else if (x < 2.6562500000000000e-01) {
        float dx = x - 2.5000000000000000e-01;
        return ((vec4(-8.5042116753280467e+01,  3.9234694840689350e+01,  6.3623990194130904e+01, 1.0) * dx
               + vec4(-8.2245262921022455e+00,  1.2252103799133005e+00,  2.0432897592276738e+00, 1.0)) * dx
               + vec4( 2.3917522075432149e-01,  9.9771540013190607e-01, -5.0765007940944740e-01, 1.0)) * dx
               + vec4( 7.7942857142857203e-02,  5.0398571428571404e-01,  8.3837142857142899e-01, 1.0);
    } else if (x < 2.8125000000000000e-01) {
        float dx = x - 2.6562500000000000e-01;
        return ((vec4(-4.4981860368289709e+01,  3.5222378119677195e+01,  1.8276940800992332e+01, 1.0) * dx
               + vec4(-1.2210875514912267e+01,  3.0643367005706139e+00,  5.0256642995775600e+00, 1.0)) * dx
               + vec4(-8.0127932480280273e-02,  1.0647395732644671e+00, -3.9719767224061564e-01, 1.0)) * dx
               + vec4( 7.9347619047619000e-02,  5.2002380952381000e-01,  8.3118095238095202e-01, 1.0);
    } else if (x < 2.9687500000000000e-01) {
        float dx = x - 2.8125000000000000e-01;
        return ((vec4( 8.8958586797831074e+01, -6.4031864461777545e+01, -5.4343639113056135e+01, 1.0) * dx
               + vec4(-1.4319400219675847e+01,  4.7153856749304826e+00,  5.8823958996240755e+00, 1.0)) * dx
               + vec4(-4.9466349083321959e-01,  1.1862977353816719e+00, -2.2675923162809006e-01, 1.0)) * dx
               + vec4( 7.4942857142857103e-02,  5.3754285714285699e-01,  8.2627142857142899e-01, 1.0);
    } else if (x < 3.1250000000000000e-01) {
        float dx = x - 2.9687500000000000e-01;
        return ((vec4( 2.3465669412937996e+02, -7.4943148843863256e+01, -1.7040059387215410e+02, 1.0) * dx
               + vec4(-1.0149466463527515e+01,  1.7138920282846606e+00,  3.3350378161995691e+00, 1.0)) * dx
               + vec4(-8.7698953275827207e-01,  1.2867551994944084e+00, -8.2736829818345611e-02, 1.0)) * dx
               + vec4( 6.4057142857142799e-02,  5.5698571428571397e-01,  8.2395714285714305e-01, 1.0);
    } else if (x < 3.2812500000000000e-01) {
        float dx = x - 3.1250000000000000e-01;
        return ((vec4( 3.5054309382746595e+02, -7.5598816353949772e+01, -5.9224118732067950e+01, 1.0) * dx
               + vec4( 8.5006607378717081e-01, -1.7990680737714295e+00, -4.6524900215576546e+00, 1.0)) * dx
               + vec4(-1.0222926638479650e+00,  1.2854243237836778e+00, -1.0332202052706571e-01, 1.0)) * dx
               + vec4( 4.8771428571428597e-02,  5.7722380952381003e-01,  8.2282857142857202e-01, 1.0);
    } else if (x < 3.4375000000000000e-01) {
        float dx = x - 3.2812500000000000e-01;
        return ((vec4(-1.3511844086782639e+02,  2.1571557117596814e+01,  6.5912402293741552e+00, 1.0) * dx
               + vec4( 1.7281773596949638e+01, -5.3427625903628249e+00, -7.4286205871233397e+00, 1.0)) * dx
               + vec4(-7.3898266899270237e-01,  1.1738332196565799e+00, -2.9208937378770627e-01, 1.0)) * dx
               + vec4( 3.4342857142857203e-02,  5.9658095238095199e-01,  8.1985238095238100e-01, 1.0);
    } else if (x < 3.5937500000000000e-01) {
        float dx = x - 3.4375000000000000e-01;
        return ((vec4(-1.6458788273706924e+02,  1.0533768835542057e+01,  3.0362548290707878e+01, 1.0) * dx
               + vec4( 1.0948096681270275e+01, -4.3315958504754741e+00, -7.1196562013714262e+00, 1.0)) * dx
               + vec4(-2.9789094589551629e-01,  1.0226713690184817e+00, -5.1940619860793691e-01, 1.0)) * dx
               + vec4( 2.6499999999999999e-02,  6.1370000000000002e-01,  8.1350000000000000e-01, 1.0);
    } else if (x < 3.7500000000000000e-01) {
        float dx = x - 3.5937500000000000e-01;
        return ((vec4(-1.0406115199344315e+02,  1.9929786587720105e+01,  3.6734795179105028e+01, 1.0) * dx
               + vec4( 3.2330396779701545e+00, -3.8378254363094402e+00, -5.6964117502444944e+00, 1.0)) * dx
               + vec4(-7.6310690282384588e-02,  8.9502416141246732e-01, -7.1965726035193567e-01, 1.0)) * dx
               + vec4( 2.3890476190476202e-02,  6.2866190476190498e-01,  8.0376190476190501e-01, 1.0);
    } else if (x < 3.9062500000000000e-01) {
        float dx = x - 3.7500000000000000e-01;
        return ((vec4( 2.3255546213942225e+02,  1.8349599099637384e+01,  1.7433813849989207e+01, 1.0) * dx
               + vec4(-1.6448268217224928e+00, -2.9036166900100602e+00, -3.9744682262239461e+00, 1.0)) * dx
               + vec4(-5.1494864403514876e-02,  7.8968912818872505e-01, -8.7076475998425507e-01, 1.0)) * dx
               + vec4( 2.3090476190476199e-02,  6.4178571428571396e-01,  7.9126666666666701e-01, 1.0);
    } else if (x < 4.0625000000000000e-01) {
        float dx = x - 3.9062500000000000e-01;
        return ((vec4( 1.5126193200717549e+02,  2.0267550346934740e+01,  2.0857035135376179e+01, 1.0) * dx
               + vec4( 9.2562104660629245e+00, -2.0434792322145579e+00, -3.1572582020057021e+00, 1.0)) * dx
               + vec4( 6.7433005039304356e-02,  7.1239075440396538e-01, -9.8219798542534331e-01, 1.0)) * dx
               + vec4( 2.2771428571428599e-02,  6.5348571428571400e-01,  7.7675714285714303e-01, 1.0);
    } else if (x < 4.2187500000000000e-01) {
        float dx = x - 4.0625000000000000e-01;
        return ((vec4( 1.0861181935568159e+02, -5.7969433444380156e+00,  3.9956456082908054e+00, 1.0) * dx
               + vec4( 1.6346613528899276e+01, -1.0934378097019919e+00, -2.1795846800349437e+00, 1.0)) * dx
               + vec4( 4.6747712996058871e-01,  6.6337642562401933e-01, -1.0655861554572283e+00, 1.0)) * dx
               + vec4( 2.6661904761904800e-02,  6.6419523809523795e-01,  7.6071904761904796e-01, 1.0);
    } else if (x < 4.3750000000000000e-01) {
        float dx = x - 4.2187500000000000e-01;
        return ((vec4(-3.0484063800132168e+02,  1.4154965887634640e+01, -3.1353889969814710e+00, 1.0) * dx
               + vec4( 2.1437792561196851e+01, -1.3651695289725239e+00, -1.9922887921463122e+00, 1.0)) * dx
               + vec4( 1.0578584751183406e+00,  6.2496068595722998e-01, -1.1307716784600605e+00, 1.0)) * dx
               + vec4( 3.8371428571428598e-02,  6.7427142857142897e-01,  7.4355238095238096e-01, 1.0);
    } else if (x < 4.5312500000000000e-01) {
        float dx = x - 4.3750000000000000e-01;
        return ((vec4( 1.9732370744832981e+01, -3.3873392535419122e+00, -5.1854420010455629e+00, 1.0) * dx
               + vec4( 7.1483876548848961e+00, -7.0165550298965007e-01, -2.1392601513798186e+00, 1.0)) * dx
               + vec4( 1.5045175409946179e+00,  5.9266654483282100e-01, -1.1953271307026563e+00, 1.0)) * dx
               + vec4( 5.8971428571428598e-02,  6.8375714285714295e-01,  7.2538571428571397e-01, 1.0);
    } else if (x < 4.6875000000000000e-01) {
        float dx = x - 4.5312500000000000e-01;
        return ((vec4(-5.2460806882781675e+01, -6.0560887320505685e-01,  1.3890718905419471e+01, 1.0) * dx
               + vec4( 8.0733425335489422e+00, -8.6043703049942721e-01, -2.3823277451788294e+00, 1.0)) * dx
               + vec4( 1.7423570751888966e+00,  5.6825884899705426e-01, -1.2659769415863851e+00, 1.0)) * dx
               + vec4( 8.4300000000000000e-02,  6.9283333333333297e-01,  7.0616666666666705e-01, 1.0);
    } else if (x < 4.8437500000000000e-01) {
        float dx = x - 4.6875000000000000e-01;
        return ((vec4( 1.0354971072183483e+01,  5.8097747460711062e+00, -5.4384621916749820e+00, 1.0) * dx
               + vec4( 5.6142422109185510e+00, -8.8882494643091425e-01, -1.7312002964872917e+00, 1.0)) * dx
               + vec4( 1.9562255868212013e+00,  5.4092663060751767e-01, -1.3302508172374183e+00, 1.0)) * dx
               + vec4( 1.1329523809523800e-01,  7.0150000000000001e-01,  6.8585714285714305e-01, 1.0);
    } else if (x < 5.0000000000000000e-01) {
        float dx = x - 4.8437500000000000e-01;
        return ((vec4(-1.3925172644537971e+01, -8.9021377300786071e+00, -4.6199177582688593e+00, 1.0) * dx
               + vec4( 6.0996314799271518e+00, -6.1649175520883115e-01, -1.9861282117220564e+00, 1.0)) * dx
               + vec4( 2.1392548632406654e+00,  5.1740605714439658e-01, -1.3883340751781894e+00, 1.0)) * dx
               + vec4( 1.4527142857142900e-01,  7.0975714285714298e-01,  6.6462857142857201e-01, 1.0);
    } else if (x < 5.1562500000000000e-01) {
        float dx = x - 5.0000000000000000e-01;
        return ((vec4( 3.1614367125520630e+01, -1.1395280968671647e+01,  2.1421523701702025e+01, 1.0) * dx
               + vec4( 5.4468890122144344e+00, -1.0337794613062659e+00, -2.2026868566409092e+00, 1.0)) * dx
               + vec4( 2.3196692459303776e+00,  4.9162056938634824e-01, -1.4537843106213608e+00, 1.0)) * dx
               + vec4( 1.8013333333333301e-01,  7.1765714285714299e-01,  6.4243333333333297e-01, 1.0);
    } else if (x < 5.3125000000000000e-01) {
        float dx = x - 5.1562500000000000e-01;
        return ((vec4(-3.7634010143333590e+01,  2.0544616050328934e+00,  1.3219372364175872e+00, 1.0) * dx
               + vec4( 6.9288124712232140e+00, -1.5679332567127493e+00, -1.1985529331236269e+00, 1.0)) * dx
               + vec4( 2.5130395816090907e+00,  4.5096880816730112e-01, -1.5069286823364316e+00, 1.0)) * dx
               + vec4( 2.1782857142857101e-01,  7.2504285714285699e-01,  6.1926190476190501e-01, 1.0);
    } else if (x < 5.4687500000000000e-01) {
        float dx = x - 5.3125000000000000e-01;
        return ((vec4( 1.2815768685879013e+01, -1.4298832118473902e+01,  3.9450879734146490e+01, 1.0) * dx
               + vec4( 5.1647182457544520e+00, -1.4716303689768324e+00, -1.1365871251665525e+00, 1.0)) * dx
               + vec4( 2.7020009990618670e+00,  4.0347562651590141e-01, -1.5434152457472157e+00, 1.0)) * dx
               + vec4( 2.5864285714285701e-01,  7.3171428571428598e-01,  5.9542857142857097e-01, 1.0);
    } else if (x < 5.6250000000000000e-01) {
        float dx = x - 5.4687500000000000e-01;
        return ((vec4(-7.8540912219456771e+01, -1.8509114083431125e+01,  3.3113477160250433e+01, 1.0) * dx
               + vec4( 5.7654574029050307e+00, -2.1418881245302965e+00,  7.1267286237156402e-01, 1.0)) * dx
               + vec4( 2.8727849935721714e+00,  3.4701440005485251e-01, -1.5500389061033872e+00, 1.0)) * dx
               + vec4( 3.0217142857142898e-01,  7.3760476190476199e-01,  5.7118571428571396e-01, 1.0);
    } else if (x < 5.7812500000000000e-01) {
        float dx = x - 5.6250000000000000e-01;
        return ((vec4(-5.8163891236508938e+01,  9.6920884524980497e+00,  3.0320583052976861e+01, 1.0) * dx
               + vec4( 2.0838521426179946e+00, -3.0095028471911305e+00,  2.2648671042583031e+00, 1.0)) * dx
               + vec4( 2.9954304552209687e+00,  2.6652391612170523e-01, -1.5035148441247956e+00, 1.0)) * dx
               + vec4( 3.4816666666666701e-01,  7.4243333333333295e-01,  5.4726666666666701e-01, 1.0);
    } else if (x < 5.9375000000000000e-01) {
        float dx = x - 5.7812500000000000e-01;
        return ((vec4(-6.4543256167712116e+01, -2.8636353652780144e-01,  2.8905906284068501e+00, 1.0) * dx
               + vec4(-6.4258025909336181e-01, -2.5551862009802844e+00,  3.6861444348665935e+00, 1.0)) * dx
               + vec4( 3.0179503284010409e+00,  1.7957564974402687e-01, -1.4105302888259692e+00, 1.0)) * dx
               + vec4( 3.9525714285714297e-01,  7.4590000000000001e-01,  5.2444285714285699e-01, 1.0);
    } else if (x < 6.0937500000000000e-01) {
        float dx = x - 5.9375000000000000e-01;
        return ((vec4(-2.4450284092939786e+01,  1.3922851408411924e+01, -1.6916850328844372e+01, 1.0) * dx
               + vec4(-3.6680453919548675e+00, -2.5686094917550251e+00,  3.8216408705731646e+00, 1.0)) * dx
               + vec4( 2.9505968026034126e+00,  9.9516342045037676e-02, -1.2932211434284731e+00, 1.0)) * dx
               + vec4( 4.4200952380952402e-01,  7.4808095238095196e-01,  5.0331428571428605e-01, 1.0);
    } else if (x < 6.2500000000000000e-01) {
        float dx = x - 6.0937500000000000e-01;
        return ((vec4( 1.2547821111311350e+01,  1.5748329330961459e+01, -1.7611303598786566e+01, 1.0) * dx
               + vec4(-4.8141524588114200e+00, -1.9159758319857161e+00,  3.0286635114085847e+00, 1.0)) * dx
               + vec4( 2.8180624611851890e+00,  2.9444696361588602e-02, -1.1861851374600081e+00, 1.0)) * dx
               + vec4( 4.8712380952380901e-01,  7.4906190476190504e-01,  4.8397619047619100e-01, 1.0);
    } else if (x < 6.4062500000000000e-01) {
        float dx = x - 6.2500000000000000e-01;
        return ((vec4( 9.2115329809656430e+00, -3.2661877796437579e+00, -1.2675733711774058e+00, 1.0) * dx
               + vec4(-4.2259733442187004e+00, -1.1777728945968977e+00,  2.2031336552154643e+00, 1.0)) * dx
               + vec4( 2.6768104955128438e+00, -1.8895127491264742e-02, -1.1044383067315073e+00, 1.0)) * dx
               + vec4( 5.3002857142857096e-01,  7.4911428571428595e-01,  4.6611428571428598e-01, 1.0);
    } else if (x < 6.5625000000000000e-01) {
        float dx = x - 6.4062500000000000e-01;
        return ((vec4( 1.4269589821681299e+01,  7.3028598827757278e+00, -8.5260219639800940e+00, 1.0) * dx
               + vec4(-3.7941827357359359e+00, -1.3308754467676989e+00,  2.1437161534415234e+00, 1.0)) * dx
               + vec4( 2.5514955567635522e+00, -5.8092757825086563e-02, -1.0365187784712420e+00, 1.0)) * dx
               + vec4( 5.7085714285714295e-01,  7.4851904761904797e-01,  4.4939047619047601e-01, 1.0);
    } else if (x < 6.7187500000000000e-01) {
        float dx = x - 6.5625000000000000e-01;
        return ((vec4( 8.6083934467238432e+00,  2.6914824850885094e-01, -1.7057138772896455e+01, 1.0) * dx
               + vec4(-3.1252957128446250e+00, -9.8855388976258662e-01,  1.7440588738799565e+00, 1.0)) * dx
               + vec4( 2.4433787060044811e+00, -9.4333841208372265e-02, -9.7577229366934382e-01, 1.0)) * dx
               + vec4( 6.0985238095238103e-01,  7.4731428571428604e-01,  4.3368571428571401e-01, 1.0);
    } else if (x < 6.8750000000000000e-01) {
        float dx = x - 6.7187500000000000e-01;
        return ((vec4( 8.7188554392023345e+00,  1.7834947123447904e+01, -1.8886229447019101e+00, 1.0) * dx
               + vec4(-2.7217772700294449e+00, -9.7593756561373424e-01,  9.4450549390043514e-01, 1.0)) * dx
               + vec4( 2.3520181906470738e+00, -1.2502902019862727e-01, -9.3376347542277516e-01, 1.0)) * dx
               + vec4( 6.4729999999999999e-01,  7.4560000000000004e-01,  4.1880000000000001e-01, 1.0);
    } else if (x < 7.0312500000000000e-01) {
        float dx = x - 6.8750000000000000e-01;
        return ((vec4( 8.9449847961700044e+00, -2.1676746266635202e+01, -4.0993789718798466e+00, 1.0) * dx
               + vec4(-2.3130809213168355e+00, -1.3992441920211368e-01,  8.5597629336753311e-01, 1.0)) * dx
               + vec4( 2.2733485314072883e+00, -1.4246436371137491e-01, -9.0563094749671313e-01, 1.0)) * dx
               + vec4( 6.8341904761904804e-01,  7.4347619047619096e-01,  4.0443333333333298e-01, 1.0);
    } else if (x < 7.1875000000000000e-01) {
        float dx = x - 7.0312500000000000e-01;
        return ((vec4( 1.1674919661892304e+01,  2.3933066515154213e+01, -1.1673175453308831e+01, 1.0) * dx
               + vec4(-1.8937847589963666e+00, -1.1560219004506387e+00,  6.6381790406066532e-01, 1.0)) * dx
               + vec4( 2.2076162551523946e+00, -1.6271352495594915e-01, -8.8188416316189755e-01, 1.0)) * dx
               + vec4( 7.1840952380952405e-01,  7.4113333333333298e-01,  3.9047619047618998e-01, 1.0);
    } else if (x < 7.3437500000000000e-01) {
        float dx = x - 7.1875000000000000e-01;
        return ((vec4(-4.4641682053710623e+00,  2.0910706819426692e+00,  4.6048045942407727e+00, 1.0) * dx
               + vec4(-1.3465228998451648e+00, -3.4159407552784897e-02,  1.1663780468681384e-01, 1.0)) * dx
               + vec4( 2.1569864479829954e+00, -1.8131010789350266e-01, -8.6968954271271826e-01, 1.0)) * dx
               + vec4( 7.5248571428571398e-01,  7.3839999999999995e-01,  3.7681428571428599e-01, 1.0);
    } else if (x < 7.5000000000000000e-01) {
        float dx = x - 7.3437500000000000e-01;
        return ((vec4( 1.2423276968973711e+01, -6.0829492432479162e+00, -2.1725700066572116e+01, 1.0) * dx
               + vec4(-1.5557807844719334e+00,  6.3859530663277708e-02,  3.3248802004185007e-01, 1.0)) * dx
               + vec4( 2.1116379529155407e+00, -1.8084604346990121e-01, -8.6267195170133282e-01, 1.0)) * dx
               + vec4( 7.8584285714285695e-01,  7.3556666666666704e-01,  3.6327142857142902e-01, 1.0);
    } else if (x < 7.6562500000000000e-01) {
        float dx = x - 7.5000000000000000e-01;
        return ((vec4( 3.4549460436900552e+00,  2.2240726291601970e+01, -7.5799471847609725e+00, 1.0) * dx
               + vec4(-9.7343967655129060e-01, -2.2127871511396835e-01, -6.8590417057871789e-01, 1.0)) * dx
               + vec4( 2.0721188832120530e+00, -1.8330571822694325e-01, -8.6819407905347146e-01, 1.0)) * dx
               + vec4( 8.1850476190476196e-01,  7.3273333333333301e-01,  3.4979047619047599e-01, 1.0);
    } else if (x < 7.8125000000000000e-01) {
        float dx = x - 7.6562500000000000e-01;
        return ((vec4( 8.7094721894791203e+00,  1.3239510743088688e+01, -2.2852796908624047e+01, 1.0) * dx
               + vec4(-8.1148908075331927e-01,  8.2125532980487381e-01, -1.0412141948643885e+00, 1.0)) * dx
               + vec4( 2.0442293713791684e+00, -1.7393108362239784e-01, -8.9518030351351996e-01, 1.0)) * dx
               + vec4( 8.5065714285714300e-01,  7.2989999999999999e-01,  3.3602857142857101e-01, 1.0);
    } else if (x < 7.9687500000000000e-01) {
        float dx = x - 7.8125000000000000e-01;
        return ((vec4(-1.2078434801289291e+01,  4.3390183117236198e+01, -3.9570693752303733e+01, 1.0) * dx
               + vec4(-4.0323257187148548e-01,  1.4418573958871561e+00, -2.1124390499561407e+00, 1.0)) * dx
               + vec4( 2.0252493455569058e+00, -1.3856994728345987e-01, -9.4445613546384066e-01, 1.0)) * dx
               + vec4( 8.8243333333333296e-01,  7.2743333333333304e-01,  3.2169999999999999e-01, 1.0);
    } else if (x < 8.1250000000000000e-01) {
        float dx = x - 7.9687500000000000e-01;
        return ((vec4(-1.2824532984374384e+01,  1.1653781393088177e+02, -1.1096774236821523e+02, 1.0) * dx
               + vec4(-9.6940920318192092e-01,  3.4757722295076028e+00, -3.9673153195953783e+00, 1.0)) * dx
               + vec4( 2.0038018178216963e+00, -6.1731984386666772e-02, -1.0394522974880831e+00, 1.0)) * dx
               + vec4( 9.1393333333333304e-01,  7.2578571428571403e-01,  3.0627619047619098e-01, 1.0);
    } else if (x < 8.2812500000000000e-01) {
        float dx = x - 8.1250000000000000e-01;
        return ((vec4(-3.5855044278532131e+02,  2.7064903734930277e+02, -8.0792089155266083e+01, 1.0) * dx
               + vec4(-1.5705591868244702e+00,  8.9384822575176859e+00, -9.1689282431054675e+00, 1.0)) * dx
               + vec4( 1.9641148117278464e+00,  1.3224074197310332e-01, -1.2447061031552840e+00, 1.0)) * dx
               + vec4( 9.4495714285714305e-01,  7.2611428571428605e-01,  2.8864285714285698e-01, 1.0);
    } else if (x < 8.4375000000000000e-01) {
        float dx = x - 8.2812500000000000e-01;
        return ((vec4(-3.8174017206443654e+02, -1.9549693475620506e+02,  4.4911575613188438e+02, 1.0) * dx
               + vec4(-1.8377611192386407e+01,  2.1625155883266252e+01, -1.2956057422258565e+01, 1.0)) * dx
               + vec4( 1.6524246495526764e+00,  6.0979758792285232e-01, -1.5904090041765968e+00, 1.0)) * dx
               + vec4( 9.7389523809523804e-01,  7.3139523809523799e-01,  2.6664761904761902e-01, 1.0);
    } else if (x < 8.5937500000000000e-01) {
        float dx = x - 8.4375000000000000e-01;
        return ((vec4( 4.3248438818547703e+02, -2.7134838403902307e+02,  3.3204036056432756e+01, 1.0) * dx
               + vec4(-3.6271681757906869e+01,  1.2461237066569140e+01,  8.0962436464235150e+00, 1.0)) * dx
               + vec4( 7.9852944720434427e-01,  1.1423974777640304e+00, -1.6663435944240195e+00, 1.0)) * dx
               + vec4( 9.9377142857142897e-01,  7.4545714285714304e-01,  2.4034761904761900e-01, 1.0);
    } else if (x < 8.7500000000000000e-01) {
        float dx = x - 8.5937500000000000e-01;
        return ((vec4( 1.7847934313241271e+02, -6.1117386114828536e+00, -1.0882439559595376e+02, 1.0) * dx
               + vec4(-1.5998976061712632e+01, -2.5821843526006538e-01,  9.6526828365688004e+00, 1.0)) * dx
               + vec4(-1.8199581227210410e-02,  1.3330696438782346e+00, -1.3890166181272647e+00, 1.0)) * dx
               + vec4( 9.9904285714285701e-01,  7.6531428571428595e-01,  2.1641428571428600e-01, 1.0);
    } else if (x < 8.9062500000000000e-01) {
        float dx = x - 8.7500000000000000e-01;
        return ((vec4( 1.0065469642774150e+02,  1.1181852770679304e+01, -4.2302948910418884e+01, 1.0) * dx
               + vec4(-7.6327568523807861e+00, -5.4470618267332416e-01,  4.5515392930084682e+00, 1.0)) * dx
               + vec4(-3.8744540800992006e-01,  1.3205239467230254e+00, -1.1670756473526198e+00, 1.0)) * dx
               + vec4( 9.9553333333333305e-01,  7.8605714285714301e-01,  1.9665238095238100e-01, 1.0);
    } else if (x < 9.0625000000000000e-01) {
        float dx = x - 8.9062500000000000e-01;
        return ((vec4( 5.1792385442186948e+01,  1.3813127528788970e+01, -4.7771351619749993e+01, 1.0) * dx
               + vec4(-2.9145679573304033e+00, -2.0556834047731776e-02,  2.5685885628325829e+00, 1.0)) * dx
               + vec4(-5.5224735816165738e-01,  1.3116917120867588e+00, -1.0558236496051034e+00, 1.0)) * dx
               + vec4( 9.8799999999999999e-01,  8.0659999999999998e-01,  1.7936666666666701e-01, 1.0);
    } else if (x < 9.2187500000000000e-01) {
        float dx = x - 9.0625000000000000e-01;
        return ((vec4( 1.1035785704157649e+02,  5.2154589495154021e+01, -3.9990387467675163e+01, 1.0) * dx
               + vec4(-4.8679988972789023e-01,  6.2693351886425119e-01,  3.2930645565680206e-01, 1.0)) * dx
               + vec4(-6.0539373077194325e-01,  1.3211663477870170e+00, -1.0105440399412067e+00, 1.0)) * dx
               + vec4( 9.7885714285714298e-01,  8.2714285714285696e-01,  1.6331428571428599e-01, 1.0);
    } else if (x < 9.3750000000000000e-01) {
        float dx = x - 9.2187500000000000e-01;
        return ((vec4( 4.6043843534396274e+01,  2.0987943062129727e+01, -2.3203479461840441e+01, 1.0) * dx
               + vec4( 4.6862246590960082e+00,  3.0716799014495959e+00, -1.5452429568904713e+00, 1.0)) * dx
               + vec4(-5.3977771875056635e-01,  1.3789571824794209e+00, -1.0295430477729828e+00, 1.0)) * dx
               + vec4( 9.6970000000000001e-01,  8.4813809523809502e-01,  1.4745238095238100e-01, 1.0);
    } else if (x < 9.5312500000000000e-01) {
        float dx = x - 9.3750000000000000e-01;
        return ((vec4( 6.1233625963980650e+01,  2.8669866827404956e+01,  2.4201791029260814e+01, 1.0) * dx
               + vec4( 6.8445298247708335e+00,  4.0554897324869268e+00, -2.6329060566642419e+00, 1.0)) * dx
               + vec4(-3.5960967994014698e-01,  1.4903192080096790e+00, -1.0948266261097752e+00, 1.0)) * dx
               + vec4( 9.6258571428571404e-01,  8.7051428571428602e-01,  1.3089999999999999e-01, 1.0);
    } else if (x < 9.6875000000000000e-01) {
        float dx = x - 9.5312500000000000e-01;
        return ((vec4( 4.1070719275903762e+01,  5.3910277236601019e+00,  2.0019172487757277e+01, 1.0) * dx
               + vec4( 9.7148560418324266e+00,  5.3993897400215340e+00, -1.4984471021676413e+00, 1.0)) * dx
               + vec4(-1.0086927577447102e-01,  1.6380516997676238e+00, -1.1593790192165234e+00, 1.0)) * dx
               + vec4( 9.5887142857142904e-01,  8.9490000000000003e-01,  1.1324285714285701e-01, 1.0);
    } else if (x < 9.8437500000000000e-01) {
        float dx = x - 9.6875000000000000e-01;
        return ((vec4(-5.3250445924665847e+01, -1.6529749150400146e+01, -1.4422423336140781e+02, 1.0) * dx
               + vec4( 1.1640046007890415e+01,  5.6520941645681013e+00, -5.6004839180401900e-01, 1.0)) * dx
               + vec4( 2.3280106875244833e-01,  1.8107311357768368e+00, -1.1915430113098306e+00, 1.0)) * dx
               + vec4( 9.5982380952380997e-01,  9.2183333333333295e-01,  9.4838095238095305e-02, 1.0);
    } else if (x < 1.0000000000000000e+00) {
        float dx = x - 9.8437500000000000e-01;
        return ((vec4(-1.9507053557699635e+02, -1.0404825969371934e+02,  1.5617193238656020e+02, 1.0) * dx
               + vec4( 9.1439313551717039e+00,  4.8772621731430945e+00, -7.3205593306200099e+00, 1.0)) * dx
               + vec4( 5.5755071505029385e-01,  1.9752523285535741e+00, -1.3146775069727061e+00, 1.0)) * dx
               + vec4( 9.6609999999999996e-01,  9.5144285714285703e-01,  7.5533333333333300e-02, 1.0);
    } else {
        float dx = x - 1.0000000000000000e+00;
        return ((vec4( 0.0000000000000000e+00,  3.4202936336155174e+00,  3.0625241907655076e+00, 1.0) * dx
               + vec4( 0.0000000000000000e+00,  0.0000000000000000e+00,  0.0000000000000000e+00, 1.0)) * dx
               + vec4( 0.0000000000000000e+00,  0.0000000000000000e+00,  0.0000000000000000e+00, 1.0)) * dx
               + vec4( 9.7629999999999995e-01,  9.8309999999999997e-01,  5.3800000000000001e-02, 1.0);
    }
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }
}
`,_r=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdBu.frag
float colormap_red(float x) {
	if (x < 0.09771832105856419) {
		return 7.60263247863246E+02 * x + 1.02931623931624E+02;
	} else if (x < 0.3017162107441106) {
		return (-2.54380938558548E+02 * x + 4.29911571188803E+02) * x + 1.37642085716717E+02;
	} else if (x < 0.4014205790737471) {
		return 8.67103448276151E+01 * x + 2.18034482758611E+02;
	} else if (x < 0.5019932233215039) {
		return -6.15461538461498E+01 * x + 2.77547692307680E+02;
	} else if (x < 0.5969483882550937) {
		return -3.77588522588624E+02 * x + 4.36198819698878E+02;
	} else if (x < 0.8046060096654594) {
		return (-6.51345897546620E+02 * x + 2.09780968434337E+02) * x + 3.17674951640855E+02;
	} else {
		return -3.08431855203590E+02 * x + 3.12956742081421E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09881640500975222) {
		return 2.41408547008547E+02 * x + 3.50427350427364E-01;
	} else if (x < 0.5000816285610199) {
		return ((((1.98531871433258E+04 * x - 2.64108262469187E+04) * x + 1.10991785969817E+04) * x - 1.92958444776211E+03) * x + 8.39569642882186E+02) * x - 4.82944517518776E+01;
	} else if (x < 0.8922355473041534) {
		return (((6.16712686949223E+03 * x - 1.59084026055125E+04) * x + 1.45172137257997E+04) * x - 5.80944127411621E+03) * x + 1.12477959061948E+03;
	} else {
		return -5.28313797313699E+02 * x + 5.78459299959206E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.1033699568661857) {
		return 1.30256410256410E+02 * x + 3.08518518518519E+01;
	} else if (x < 0.2037526071071625) {
		return 3.38458128078815E+02 * x + 9.33004926108412E+00;
	} else if (x < 0.2973267734050751) {
		return (-1.06345054944861E+02 * x + 5.93327252747168E+02) * x - 3.81852747252658E+01;
	} else if (x < 0.4029109179973602) {
		return 6.68959706959723E+02 * x - 7.00740740740798E+01;
	} else if (x < 0.5006715489526758) {
		return 4.87348695652202E+02 * x + 3.09898550724286E+00;
	} else if (x < 0.6004396902588283) {
		return -6.85799999999829E+01 * x + 2.81436666666663E+02;
	} else if (x < 0.702576607465744) {
		return -1.81331701891043E+02 * x + 3.49137263626287E+02;
	} else if (x < 0.9010407030582428) {
		return (2.06124143164576E+02 * x - 5.78166906665595E+02) * x + 5.26198653917172E+02;
	} else {
		return -7.36990769230737E+02 * x + 8.36652307692262E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,br=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,wr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap(1.0 - (A-0.4)*(1.0/0.6));


    if (A > 0.6) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,$r=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/transform_seismic.frag
float colormap_f(float x) {
    return ((-2010.0 * x + 2502.5950459) * x - 481.763180924) / 255.0;
}

float colormap_red(float x) {
    if (x < 0.0) {
        return 3.0 / 255.0;
    } else if (x < 0.238) {
        return ((-1810.0 * x + 414.49) * x + 3.87702) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return (344441250.0 / 323659.0 * x - 23422005.0 / 92474.0) / 255.0;
    } else if (x < 25851.0 / 34402.0) {
        return 1.0;
    } else if (x <= 1.0) {
        return (-688.04 * x + 772.02) / 255.0;
    } else {
        return 83.0 / 255.0;
    }
}

float colormap_green(float x) {
    if (x < 0.0) {
        return 0.0;
    } else if (x < 0.238) {
        return 0.0;
    } else if (x < 51611.0 / 108060.0) {
        return colormap_f(x);
    } else if (x < 0.739376978894039) {
        float xx = x - 51611.0 / 108060.0;
        return ((-914.74 * xx - 734.72) * xx + 255.) / 255.0;
    } else {
        return 0.0;
    }
}

float colormap_blue(float x) {
    if (x < 0.0) {
        return 19.0 / 255.0;
    } else if (x < 0.238) {
        float xx = x - 0.238;
        return (((1624.6 * xx + 1191.4) * xx + 1180.2) * xx + 255.0) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return 1.0;
    } else if (x < 174.5 / 256.0) {
        return (-951.67322673866 * x + 709.532730938451) / 255.0;
    } else if (x < 0.745745353439206) {
        return (-705.250074130877 * x + 559.620050530617) / 255.0;
    } else if (x <= 1.0) {
        return ((-399.29 * x + 655.71) * x - 233.25) / 255.0;
    } else {
        return 23.0 / 255.0;
    }
}

vec4 colormap(float x) {
    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,kr=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((B-0.1)*(1.0/0.9));


    if (B < 0.1) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,he={},yr=a=>{const e={vert:ar,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{iteration:a.prop("iteration"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}};he.raw=a({frag:lr,...e}),he.A_transform_seismic=a({frag:$r,...e}),he.A_gradiant1=a({frag:hr,...e}),he.A_gradiant2=a({frag:vr,...e}),he.A_MATLAB_cool=a({frag:gr,...e}),he.A_MATLAB_parula=a({frag:xr,...e}),he.A_IDL_CB_RdBu=a({frag:_r,...e}),he.A_IDL_CB_RdYiBu=a({frag:br,...e}),he.A_IDL_CB_BuYiRd=a({frag:wr,...e}),he.B_IDL_CB_RdYiBu=a({frag:kr,...e}),he.grayscale=a({frag:fr,...e}),he.blackwhite=a({frag:cr,...e}),he.whiteblack=a({frag:ur,...e}),he.timebasedblue=a({frag:sr,...e}),he.lerp=a({frag:pr,...e}),he.mrob=a({frag:mr,...e}),he.redblue=a({frag:dr,...e})},Sr=a=>{const{colorMode:e,inputBuffer:n,iteration:o,outputBuffer:t,zoomState:i}=a;(he[e]||he.raw)({inputBuffer:n,iteration:o,outputBuffer:t,pan:[i.panX,i.panY],zoomLevel:i.zoomLevel})},Er=`precision mediump float;

uniform float radius;
uniform sampler2D prevState;
uniform bool pauseSimulation;
uniform float Da;
uniform float Db;
uniform float f;
uniform float k;

uniform bool penIsActive;
uniform bool eraserIsActive;
uniform float penDensity;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

// https://thebookofshaders.com/10/
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
}

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(radius)).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(radius)).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(radius)).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(radius)).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(radius)).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(radius)).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(radius)).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(radius)).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(radius)).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));


    float rnd = random(uv);
    if (penIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(0.0, 1.0, 0, 1);
    } else if (eraserIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(1.0, 0.0, 0, 1);
    } else if (pauseSimulation) {
        gl_FragColor = vec4(A, B, 0, 1);
    } else {
        gl_FragColor = vec4(newA, newB, 0, 1);
    }
}
`,Ar=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
uniform float penRadius;

attribute vec2 position;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

void main() {
    uv = 0.5 * (position + 1.0);
    mouseUv = (mousePosition * zoomLevel) + pan * (1.0 - zoomLevel);
    scaledPenRadius = penRadius * zoomLevel;
    gl_Position = vec4(position, 0, 1);
}
`;let mn;const Dr=(a,e)=>{mn=a({frag:Er,vert:Ar,attributes:{position:[-4,-4,4,-4,0,4]},count:3,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),Da:1,Db:.5,f:a.prop("f"),k:a.prop("k"),radius:e,pauseSimulation:a.prop("pauseSimulation"),mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),penDensity:a.prop("penDensity"),penIsActive:a.prop("penIsActive"),eraserIsActive:a.prop("eraserIsActive"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},Br=a=>{const{inputBuffer:e,outputBuffer:n,pauseSimulation:o,mouseState:t,simulationParameters:i,worldSize:r}=a;mn({inputBuffer:e,outputBuffer:n,pauseSimulation:o,zoomLevel:t.zoomLevel,pan:[t.panX,t.panY],mousePosition:[t.x,t.y],penRadius:1/2**(r-t.penSize),penDensity:t.penDensity,penIsActive:t.pressedLeft,eraserIsActive:t.pressedRight,...i})},zr=(a,e)=>a==="randomSpots"?Ir(e,.001):a==="middleCircleAndRandomSpots"?Cr(e,.005,.05):a==="empty"?Tr(e):Lr(e,.02),Cr=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},Tr=a=>Array(a*a).fill(0).map(()=>[0,0,0,1]).flat(),Ir=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),Lr=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),Rr=`precision highp float;

attribute vec2 position;

uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,Pr=`precision highp float;

uniform sampler2D prevState;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float division = 10.0;
    float column = mod(uv.x, 1.0 / division);
    float c = column * division;

    float row = mod(uv.y, 1.0 / division);
    float r = row * division;

    // I haven't found a way to compare the value to an exact value
    // Might be a precision issue, or just that I'm missing something
    if (c < 0.05 || r < 0.05) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
       gl_FragColor = color;
    }
}
`;let dn;const Fr=a=>{dn=a({vert:Rr,frag:Pr,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},Mr=a=>{const{inputBuffer:e,outputBuffer:n,zoomState:o}=a;dn({inputBuffer:e,outputBuffer:n,zoomLevel:o.zoomLevel,pan:[o.panX,o.panY]})},Nr=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

attribute vec2 position;

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}
`,Ur=`precision mediump float;

uniform sampler2D prevState;
uniform vec2 mousePosition;
uniform float penRadius;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float d = distance(uv, mousePosition);
    if (
        (d >= penRadius && d <= penRadius + 0.001) ||
        (uv.x >= mousePosition.x - 0.001 && uv.x <= mousePosition.x + 0.001 && uv.y >= mousePosition.y - 0.01 && uv.y <= mousePosition.y + 0.01) ||
        (uv.x >= mousePosition.x - 0.01 && uv.x <= mousePosition.x + 0.01 && uv.y >= mousePosition.y - 0.001 && uv.y <= mousePosition.y + 0.001))
    {
        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    } else {
        gl_FragColor = color;
    }
}
`;let hn;const Or=a=>{hn=a({frag:Ur,vert:Nr,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}})},Vr=a=>{const{inputBuffer:e,mouseState:n,outputBuffer:o,worldSize:t}=a;hn({inputBuffer:e,outputBuffer:o,mousePosition:[n.x,n.y],penRadius:1/2**(t-n.penSize),zoomLevel:n.zoomLevel,pan:[n.panX,n.panY]})},vn=a=>{const{controls:e,info:n,mouseState:o,simulationParameters:t}=a,i=document.getElementById("canvas");if(!i)throw new Error("Canvas container not ready");const r=Le({extensions:["OES_texture_float"],canvas:i});n.iteration=0;const s=2**n.worldSize,l=zr(e.initialConditions,s),f=()=>r.framebuffer({color:r.texture({radius:s,data:l,wrap:"repeat",type:"float"}),depthStencil:!1}),c=Array(2).fill(0).map(f),u=Array(2).fill(0).map(f);return Dr(r,s),yr(r),Fr(r),Or(r),r.frame(()=>{e.pause||n.iteration++;let p=c[(n.iteration+1)%2];for(let m=0;m<e.speed;m++){n.iteration++;const d=c[n.iteration%2];p=c[(n.iteration+1)%2],Br({inputBuffer:d,outputBuffer:p,worldSize:n.worldSize,pauseSimulation:e.pause,mouseState:o,simulationParameters:t})}Hr({inputTexture:p,graphicsTextures:u,controls:e,info:n,mouseState:o})}),r},Hr=a=>{const{inputTexture:e,graphicsTextures:n,controls:o,info:t,mouseState:i}=a;let r=0;r++;const s=e;let l=n[r%2];if(!o.grid&&!o.pen&&(l=null),Sr({colorMode:o.colors,inputBuffer:s,iteration:t.iteration,outputBuffer:l,zoomState:i}),o.grid){r++;const f=n[(r+1)%2];let c=n[r%2];o.pen||(c=null),Mr({inputBuffer:f,outputBuffer:c,zoomState:i})}if(o.pen){r++;const f=n[(r+1)%2],c=null;Vr({mouseState:i,worldSize:t.worldSize,inputBuffer:f,outputBuffer:c})}};const{window:Kr}=je;function qr(a){let e,n,o,t,i,r,s,l,f,c,u,p,m,d=2**a[0].worldSize+"",g,C,E=2**a[0].worldSize+"",S,M,v=2**(a[0].worldSize+1)+"",x,$,L,D,b,V,X;return n=new ir({}),n.$on("fkupdated",a[4]),{c(){e=B("main"),N(n.$$.fragment),o=q(),t=B("div"),i=q(),r=B("div"),s=B("label"),l=R("World Size:"),f=q(),c=B("input"),u=q(),p=B("span"),m=R("("),g=R(d),C=R(" x "),S=R(E),M=R(" : "),x=R(v),$=R(")"),L=q(),D=B("canvas"),this.h()},l(I){e=z(I,"MAIN",{});var F=T(e);G(n.$$.fragment,F),o=Y(F),t=z(F,"DIV",{id:!0,class:!0}),T(t).forEach(h),i=Y(F),r=z(F,"DIV",{});var te=T(r);s=z(te,"LABEL",{for:!0});var xe=T(s);l=P(xe,"World Size:"),xe.forEach(h),f=Y(te),c=z(te,"INPUT",{id:!0,type:!0,step:!0}),u=Y(te),p=z(te,"SPAN",{});var ae=T(p);m=P(ae,"("),g=P(ae,d),C=P(ae," x "),S=P(ae,E),M=P(ae," : "),x=P(ae,v),$=P(ae,")"),ae.forEach(h),te.forEach(h),L=Y(F),D=z(F,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(D).forEach(h),F.forEach(h),this.h()},h(){y(t,"id","datgui-container"),y(t,"class","svelte-198vt5w"),y(s,"for","worldSize"),y(c,"id","worldSize"),y(c,"type","number"),y(c,"step","1"),y(D,"id","canvas"),y(D,"width",a[1].width),y(D,"height",a[1].height),y(D,"class","svelte-198vt5w")},m(I,F){A(I,e,F),U(n,e,null),w(e,o),w(e,t),w(e,i),w(e,r),w(r,s),w(s,l),w(r,f),w(r,c),Se(c,a[0].worldSize),w(r,u),w(r,p),w(p,m),w(p,g),w(p,C),w(p,S),w(p,M),w(p,x),w(p,$),w(e,L),w(e,D),b=!0,V||(X=[Z(Kr,"keydown",a[2]),Z(c,"input",a[5]),Z(c,"change",a[3]),Z(D,"contextmenu",we(Yr))],V=!0)},p(I,[F]){F&1&&Ae(c.value)!==I[0].worldSize&&Se(c,I[0].worldSize),(!b||F&1)&&d!==(d=2**I[0].worldSize+"")&&pe(g,d),(!b||F&1)&&E!==(E=2**I[0].worldSize+"")&&pe(S,E),(!b||F&1)&&v!==(v=2**(I[0].worldSize+1)+"")&&pe(x,v)},i(I){b||(_(n.$$.fragment,I),b=!0)},o(I){k(n.$$.fragment,I),b=!1},d(I){I&&h(e),O(n),V=!1,Be(X)}}}const Yr=a=>a;function Gr(a,e,n){const o={width:Math.min(window.innerWidth,window.innerHeight)*.9,height:Math.min(window.innerWidth,window.innerHeight)*.9},t={colors:"A_transform_seismic",initialConditions:"middleCircleAndRandomSpots",reset:()=>d(),pause:!1,grid:!1,pen:!1,speed:50},i={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:3,penDensity:.3,zoomLevel:1,panX:.5,panY:.5},r={iteration:0,worldSize:8},s={f:Ee[0].f,k:Ee[0].k};let l,f;const c=async()=>{const E=await Te(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);l=new E.GUI({autoPlace:!1,closeOnTop:!0}),l.domElement.id="datgui";const S=document.getElementById("datgui-container");if(!S)throw new Error("Gui container not ready");S.appendChild(l.domElement),l.add(t,"pause").name("Pause"),l.add(t,"grid").name("Debug grid"),l.add(t,"pen").name("Show pen"),l.add(t,"reset").name("Reset simulation"),l.add(t,"colors",["grayscale","blackwhite","whiteblack","raw","timebasedblue","lerp","mrob","redblue","A_gradiant1","A_gradiant2","A_MATLAB_cool","A_MATLAB_parula","A_IDL_CB_RdBu","A_IDL_CB_RdYiBu","A_IDL_CB_BuYiRd","A_transform_seismic","B_IDL_CB_RdYiBu"]).name("Color scheme");const M={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots",Empty:"empty"};l.add(t,"initialConditions",M).onFinishChange(t.reset).name("Initial conditions");const v=l.add(r,"iteration").listen();v.domElement.style.pointerEvents="none",l.add(t,"speed",1,200).name("Simulation speed").listen(),l.add(i,"penSize",0,r.worldSize).name("Pen size").listen(),l.add(i,"penDensity",0,1).name("Pen density"),l.add(i,"zoomLevel",0,1).name("Zoom level").listen(),l.add(i,"panX",0,1).name("pan x").listen(),l.add(i,"panY",0,1).name("pan y").listen()},u=E=>{if(E.code==="Space"){t.pause=!t.pause,E.preventDefault();return}if(E.code==="KeyR"&&!E.getModifierState("Control")){d(),E.preventDefault();return}};let p;const m=()=>{i.x=Math.random(),i.y=Math.random(),i.penSize=Math.random()*3,i.pressedLeft=!0,setTimeout(()=>i.pressedLeft=!1,500),p=setTimeout(m,Math.random()*5e3)},d=()=>{isNaN(r.worldSize)||(r.worldSize>11&&n(0,r.worldSize=11,r),r.worldSize<1&&n(0,r.worldSize=1,r),l&&(document.getElementById(l.domElement.id)?.remove(),l.destroy()),f?.destroy(),c(),f=vn({controls:t,info:r,mouseState:i,simulationParameters:s}),p&&clearTimeout(p),m())},g=E=>{s.f=E.detail.f,s.k=E.detail.k,s.f>.06?t.speed=70:s.f>.03?t.speed=50:t.speed=2};$e(()=>{d()}),ye(()=>{l.destroy(),f.destroy()});function C(){r.worldSize=Ae(this.value),n(0,r)}return[r,o,u,d,g,C]}class Ct extends Q{constructor(e){super(),J(this,e,Gr,qr,ee,{})}}function Tt(a,e,n){const o=a.slice();return o[17]=e[n],o}function It(a){let e,n,o,t,i,r,s,l,f,c=Ee,u=[];for(let p=0;p<c.length;p+=1)u[p]=Lt(Tt(a,c,p));return r=new Fe({props:{sketch:a[4]}}),{c(){e=B("div"),n=R("Select f and k parameters on the map of use a preset"),o=q(),t=B("select");for(let p=0;p<u.length;p+=1)u[p].c();i=q(),N(r.$$.fragment),this.h()},l(p){e=z(p,"DIV",{});var m=T(e);n=P(m,"Select f and k parameters on the map of use a preset"),m.forEach(h),o=Y(p),t=z(p,"SELECT",{class:!0});var d=T(t);for(let g=0;g<u.length;g+=1)u[g].l(d);d.forEach(h),i=Y(p),G(r.$$.fragment,p),this.h()},h(){y(t,"class","full-width svelte-vk9dfi"),a[0]===void 0&&it(()=>a[6].call(t))},m(p,m){A(p,e,m),w(e,n),A(p,o,m),A(p,t,m);for(let d=0;d<u.length;d+=1)u[d].m(t,null);Ve(t,a[0]),A(p,i,m),U(r,p,m),s=!0,l||(f=[Z(t,"change",a[6]),Z(t,"change",a[7])],l=!0)},p(p,m){if(m&0){c=Ee;let d;for(d=0;d<c.length;d+=1){const g=Tt(p,c,d);u[d]?u[d].p(g,m):(u[d]=Lt(g),u[d].c(),u[d].m(t,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}m&1&&Ve(t,p[0])},i(p){s||(_(r.$$.fragment,p),s=!0)},o(p){k(r.$$.fragment,p),s=!1},d(p){p&&h(e),p&&h(o),p&&h(t),ke(u,p),p&&h(i),O(r,p),l=!1,Be(f)}}}function Lt(a){let e,n=a[17].type+"",o,t,i=a[17].name+"",r,s,l=a[17].f+"",f,c,u=a[17].k+"",p,m;return{c(){e=B("option"),o=R(n),t=R(" - "),r=R(i),s=R(" (f/k "),f=R(l),c=R(" / "),p=R(u),m=R(`)
                `),this.h()},l(d){e=z(d,"OPTION",{});var g=T(e);o=P(g,n),t=P(g," - "),r=P(g,i),s=P(g," (f/k "),f=P(g,l),c=P(g," / "),p=P(g,u),m=P(g,`)
                `),g.forEach(h),this.h()},h(){e.__value=a[17],e.value=e.__value},m(d,g){A(d,e,g),w(e,o),w(e,t),w(e,r),w(e,s),w(e,f),w(e,c),w(e,p),w(e,m)},p:ne,d(d){d&&h(e)}}}function Wr(a){let e,n,o=a[1]?"Close":"F/K selection",t,i,r,s,l,f=a[1]&&It(a);return{c(){e=B("div"),n=B("button"),t=R(o),i=q(),f&&f.c(),this.h()},l(c){e=z(c,"DIV",{id:!0,class:!0});var u=T(e);n=z(u,"BUTTON",{class:!0,id:!0});var p=T(n);t=P(p,o),p.forEach(h),i=Y(u),f&&f.l(u),u.forEach(h),this.h()},h(){y(n,"class","full-width svelte-vk9dfi"),y(n,"id","toggleButton"),y(e,"id","container"),y(e,"class","svelte-vk9dfi"),Ie(e,"no-cursor",a[2])},m(c,u){A(c,e,u),w(e,n),w(n,t),w(e,i),f&&f.m(e,null),r=!0,s||(l=Z(n,"click",a[5]),s=!0)},p(c,[u]){(!r||u&2)&&o!==(o=c[1]?"Close":"F/K selection")&&pe(t,o),c[1]?f?(f.p(c,u),u&2&&_(f,1)):(f=It(c),f.c(),_(f,1),f.m(e,null)):f&&(oe(),k(f,1,1,()=>{f=null}),re()),(!r||u&4)&&Ie(e,"no-cursor",c[2])},i(c){r||(_(f),r=!0)},o(c){k(f),r=!1},d(c){c&&h(e),f&&f.d(),s=!1,l()}}}function Xr(a,e,n){const o=Ge();let t=Ee[0],i=!0;const r=[0,.12],s=[.03,.07],l=v=>{const{f:x,k:$}=v,L=d.map($,s[0],s[1],0,d.width),D=d.map(x,r[0],r[1],d.height,0);return{x:L,y:D}},f=v=>{const{x,y:$}=v,L=d.map($,d.height,0,r[0],r[1]),D=d.map(x,0,d.width,s[0],s[1]);return{f:L,k:D}},c=v=>{const x=v.mouseX,$=v.mouseY;if(x<0||$<0||x>v.width||$>v.height)return;const{f:L,k:D}=f({x:v.mouseX,y:v.mouseY});n(0,t={f:L,k:D,name:"custom",type:"manual"}),o("fkupdated",t)},u=v=>{v.noStroke();const x=v.textSize();for(const $ of Ee){const{x:L,y:D}=l({f:$.f,k:$.k}),b=$.f===t.f&&$.k===t.k;v.circle(L,D,3),v.textSize(b?x*2:x),v.fill(b?[240,240,150]:[255,255,255]),v.text($.name,L-v.textWidth($.name)/2,D-10)}},p=v=>{v.noFill(),v.stroke("red");const{x,y:$}=l(t);v.text("F",10,$>10?$-5:$+15),v.line(0,$,v.width,$),v.text("K",x<v.width-10?x+5:x-15,v.height-10),v.line(x,0,x,v.height),v.circle(x,$,10)},m=v=>{const{f:x,k:$}=t,L=`F: ${x.toFixed(4)}`,D=`K: ${$.toFixed(4)}`,b=v.textSize(),V=v.height*.05;v.textStyle(v.BOLD),v.textSize(V),v.fill("white"),v.stroke(0),v.strokeWeight(1),v.text(L,v.width*.05,v.textSize()),v.text(D,v.width*.05,v.textSize()+v.textSize()+6),v.textStyle(v.NORMAL),v.textSize(b)};let d,g=!1;const C=v=>{d=v;let x;v.preload=()=>{x=v.loadImage(Ze+"/parameters_map.png")},v.setup=()=>{v.createCanvas(400,400),v.frameRate(55)},v.draw=()=>{v.background(255),v.tint(150,190),v.image(x,0,0,v.width,v.height),u(v),p(v),m(v),n(2,g=!1),v.mouseIsPressed&&(c(v),n(2,g=!0))}},E=()=>{n(1,i=!i),i||d.remove()};ye(()=>d?.remove());function S(){t=at(this),n(0,t)}return[t,i,g,o,C,E,S,()=>o("fkupdated",t)]}let jr=class extends Q{constructor(e){super(),J(this,e,Xr,Wr,ee,{})}};const Rt=a=>{if(!a.currentTarget)throw new Error("Event has no currentTarget");const e=a.currentTarget,n=e.getBoundingClientRect(),o=a.clientX-n.left,t=a.clientY-n.top,{width:i,height:r}=e,s=o/i,l=(r-t)/r;return{x:s,y:l}};const{window:Zr}=je;function Qr(a){let e,n,o,t,i,r,s,l,f,c,u,p,m,d=2**a[0].worldSize+"",g,C,E=2**a[0].worldSize+"",S,M,v=2**(a[0].worldSize+1)+"",x,$,L,D,b,V,X;return n=new jr({}),n.$on("fkupdated",a[7]),{c(){e=B("main"),N(n.$$.fragment),o=q(),t=B("div"),i=q(),r=B("div"),s=B("label"),l=R("World Size:"),f=q(),c=B("input"),u=q(),p=B("span"),m=R("("),g=R(d),C=R(" x "),S=R(E),M=R(" : "),x=R(v),$=R(")"),L=q(),D=B("canvas"),this.h()},l(I){e=z(I,"MAIN",{});var F=T(e);G(n.$$.fragment,F),o=Y(F),t=z(F,"DIV",{id:!0,class:!0}),T(t).forEach(h),i=Y(F),r=z(F,"DIV",{});var te=T(r);s=z(te,"LABEL",{for:!0});var xe=T(s);l=P(xe,"World Size:"),xe.forEach(h),f=Y(te),c=z(te,"INPUT",{id:!0,type:!0,step:!0}),u=Y(te),p=z(te,"SPAN",{});var ae=T(p);m=P(ae,"("),g=P(ae,d),C=P(ae," x "),S=P(ae,E),M=P(ae," : "),x=P(ae,v),$=P(ae,")"),ae.forEach(h),te.forEach(h),L=Y(F),D=z(F,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(D).forEach(h),F.forEach(h),this.h()},h(){y(t,"id","datgui-container"),y(t,"class","svelte-18zf5fr"),y(s,"for","worldSize"),y(c,"id","worldSize"),y(c,"type","number"),y(c,"step","1"),y(D,"id","canvas"),y(D,"width",a[1].width),y(D,"height",a[1].height),y(D,"class","svelte-18zf5fr")},m(I,F){A(I,e,F),U(n,e,null),w(e,o),w(e,t),w(e,i),w(e,r),w(r,s),w(s,l),w(r,f),w(r,c),Se(c,a[0].worldSize),w(r,u),w(r,p),w(p,m),w(p,g),w(p,C),w(p,S),w(p,M),w(p,x),w(p,$),w(e,L),w(e,D),b=!0,V||(X=[Z(Zr,"keydown",a[2]),Z(c,"input",a[8]),Z(c,"change",a[6]),Z(D,"mousemove",a[4]),Z(D,"mousedown",we(a[5])),Z(D,"mouseup",a[5]),Z(D,"wheel",a[3]),Z(D,"keydown",we(a[2])),Z(D,"contextmenu",we(Jr))],V=!0)},p(I,[F]){F&1&&Ae(c.value)!==I[0].worldSize&&Se(c,I[0].worldSize),(!b||F&1)&&d!==(d=2**I[0].worldSize+"")&&pe(g,d),(!b||F&1)&&E!==(E=2**I[0].worldSize+"")&&pe(S,E),(!b||F&1)&&v!==(v=2**(I[0].worldSize+1)+"")&&pe(x,v)},i(I){b||(_(n.$$.fragment,I),b=!0)},o(I){k(n.$$.fragment,I),b=!1},d(I){I&&h(e),O(n),V=!1,Be(X)}}}const Jr=a=>a;function ei(a,e,n){const o={width:Math.min(window.innerWidth,window.innerHeight)*.9,height:Math.min(window.innerWidth,window.innerHeight)*.9},t={colors:"A_transform_seismic",initialConditions:"middleCircleAndRandomSpots",reset:()=>g(),pause:!1,grid:!1,pen:!0,speed:50},i={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:3,penDensity:.3,zoomLevel:1,panX:.5,panY:.5},r={iteration:0,worldSize:8},s={f:Ee[0].f,k:Ee[0].k};let l,f;const c=async()=>{const S=await Te(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);l=new S.GUI({autoPlace:!1,closeOnTop:!0}),l.domElement.id="datgui";const M=document.getElementById("datgui-container");if(!M)throw new Error("Gui container not ready");M.appendChild(l.domElement),l.add(t,"pause").name("Pause"),l.add(t,"grid").name("Debug grid"),l.add(t,"pen").name("Show pen"),l.add(t,"reset").name("Reset simulation"),l.add(t,"colors",["grayscale","blackwhite","whiteblack","raw","timebasedblue","lerp","mrob","redblue","A_gradiant1","A_gradiant2","A_MATLAB_cool","A_MATLAB_parula","A_IDL_CB_RdBu","A_IDL_CB_RdYiBu","A_IDL_CB_BuYiRd","A_transform_seismic","B_IDL_CB_RdYiBu"]).name("Color scheme");const v={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots",Empty:"empty"};l.add(t,"initialConditions",v).onFinishChange(t.reset).name("Initial conditions");const x=l.add(r,"iteration").listen();x.domElement.style.pointerEvents="none",l.add(t,"speed",1,200).name("Simulation speed"),l.add(i,"penSize",0,r.worldSize).name("Pen size"),l.add(i,"penDensity",0,1).name("Pen density"),l.add(i,"zoomLevel",0,1).name("Zoom level").listen(),l.add(i,"panX",0,1).name("pan x").listen(),l.add(i,"panY",0,1).name("pan y").listen()},u=S=>{if(S.code==="Space"){t.pause=!t.pause,S.preventDefault();return}if(S.code==="KeyR"&&!S.getModifierState("Control")){g(),S.preventDefault();return}},p=S=>{if(!S.getModifierState("Control"))return;const M=Rt(S);i.panX=M.x,i.panY=M.y,S.deltaY>0?i.zoomLevel*=1+i.zoomLevel/2:i.zoomLevel*=1-i.zoomLevel/2,i.zoomLevel>1&&(i.zoomLevel=1),i.zoomLevel<0&&(i.zoomLevel=0),S.preventDefault()},m=S=>{const M=Rt(S);i.x=M.x,i.y=M.y},d=S=>{if(![0,2].includes(S.button)||!["mouseup","mousedown"].includes(S.type))return;let M=S.type==="mousedown";S.button===0&&(i.pressedLeft=M),S.button===2&&(i.pressedRight=M)},g=()=>{isNaN(r.worldSize)||(r.worldSize>11&&n(0,r.worldSize=11,r),r.worldSize<1&&n(0,r.worldSize=1,r),l&&(document.getElementById(l.domElement.id)?.remove(),l.destroy()),f?.destroy(),c(),f=vn({controls:t,info:r,mouseState:i,simulationParameters:s}))},C=S=>{s.f=S.detail.f,s.k=S.detail.k};$e(()=>{g()}),ye(()=>{l.destroy(),f.destroy()});function E(){r.worldSize=Ae(this.value),n(0,r)}return[r,o,u,p,m,d,g,C,E]}class Pt extends Q{constructor(e){super(),J(this,e,ei,Qr,ee,{})}}const ti=`precision mediump float;
attribute vec2 position;
varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}
`,ni=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    gl_FragColor = vec4(A, B, 0.0, 1.0);
}

`,oi=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float PI = 3.14159265359;
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = sin(iteration*PI/180.0);
    if (val < 0.0) {
        val = -1.0 * val;
    }
    gl_FragColor = vec4(A, B, val, 1.0);
}
`,ri=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (A + B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}

`,ii=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(1.0 - val, 1.0 - val, 1.0 - val, 1.0);
}
`,ai=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}
`,li=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    // vec3 color1 = vec3(1.0, 0.0, 0.0);
    // vec3 color2 = vec3(0.0, 1.0, 0.0);
    // vec3 result = color1 * A + color2 * B;

    vec3 color1RGB = vec3(0.639, 0.941, 0.717);
    vec3 color2RGB = vec3(0.929, 0.082, 0.705);

    vec3 color1HSV = rgb2hsv(color1RGB);
    vec3 color2HSV = rgb2hsv(color2RGB);

    float color1Offset = (cos(iteration * 0.001) + 1.0) * 0.5;
    float color1newH = 0.5 * (color1HSV.x + color1Offset);
    vec3 color1newHSV = vec3(color1newH, color1HSV.g, color1HSV.b);

    float color2Offset = (cos(iteration * 0.002)) * 0.5;
    float color2newH = 0.5 * (color2HSV.x + color2Offset + 0.33);
    vec3 color2newHSV = vec3(color2newH, color2HSV.g, color2HSV.b);


    vec3 resultHSV = color1newHSV * A + color2newHSV * B;
    vec3 result = hsv2rgb(resultHSV);

    gl_FragColor = vec4(result, 1.0);
}
`,si=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float red = A; // The more A the redder
    float blue = 1.0 - A; // The less A the bleuer

    float green = max(A, B) - min(A, B);

    vec3 result = vec3(red, green, blue);

    gl_FragColor = vec4(result, 1.0);
}
`,fi=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec3 color1 = vec3(0.0, 0.0, 1.0);
    vec3 color2 = vec3(1.0, 0.0, 0.0);
    vec3 result = vec3(A, 0.0, 1.0-A);

    gl_FragColor = vec4(result, 1.0);
}
`,ci=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    if (A > 0.9) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else if (A > 0.4) {
        gl_FragColor = vec4(1.0 - A, 0.0, 0.0, 1.0);
    } else { 
        gl_FragColor = vec4(0.0, A, 0.0, 1.0);
    }
}
`,ui=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);
    vec4 color = mix(blue, red, A);

    vec4 softRed = vec4(0.8588, 0.2824, 0.3765, 1.0);
    vec4 softBlue = vec4(0.2824, 0.3882, 0.8588, 1.0);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.6);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.4);
    vec4 softColor = mix(softBlue, softRed, 1.0-A);


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(color);
    }

}
`,pi=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/MATLAB_cool.frag
float colormap_red(float x) {
    return (1.0 + 1.0 / 63.0) * x - 1.0 / 63.0;
}

float colormap_green(float x) {
    return -(1.0 + 1.0 / 63.0) * x + (1.0 + 1.0 / 63.0);
}

vec4 colormap(float x) {
    float r = clamp(colormap_red(x), 0.0, 1.0);
    float g = clamp(colormap_green(x), 0.0, 1.0);
    float b = 1.0;
    return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,mi=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdBu.frag
float colormap_red(float x) {
	if (x < 0.09771832105856419) {
		return 7.60263247863246E+02 * x + 1.02931623931624E+02;
	} else if (x < 0.3017162107441106) {
		return (-2.54380938558548E+02 * x + 4.29911571188803E+02) * x + 1.37642085716717E+02;
	} else if (x < 0.4014205790737471) {
		return 8.67103448276151E+01 * x + 2.18034482758611E+02;
	} else if (x < 0.5019932233215039) {
		return -6.15461538461498E+01 * x + 2.77547692307680E+02;
	} else if (x < 0.5969483882550937) {
		return -3.77588522588624E+02 * x + 4.36198819698878E+02;
	} else if (x < 0.8046060096654594) {
		return (-6.51345897546620E+02 * x + 2.09780968434337E+02) * x + 3.17674951640855E+02;
	} else {
		return -3.08431855203590E+02 * x + 3.12956742081421E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09881640500975222) {
		return 2.41408547008547E+02 * x + 3.50427350427364E-01;
	} else if (x < 0.5000816285610199) {
		return ((((1.98531871433258E+04 * x - 2.64108262469187E+04) * x + 1.10991785969817E+04) * x - 1.92958444776211E+03) * x + 8.39569642882186E+02) * x - 4.82944517518776E+01;
	} else if (x < 0.8922355473041534) {
		return (((6.16712686949223E+03 * x - 1.59084026055125E+04) * x + 1.45172137257997E+04) * x - 5.80944127411621E+03) * x + 1.12477959061948E+03;
	} else {
		return -5.28313797313699E+02 * x + 5.78459299959206E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.1033699568661857) {
		return 1.30256410256410E+02 * x + 3.08518518518519E+01;
	} else if (x < 0.2037526071071625) {
		return 3.38458128078815E+02 * x + 9.33004926108412E+00;
	} else if (x < 0.2973267734050751) {
		return (-1.06345054944861E+02 * x + 5.93327252747168E+02) * x - 3.81852747252658E+01;
	} else if (x < 0.4029109179973602) {
		return 6.68959706959723E+02 * x - 7.00740740740798E+01;
	} else if (x < 0.5006715489526758) {
		return 4.87348695652202E+02 * x + 3.09898550724286E+00;
	} else if (x < 0.6004396902588283) {
		return -6.85799999999829E+01 * x + 2.81436666666663E+02;
	} else if (x < 0.702576607465744) {
		return -1.81331701891043E+02 * x + 3.49137263626287E+02;
	} else if (x < 0.9010407030582428) {
		return (2.06124143164576E+02 * x - 5.78166906665595E+02) * x + 5.26198653917172E+02;
	} else {
		return -7.36990769230737E+02 * x + 8.36652307692262E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,di=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,hi=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((B-0.1)*(1.0/0.9));


    if (B < 0.1) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,_e={},vi=a=>{const e={vert:ti,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{iteration:a.prop("iteration"),prevState:a.prop("inputBuffer")}};_e.raw=a({frag:ni,...e}),_e.A_gradiant1=a({frag:ci,...e}),_e.A_gradiant2=a({frag:ui,...e}),_e.A_MATLAB_cool=a({frag:pi,...e}),_e.A_IDL_CB_RdBu=a({frag:mi,...e}),_e.A_IDL_CB_RdYiBu=a({frag:di,...e}),_e.B_IDL_CB_RdYiBu=a({frag:hi,...e}),_e.grayscale=a({frag:ri,...e}),_e.blackwhite=a({frag:ii,...e}),_e.whiteblack=a({frag:ai,...e}),_e.timebasedblue=a({frag:oi,...e}),_e.lerp=a({frag:li,...e}),_e.mrob=a({frag:si,...e}),_e.redblue=a({frag:fi,...e})},gi=a=>{const{colorMode:e,inputBuffer:n,iteration:o,outputBuffer:t,zoomState:i}=a;(_e[e]||_e.raw)({inputBuffer:n,iteration:o,outputBuffer:t,pan:[i.panX,i.panY],zoomLevel:i.zoomLevel})},xi=`precision mediump float;

uniform float radius;
uniform sampler2D prevState;
uniform bool pauseSimulation;
uniform float Da;
uniform float Db;

varying vec2 v_fk;

uniform bool penIsActive;
uniform bool eraserIsActive;
uniform float penDensity;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

// https://thebookofshaders.com/10/
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
}

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(radius)).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(radius)).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(radius)).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(radius)).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(radius)).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(radius)).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(radius)).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(radius)).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(radius)).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float f = v_fk.x;
    float k = v_fk.y;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));


    float rnd = random(uv);
    if (penIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(0.0, 1.0, 0, 1);
    } else if (pauseSimulation) {
        gl_FragColor = vec4(A, B, 0, 1);
    } else {
        gl_FragColor = vec4(newA, newB, 0, 1);
    }
}
`,_i=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float penRadius;

attribute vec2 position;
attribute vec2 fk;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;
varying vec2 v_fk;

void main() {
    uv = 0.5 * (position + 1.0);
    v_fk = fk;
    mouseUv = mousePosition;
    scaledPenRadius = penRadius;
    gl_Position = vec4(position, 0, 1);
}
`;let gn;const bi=(a,e)=>{gn=a({frag:xi,vert:_i,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]],fk:(n,o)=>{const{maxF:t,minF:i,maxK:r,minK:s}=o.simulationParameters;return[[i,r],[i,s],[t,r],[t,r],[i,s],[t,s]]}},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),Da:1,Db:.5,radius:e,pauseSimulation:a.prop("pauseSimulation"),mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),penDensity:a.prop("penDensity"),penIsActive:a.prop("penIsActive")}})},wi=a=>{const{inputBuffer:e,outputBuffer:n,simulationParameters:o,pauseSimulation:t,mouseState:i,worldSize:r}=a;gn({inputBuffer:e,outputBuffer:n,pauseSimulation:t,zoomLevel:i.zoomLevel,pan:[i.panX,i.panY],mousePosition:[i.x,i.y],penRadius:1/2**(r-i.penSize),penDensity:i.penDensity,penIsActive:i.pressedLeft,eraserIsActive:i.pressedRight,simulationParameters:o})},$i=(a,e)=>a==="randomSpots"?yi(e,.001):a==="middleCircleAndRandomSpots"?ki(e,.005,.05):a==="empty"||a==="full"?Ft(e):Si(e,.02),ki=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},Ft=a=>Array(a*a).fill(0).map(()=>[0,0,0,1]).flat(),yi=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),Si=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),Ei=a=>{const{controls:e,info:n,mouseState:o,simulationParameters:t}=a,i=document.getElementById("canvas");if(!i)throw new Error("Canvas container not ready");const r=Le({extensions:["OES_texture_float"],canvas:i});n.iteration=0;const s=2**n.worldSize,l=$i(e.initialConditions,s),f=()=>r.framebuffer({color:r.texture({radius:s,data:l,wrap:"repeat",type:"float"}),depthStencil:!1}),c=Array(2).fill(0).map(f);return bi(r,s),vi(r),r.frame(()=>{e.pause||n.iteration++;let u=c[(n.iteration+1)%2];for(let p=0;p<e.speed;p++){n.iteration++;const m=c[n.iteration%2];u=c[(n.iteration+1)%2],wi({inputBuffer:m,outputBuffer:u,worldSize:n.worldSize,pauseSimulation:e.pause,mouseState:o,simulationParameters:t})}gi({colorMode:e.colors,inputBuffer:u,iteration:n.iteration,outputBuffer:null,zoomState:o})}),r},Mt=a=>{if(!a.currentTarget)throw new Error("Event has no currentTarget");const e=a.currentTarget,n=e.getBoundingClientRect(),o=a.clientX-n.left,t=a.clientY-n.top,{width:i,height:r}=e,s=o/i,l=(r-t)/r;return{x:s,y:l}};const{window:Ai}=je;function Di(a){let e,n,o,t,i,r,s,l,f,c,u,p;return{c(){e=B("main"),n=B("div"),o=q(),t=B("div"),i=B("label"),r=R("World Size:"),s=q(),l=B("input"),f=q(),c=B("canvas"),this.h()},l(m){e=z(m,"MAIN",{});var d=T(e);n=z(d,"DIV",{id:!0,class:!0}),T(n).forEach(h),o=Y(d),t=z(d,"DIV",{});var g=T(t);i=z(g,"LABEL",{for:!0});var C=T(i);r=P(C,"World Size:"),C.forEach(h),s=Y(g),l=z(g,"INPUT",{id:!0,type:!0,step:!0}),g.forEach(h),f=Y(d),c=z(d,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(c).forEach(h),d.forEach(h),this.h()},h(){y(n,"id","datgui-container"),y(n,"class","svelte-198vt5w"),y(i,"for","worldSize"),y(l,"id","worldSize"),y(l,"type","number"),y(l,"step","1"),y(c,"id","canvas"),y(c,"width",a[1].width),y(c,"height",a[1].height),y(c,"class","svelte-198vt5w")},m(m,d){A(m,e,d),w(e,n),w(e,o),w(e,t),w(t,i),w(i,r),w(t,s),w(t,l),Se(l,a[0].worldSize),w(e,f),w(e,c),u||(p=[Z(Ai,"keydown",a[2]),Z(l,"input",a[7]),Z(l,"change",a[6]),Z(c,"mousemove",a[4]),Z(c,"mousedown",we(a[5])),Z(c,"mouseup",a[5]),Z(c,"wheel",a[3]),Z(c,"keydown",we(a[2])),Z(c,"contextmenu",we(Bi))],u=!0)},p(m,[d]){d&1&&Ae(l.value)!==m[0].worldSize&&Se(l,m[0].worldSize)},i:ne,o:ne,d(m){m&&h(e),u=!1,Be(p)}}}const Bi=a=>a;function zi(a,e,n){const o={width:Math.min(window.innerWidth,window.innerHeight)*.9,height:Math.min(window.innerWidth,window.innerHeight)*.9},t={colors:"B_IDL_CB_RdYiBu",initialConditions:"full",reset:()=>g(),pause:!1,grid:!1,speed:10},i={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:12,penDensity:.3,zoomLevel:1,panX:.5,panY:.5},r={iteration:0,worldSize:10},s={minK:.02,maxK:.07,minF:0,maxF:.12};let l,f;const c=async()=>{const E=await Te(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);l=new E.GUI({autoPlace:!1,closeOnTop:!0}),l.domElement.id="datgui";const S=document.getElementById("datgui-container");if(!S)throw new Error("Gui container not ready");S.appendChild(l.domElement),l.add(t,"pause").name("Pause"),l.add(t,"grid").name("Debug grid"),l.add(t,"reset").name("Reset simulation"),l.add(t,"colors",["grayscale","blackwhite","whiteblack","raw","timebasedblue","lerp","mrob","redblue","A_gradiant1","A_gradiant2","A_MATLAB_cool","A_IDL_CB_RdBu","A_IDL_CB_RdYiBu","B_IDL_CB_RdYiBu"]).name("Color scheme");const M={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots",Empty:"empty",Full:"full"};l.add(t,"initialConditions",M).onFinishChange(t.reset).name("Initial conditions");const v=l.add(r,"iteration").listen();v.domElement.style.pointerEvents="none",l.add(t,"speed",1,500).name("Simulation speed"),l.add(i,"penSize",0,r.worldSize).name("Pen size"),l.add(i,"penDensity",0,1).name("Pen density"),l.add(s,"minK",0,s.maxK),l.add(s,"maxK",s.minK,1),l.add(s,"minF",0,s.maxF),l.add(s,"maxF",s.minF,1)},u=E=>{if(E.code==="Space"){t.pause=!t.pause,E.preventDefault();return}if(E.code==="KeyR"&&!E.getModifierState("Control")){g(),E.preventDefault();return}},p=E=>{if(!E.getModifierState("Control"))return;const S=Mt(E);i.panX=S.x,i.panY=S.y,E.deltaY>0?i.zoomLevel*=1+i.zoomLevel/2:i.zoomLevel*=1-i.zoomLevel/2,i.zoomLevel>1&&(i.zoomLevel=1),i.zoomLevel<0&&(i.zoomLevel=0),E.preventDefault()},m=E=>{const S=Mt(E);i.x=S.x,i.y=S.y},d=E=>{if(![0,2].includes(E.button)||!["mouseup","mousedown"].includes(E.type))return;let S=E.type==="mousedown";E.button===0&&(i.pressedLeft=S),E.button===2&&(i.pressedRight=S)},g=()=>{isNaN(r.worldSize)||(r.worldSize>12&&n(0,r.worldSize=12,r),r.worldSize<1&&n(0,r.worldSize=1,r),l&&(document.getElementById(l.domElement.id)?.remove(),l.destroy()),f?.destroy(),c(),f=Ei({controls:t,info:r,mouseState:i,simulationParameters:s}))};$e(()=>{g(),i.pressedLeft=!0,setTimeout(()=>i.pressedLeft=!1,10)}),ye(()=>{l.destroy(),f.destroy()});function C(){r.worldSize=Ae(this.value),n(0,r)}return[r,o,u,p,m,d,g,C]}let rt=class extends Q{constructor(e){super(),J(this,e,zi,Di,ee,{})}};const Ci=a=>{const e=[];for(let r=0;r<a.height;r++){e.push([]);for(let s=0;s<a.width;s++)e[e.length-1].push({A:1,B:0})}const n=5,o=5,t=Math.floor(a.width/2),i=Math.floor(a.height/2);for(let r=i-o;r<i+o;r++)for(let s=t-n;s<t+n;s++)e[r][s].B=1;return e},Ti=(a,e)=>{const n={width:a.width/e[0].length,height:a.height/e.length};for(let o=0;o<e.length;o++)for(let t=0;t<e[0].length;t++){const{A:i,B:r}=e[o][t];a.fill(i*255,r*255,0),a.rect(t*n.width,o*n.height,n.width,n.height)}},Ii=1,Li=.5,Nt=.055,Ri=.062,Pi=a=>{const e=[];for(let n=0;n<a.length;n++){e.push([]);for(let o=0;o<a[0].length;o++){const{A:t,B:i}=a[n][o],r=Ut(a,{x:o,y:n},"A"),s=Ut(a,{x:o,y:n},"B"),l=t+(Ii*r-t*i*i+Nt*(1-t)),f=i+(Li*s+t*i*i-(Ri+Nt)*i);e[n].push({A:l,B:f})}}return e},Ut=(a,e,n)=>{const o=Fi(a,e);let t=0;for(const i of o){const{coord:r,weight:s}=i;t+=a[r.y][r.x][n]*s}return t},Fi=(a,e)=>{const{x:n,y:o}=e,t=a[0].length,i=a.length,r={coord:{x:n>0?n-1:t-1,y:o>0?o-1:i-1},weight:.05},s={coord:{x:n,y:o>0?o-1:i-1},weight:.2},l={coord:{x:n<t-1?n+1:0,y:o>0?o-1:i-1},weight:.05},f={coord:{x:n>0?n-1:t-1,y:o},weight:.2},c={coord:{x:n,y:o},weight:-1},u={coord:{x:n<t-1?n+1:0,y:o},weight:.2},p={coord:{x:n>0?n-1:t-1,y:o<i-1?o+1:0},weight:.05},m={coord:{x:n,y:o<i-1?o+1:0},weight:.2},d={coord:{x:n<t-1?n+1:0,y:o<i-1?o+1:0},weight:.05};return[r,s,l,f,c,u,p,m,d]};function Mi(a){let e,n;return e=new Fe({props:{sketch:a[0]}}),{c(){N(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){U(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){O(e,o)}}}function Ni(a){const e={width:200,height:200};let n;return[t=>{let i;t.setup=()=>{n=t,t.createCanvas(500,500),t.noStroke(),i=Ci(e)},t.draw=()=>{t.background(0);for(let r=0;r<20;r++)i=Pi(i);Ti(n,i)}}]}let Ui=class extends Q{constructor(e){super(),J(this,e,Ni,Mi,ee,{})}},me,Ue;const Oi=a=>{me=[],Ue=[];for(let i=0;i<a.height;i++){me.push([]),Ue.push([]);for(let r=0;r<a.width;r++)me[me.length-1].push({A:1,B:0}),Ue[me.length-1].push({A:1,B:0})}const e=5,n=5,o=Math.floor(a.width/2),t=Math.floor(a.height/2);for(let i=t-n;i<t+n;i++)for(let r=o-e;r<o+e;r++)me[i][r].B=1;return me},Vi=a=>{const e={width:a.width/me[0].length,height:a.height/me.length};for(let n=0;n<me.length;n++)for(let o=0;o<me[0].length;o++){const{A:t,B:i}=me[n][o];a.fill(t*255,i*255,0),a.rect(o*e.width,n*e.height,e.width,e.height)}},Hi=1,Ki=.5,Ot=.055,qi=.062,Yi=()=>{for(let e=0;e<me.length;e++)for(let n=0;n<me[0].length;n++){const{A:o,B:t}=me[e][n],i=Vt(me,{x:n,y:e},"A"),r=Vt(me,{x:n,y:e},"B"),s=o+(Hi*i-o*t*t+Ot*(1-o)),l=t+(Ki*r+o*t*t-(qi+Ot)*t);Ue[e][n]={A:s,B:l}}const a=me;return me=Ue,Ue=a,me},Vt=(a,e,n)=>{const o=Gi(a,e);let t=0;for(const i of o){const{coord:r,weight:s}=i;t+=a[r.y][r.x][n]*s}return t},Gi=(a,e)=>{const{x:n,y:o}=e,t=a[0].length,i=a.length,r={coord:{x:n>0?n-1:t-1,y:o>0?o-1:i-1},weight:.05},s={coord:{x:n,y:o>0?o-1:i-1},weight:.2},l={coord:{x:n<t-1?n+1:0,y:o>0?o-1:i-1},weight:.05},f={coord:{x:n>0?n-1:t-1,y:o},weight:.2},c={coord:{x:n,y:o},weight:-1},u={coord:{x:n<t-1?n+1:0,y:o},weight:.2},p={coord:{x:n>0?n-1:t-1,y:o<i-1?o+1:0},weight:.05},m={coord:{x:n,y:o<i-1?o+1:0},weight:.2},d={coord:{x:n<t-1?n+1:0,y:o<i-1?o+1:0},weight:.05};return[r,s,l,f,c,u,p,m,d]};function Wi(a){let e,n;return e=new Fe({props:{sketch:a[0]}}),{c(){N(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){U(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){O(e,o)}}}function Xi(a){const e={width:200,height:200};let n;return[t=>{t.setup=()=>{n=t,t.createCanvas(500,500),t.noStroke(),Oi(e)},t.draw=()=>{for(let i=0;i<5;i++)Yi();Vi(n)}}]}let ji=class extends Q{constructor(e){super(),J(this,e,Xi,Wi,ee,{})}},de,Oe;const Zi=a=>{de=[],Oe=[];for(let i=0;i<a.height;i++){de.push([]),Oe.push([]);for(let r=0;r<a.width;r++)de[de.length-1].push({A:1,B:0}),Oe[de.length-1].push({A:1,B:0})}const e=5,n=5,o=Math.floor(a.width/2),t=Math.floor(a.height/2);for(let i=t-n;i<t+n;i++)for(let r=o-e;r<o+e;r++)de[i][r].B=1;return de},Qi=a=>{const e={width:a.width/de[0].length,height:a.height/de.length};for(let n=0;n<de.length;n++)for(let o=0;o<de[0].length;o++){const{A:t,B:i}=de[n][o];a.fill(t*255,i*255,0),a.rect(o*e.width,n*e.height,e.width,e.height)}},Ji=1,ea=.5,Ht=.055,ta=.062,na=()=>{for(let e=0;e<de.length;e++)for(let n=0;n<de[0].length;n++){const{A:o,B:t}=de[e][n],i=Kt(de,{x:n,y:e},"A"),r=Kt(de,{x:n,y:e},"B"),s=o+(Ji*i-o*t*t+Ht*(1-o)),l=t+(ea*r+o*t*t-(ta+Ht)*t);Oe[e][n]={A:s,B:l}}const a=de;return de=Oe,Oe=a,de},Kt=(a,e,n)=>{const o=oa(a,e);let t=0;for(const i of o){const{coord:r,weight:s}=i;t+=a[r.y][r.x][n]*s}return t},oa=(a,e)=>{const{x:n,y:o}=e,t=a[0].length,i=a.length,r={coord:{x:n>0?n-1:t-1,y:o>0?o-1:i-1},weight:.05},s={coord:{x:n,y:o>0?o-1:i-1},weight:.2},l={coord:{x:n<t-1?n+1:0,y:o>0?o-1:i-1},weight:.05},f={coord:{x:n>0?n-1:t-1,y:o},weight:.2},c={coord:{x:n,y:o},weight:-1},u={coord:{x:n<t-1?n+1:0,y:o},weight:.2},p={coord:{x:n>0?n-1:t-1,y:o<i-1?o+1:0},weight:.05},m={coord:{x:n,y:o<i-1?o+1:0},weight:.2},d={coord:{x:n<t-1?n+1:0,y:o<i-1?o+1:0},weight:.05};return[r,s,l,f,c,u,p,m,d]};function ra(a){let e,n;return e=new Fe({props:{sketch:a[0]}}),{c(){N(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){U(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){O(e,o)}}}function ia(a){const e={width:200,height:200};let n;return[t=>{t.setup=()=>{n=t,t.createCanvas(500,500),t.noStroke(),Zi(e)},t.draw=()=>{for(let i=0;i<5;i++)na();Qi(n)}}]}let aa=class extends Q{constructor(e){super(),J(this,e,ia,ra,ee,{})}};function la(a){let e;return{c(){e=B("canvas"),this.h()},l(n){e=z(n,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(e).forEach(h),this.h()},h(){y(e,"id","canvas"),y(e,"width",a[0].width),y(e,"height",a[0].height),y(e,"class","svelte-1b0ol19")},m(n,o){A(n,e,o)},p:ne,i:ne,o:ne,d(n){n&&h(e)}}}function sa(a){const e={width:window.innerWidth-50,height:window.innerHeight-10},n=2**10,o=n*.05,t=Array(n*n).fill(0).map((i,r)=>{const s=Math.floor(r/n),l=r%n;return Math.hypot(n/2-l,n/2-s)<o?[0,1,0,1]:Math.random()<.01?[0,1,0,1]:[1,0,0,1]}).flat();return $e(()=>{const i=document.getElementById("canvas");if(!i)throw new Error("Canvas container not ready");const r=Le({extensions:["OES_texture_float"],canvas:i}),s=Array(2).fill(0).map(()=>r.framebuffer({color:r.texture({radius:n,data:t,wrap:"repeat",type:"float"}),depthStencil:!1})),l=r({frag:`
precision mediump float;
uniform sampler2D prevState;
varying vec2 uv;

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(${n})).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(${n})).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(${n})).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(${n})).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(${n})).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(${n})).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(${n})).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(${n})).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(${n})).rg * 0.05;

    return r;
}

void main() {
    float Da = 1.0;
    float Db = 0.5;
    float f = 0.055;
    float k = 0.062;

    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));

    gl_FragColor = vec4(newA, newB, 0, 1);
}`,framebuffer:c=>s[(c.tick+1)%2]}),f=r({frag:`
precision mediump float;
uniform sampler2D prevState;
varying vec2 uv;
void main() {
    vec2 state = texture2D(prevState, uv).rg;
    gl_FragColor = vec4(state, 0, 1);
}`,vert:`
precision mediump float;
attribute vec2 position;
varying vec2 uv;
void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}`,attributes:{position:[-4,-4,4,-4,0,4]},uniforms:{prevState:({tick:c})=>s[c%2]},depth:{enable:!1},count:3});r.frame(()=>{f(()=>{r.draw(),l()})})}),[e]}let fa=class extends Q{constructor(e){super(),J(this,e,sa,la,ee,{})}};const ca=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},ua=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),pa=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),We=[{name:"KarlSims",type:"Unknown",f:.055,k:.062},{name:"Alpha 1",type:"alpha",f:.01,k:.047},{name:"Alpha 2",type:"alpha",f:.014,k:.053},{name:"Beta 1",type:"beta",f:.014,k:.039},{name:"Beta 2",type:"beta",f:.026,k:.051},{name:"Epsilon 1",type:"epsilon",f:.018,k:.055},{name:"Epsilon 2",type:"epsilon",f:.022,k:.059},{name:"Epsilon 1",type:"epsilon",f:.034,k:.063},{name:"Gamma 1",type:"gamma",f:.022,k:.051},{name:"Gamma 2",type:"gamma",f:.026,k:.055},{name:"Iota 1",type:"iota",f:.046,k:.0594},{name:"Lambda 1",type:"lambda",f:.026,k:.061},{name:"Lambda 2",type:"lambda",f:.034,k:.065},{name:"Mu 1",type:"mu",f:.046,k:.065},{name:"Mu 2",type:"mu",f:.058,k:.065},{name:"Pi 1",type:"pi",f:.062,k:.061},{name:"Rho 1",type:"rho",f:.09,k:.059},{name:"Rho 2",type:"rho",f:.102,k:.055},{name:"Sigma 1",type:"sigma",f:.09,k:.057},{name:"Sigma 2",type:"sigma",f:.11,k:.0523},{name:"Theta 1",type:"theta",f:.03,k:.057},{name:"Theta 2",type:"theta",f:.038,k:.061},{name:"Xi 1",type:"xi",f:.01,k:.041},{name:"Xi 2",type:"xi",f:.014,k:.047},{name:"Zeta 1",type:"zeta",f:.022,k:.061},{name:"Zeta 2",type:"zeta",f:.026,k:.059}];function ma(a){let e;return{c(){e=B("canvas"),this.h()},l(n){e=z(n,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(e).forEach(h),this.h()},h(){y(e,"id","canvas"),y(e,"width",a[0].width),y(e,"height",a[0].height),y(e,"class","svelte-1b0ol19")},m(n,o){A(n,e,o)},p:ne,i:ne,o:ne,d(n){n&&h(e)}}}function da(a){const e={width:window.innerWidth-50,height:window.innerHeight-10},n={presetParams:4,initialConditions:"randomSpots",reset:()=>f(),pause:!1},o={iteration:0},t={f:We[n.presetParams].f,k:We[n.presetParams].k};let i,r;const s=async()=>{const c=await Te(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);i=new c.GUI,i.domElement.setAttribute("style","background-color: black"),i.add(t,"f").name("Feed rate").listen(),i.add(t,"k").name("Kill rate").listen(),i.add(n,"pause").name("Pause"),i.add(n,"reset").name("Reset simulation");const u=We.reduce((d,g,C)=>(d[g.name]=C,d),{});i.add(n,"presetParams",u).onFinishChange(()=>{t.f=We[n.presetParams].f,t.k=We[n.presetParams].k});const p={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots"};i.add(n,"initialConditions",p).onFinishChange(n.reset);const m=i.add(o,"iteration").listen();m.domElement.style.pointerEvents="none"},l=()=>{document.addEventListener("keydown",c=>{if(c.code==="Space")return n.pause=!n.pause,c.preventDefault();if(c.code==="KeyR")return f(),c.preventDefault()})},f=()=>{const c=document.getElementById("canvas");if(!c)throw new Error("Canvas container not ready");r&&r.destroy(),r=Le({extensions:["OES_texture_float"],canvas:c}),o.iteration=0;const u=2**11;let p;n.initialConditions==="randomSpots"?p=ua(u,.001):n.initialConditions==="middleCircleAndRandomSpots"?p=ca(u,.005,.05):p=pa(u,.02);const m=Array(2).fill(0).map(()=>r.framebuffer({color:r.texture({radius:u,data:p,wrap:"repeat",type:"float"}),depthStencil:!1})),d=r({frag:`
precision mediump float;

uniform sampler2D prevState;
uniform float Da;
uniform float Db;
uniform float f;
uniform float k;

varying vec2 uv;

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(${u})).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(${u})).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(${u})).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(${u})).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(${u})).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(${u})).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(${u})).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(${u})).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(${u})).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));

    gl_FragColor = vec4(newA, newB, 0, 1);
}`,framebuffer:C=>m[(C.tick+1)%2],uniforms:{Da:r.prop("Da"),Db:r.prop("Db"),f:r.prop("f"),k:r.prop("k")}}),g=r({frag:`
precision mediump float;
uniform sampler2D prevState;
varying vec2 uv;
void main() {
    vec2 state = texture2D(prevState, uv).rg;
    gl_FragColor = vec4(state, 0, 1);
}`,vert:`
precision mediump float;
attribute vec2 position;
varying vec2 uv;
void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}`,attributes:{position:[-4,-4,4,-4,0,4]},uniforms:{prevState:({tick:C})=>m[C%2]},depth:{enable:!1},count:3});r.frame(()=>{g(()=>{r.draw(),!n.pause&&(o.iteration++,d({Da:1,Db:.5,...t}))})})};return $e(()=>{s(),l(),f()}),ye(()=>{i.destroy(),r.destroy()}),[e]}let ha=class extends Q{constructor(e){super(),J(this,e,da,ma,ee,{})}};const va=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},ga=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),xa=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),Xe=[{name:"KarlSims",type:"Unknown",f:.055,k:.062},{name:"Alpha 1",type:"alpha",f:.01,k:.047},{name:"Alpha 2",type:"alpha",f:.014,k:.053},{name:"Beta 1",type:"beta",f:.014,k:.039},{name:"Beta 2",type:"beta",f:.026,k:.051},{name:"Epsilon 1",type:"epsilon",f:.018,k:.055},{name:"Epsilon 2",type:"epsilon",f:.022,k:.059},{name:"Epsilon 1",type:"epsilon",f:.034,k:.063},{name:"Gamma 1",type:"gamma",f:.022,k:.051},{name:"Gamma 2",type:"gamma",f:.026,k:.055},{name:"Iota 1",type:"iota",f:.046,k:.0594},{name:"Lambda 1",type:"lambda",f:.026,k:.061},{name:"Lambda 2",type:"lambda",f:.034,k:.065},{name:"Mu 1",type:"mu",f:.046,k:.065},{name:"Mu 2",type:"mu",f:.058,k:.065},{name:"Pi 1",type:"pi",f:.062,k:.061},{name:"Rho 1",type:"rho",f:.09,k:.059},{name:"Rho 2",type:"rho",f:.102,k:.055},{name:"Sigma 1",type:"sigma",f:.09,k:.057},{name:"Sigma 2",type:"sigma",f:.11,k:.0523},{name:"Theta 1",type:"theta",f:.03,k:.057},{name:"Theta 2",type:"theta",f:.038,k:.061},{name:"Xi 1",type:"xi",f:.01,k:.041},{name:"Xi 2",type:"xi",f:.014,k:.047},{name:"Zeta 1",type:"zeta",f:.022,k:.061},{name:"Zeta 2",type:"zeta",f:.026,k:.059}],_a=`precision mediump float;
attribute vec2 position;
varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}
`,ba=`precision mediump float;
uniform sampler2D prevState;
varying vec2 uv;

void main() {
    vec2 state = texture2D(prevState, uv).rg;
    gl_FragColor = vec4(state, 0, 1);
}
`,wa=`precision mediump float;

uniform float radius;
uniform sampler2D prevState;
uniform bool pauseSimulation;
uniform float Da;
uniform float Db;
uniform float f;
uniform float k;

uniform vec2 mousePosition;
uniform bool penIsActive;
uniform bool eraserIsActive;
uniform float penRadius;

varying vec2 uv;

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(radius)).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(radius)).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(radius)).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(radius)).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(radius)).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(radius)).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(radius)).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(radius)).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(radius)).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));

    if (penIsActive && distance(uv, mousePosition) < penRadius) {
        gl_FragColor = vec4(0.0, 1.0, 0, 1);
    } else if (eraserIsActive && distance(uv, mousePosition) < penRadius) {
        gl_FragColor = vec4(1.0, 0.0, 0, 1);
    } else if (pauseSimulation) {
        gl_FragColor = vec4(A, B, 0, 1);
    } else {
        gl_FragColor = vec4(newA, newB, 0, 1);
    }
}
`;function $a(a){let e,n,o;return{c(){e=B("canvas"),this.h()},l(t){e=z(t,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(e).forEach(h),this.h()},h(){y(e,"id","canvas"),y(e,"width",a[0].width),y(e,"height",a[0].height),y(e,"class","svelte-1b0ol19")},m(t,i){A(t,e,i),n||(o=[Z(e,"mousemove",a[1]),Z(e,"mousedown",we(a[2])),Z(e,"mouseup",a[2]),Z(e,"contextmenu",we(ka))],n=!0)},p:ne,i:ne,o:ne,d(t){t&&h(e),n=!1,Be(o)}}}const nt=11,ka=a=>a;function ya(a){const e={width:window.innerWidth-50,height:window.innerHeight-10},n={presetParams:4,initialConditions:"randomSpots",reset:()=>c(),pause:!1},o={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:3},t={iteration:0},i={f:Xe[n.presetParams].f,k:Xe[n.presetParams].k};let r,s;const l=async()=>{const m=await Te(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);r=new m.GUI,r.domElement.setAttribute("style","background-color: black"),r.add(i,"f").name("Feed rate").listen(),r.add(i,"k").name("Kill rate").listen(),r.add(n,"pause").name("Pause"),r.add(n,"reset").name("Reset simulation");const d=Xe.reduce((E,S,M)=>(E[S.name]=M,E),{});r.add(n,"presetParams",d).onFinishChange(()=>{i.f=Xe[n.presetParams].f,i.k=Xe[n.presetParams].k});const g={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots"};r.add(n,"initialConditions",g).onFinishChange(n.reset);const C=r.add(t,"iteration").listen();C.domElement.style.pointerEvents="none",r.add(o,"penSize",1,nt,1).name("Pen size")},f=()=>{document.addEventListener("keydown",m=>{if(m.code==="Space")return n.pause=!n.pause,m.preventDefault();if(m.code==="KeyR")return c(),m.preventDefault()})},c=()=>{const m=document.getElementById("canvas");if(!m)throw new Error("Canvas container not ready");s&&s.destroy(),s=Le({extensions:["OES_texture_float"],canvas:m}),t.iteration=0;const d=2**nt;let g;n.initialConditions==="randomSpots"?g=ga(d,.001):n.initialConditions==="middleCircleAndRandomSpots"?g=va(d,.005,.05):g=xa(d,.02);const C=Array(2).fill(0).map(()=>s.framebuffer({color:s.texture({radius:d,data:g,wrap:"repeat",type:"float"}),depthStencil:!1})),E=s({frag:wa,framebuffer:M=>C[(M.tick+1)%2],uniforms:{Da:s.prop("Da"),Db:s.prop("Db"),f:s.prop("f"),k:s.prop("k"),radius:d,pauseSimulation:s.prop("pauseSimulation"),mousePosition:s.prop("mousePosition"),penRadius:s.prop("penRadius"),penIsActive:s.prop("penIsActive"),eraserIsActive:s.prop("eraserIsActive")}}),S=s({frag:ba,vert:_a,attributes:{position:[-4,-4,4,-4,0,4]},uniforms:{prevState:({tick:M})=>C[M%2]},depth:{enable:!1},count:3});s.frame(()=>{S(()=>{s.draw(),n.pause||t.iteration++,E({Da:1,Db:.5,pauseSimulation:n.pause,mousePosition:[o.x,o.y],penRadius:1/2**(nt-o.penSize),penIsActive:o.pressedLeft,eraserIsActive:o.pressedRight,...i})})})},u=m=>{if(!m.currentTarget)throw new Error("No target for the onmousemove event");if(!m.currentTarget.width||!m.currentTarget.height)throw new Error("No target dimensions for the onmousemove event target");const{x:d,y:g}=m,{width:C,height:E}=m.currentTarget,S=d/C,M=(E-g)/E;o.x=S,o.y=M},p=m=>{if(![0,2].includes(m.button)||!["mouseup","mousedown"].includes(m.type))return;let d=m.type==="mousedown";m.button===0&&(o.pressedLeft=d),m.button===2&&(o.pressedRight=d)};return $e(()=>{l(),f(),c()}),ye(()=>{r.destroy(),s.destroy()}),[e,u,p]}let Sa=class extends Q{constructor(e){super(),J(this,e,ya,$a,ee,{})}};const He=[{name:"KarlSims",type:"Unknown",f:.055,k:.062},{name:"STX 1",type:"N.A",f:.0353,k:.0614},{name:"STX 2",type:"N.A",f:.0201,k:.0602},{name:"STX 2",type:"N.A",f:.0181,k:.0435},{name:"α 1",type:"alpha",f:.01,k:.047},{name:"α 2",type:"alpha",f:.014,k:.053},{name:"β 1",type:"beta",f:.014,k:.039},{name:"β 2",type:"beta",f:.026,k:.051},{name:"δ 1",type:"delta",f:.03,k:.055},{name:"δ 2",type:"delta",f:.042,k:.059},{name:"ε 1",type:"epsilon",f:.018,k:.055},{name:"ε 2",type:"epsilon",f:.022,k:.059},{name:"η 1",type:"eta",f:.034,k:.063},{name:"γ 1",type:"gamma",f:.022,k:.051},{name:"γ 2",type:"gamma",f:.026,k:.055},{name:"ι 1",type:"iota",f:.046,k:.0594},{name:"κ 1",type:"kappa",f:.082,k:.06},{name:"κ 2",type:"kappa",f:.058,k:.063},{name:"λ 1",type:"lambda",f:.026,k:.061},{name:"λ 2",type:"lambda",f:.034,k:.065},{name:"μ 1",type:"mu",f:.046,k:.065},{name:"μ 2",type:"mu",f:.058,k:.065},{name:"ν 2",type:"nu",f:.046,k:.067},{name:"π 1",type:"pi",f:.062,k:.061},{name:"ρ 1",type:"rho",f:.09,k:.059},{name:"ρ 2",type:"rho",f:.102,k:.055},{name:"σ 1",type:"sigma",f:.09,k:.057},{name:"θ 2",type:"sigma",f:.11,k:.0523},{name:"θ 1",type:"theta",f:.03,k:.057},{name:"θ 2",type:"theta",f:.038,k:.061},{name:"ξ 1",type:"xi",f:.01,k:.041},{name:"ξ 2",type:"xi",f:.014,k:.047},{name:"ζ 1",type:"zeta",f:.022,k:.061},{name:"ζ 2",type:"zeta",f:.026,k:.059}];function qt(a,e,n){const o=a.slice();return o[17]=e[n],o}function Yt(a){let e,n,o,t,i,r,s,l,f,c=He,u=[];for(let p=0;p<c.length;p+=1)u[p]=Gt(qt(a,c,p));return r=new Fe({props:{sketch:a[4]}}),{c(){e=B("div"),n=R("Select f and k parameters on the map of use a preset"),o=q(),t=B("select");for(let p=0;p<u.length;p+=1)u[p].c();i=q(),N(r.$$.fragment),this.h()},l(p){e=z(p,"DIV",{});var m=T(e);n=P(m,"Select f and k parameters on the map of use a preset"),m.forEach(h),o=Y(p),t=z(p,"SELECT",{class:!0});var d=T(t);for(let g=0;g<u.length;g+=1)u[g].l(d);d.forEach(h),i=Y(p),G(r.$$.fragment,p),this.h()},h(){y(t,"class","full-width svelte-1qznlxf"),a[0]===void 0&&it(()=>a[6].call(t))},m(p,m){A(p,e,m),w(e,n),A(p,o,m),A(p,t,m);for(let d=0;d<u.length;d+=1)u[d].m(t,null);Ve(t,a[0]),A(p,i,m),U(r,p,m),s=!0,l||(f=[Z(t,"change",a[6]),Z(t,"change",a[7])],l=!0)},p(p,m){if(m&0){c=He;let d;for(d=0;d<c.length;d+=1){const g=qt(p,c,d);u[d]?u[d].p(g,m):(u[d]=Gt(g),u[d].c(),u[d].m(t,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}m&1&&Ve(t,p[0])},i(p){s||(_(r.$$.fragment,p),s=!0)},o(p){k(r.$$.fragment,p),s=!1},d(p){p&&h(e),p&&h(o),p&&h(t),ke(u,p),p&&h(i),O(r,p),l=!1,Be(f)}}}function Gt(a){let e,n=a[17].type+"",o,t,i=a[17].name+"",r,s,l=a[17].f+"",f,c,u=a[17].k+"",p,m;return{c(){e=B("option"),o=R(n),t=R(" - "),r=R(i),s=R(" (f/k "),f=R(l),c=R(" / "),p=R(u),m=R(`)
                `),this.h()},l(d){e=z(d,"OPTION",{});var g=T(e);o=P(g,n),t=P(g," - "),r=P(g,i),s=P(g," (f/k "),f=P(g,l),c=P(g," / "),p=P(g,u),m=P(g,`)
                `),g.forEach(h),this.h()},h(){e.__value=a[17],e.value=e.__value},m(d,g){A(d,e,g),w(e,o),w(e,t),w(e,r),w(e,s),w(e,f),w(e,c),w(e,p),w(e,m)},p:ne,d(d){d&&h(e)}}}function Ea(a){let e,n,o=a[1]?"Close":"F/K selection",t,i,r,s,l,f=a[1]&&Yt(a);return{c(){e=B("div"),n=B("button"),t=R(o),i=q(),f&&f.c(),this.h()},l(c){e=z(c,"DIV",{id:!0,class:!0});var u=T(e);n=z(u,"BUTTON",{class:!0,id:!0});var p=T(n);t=P(p,o),p.forEach(h),i=Y(u),f&&f.l(u),u.forEach(h),this.h()},h(){y(n,"class","full-width svelte-1qznlxf"),y(n,"id","toggleButton"),y(e,"id","container"),y(e,"class","svelte-1qznlxf"),Ie(e,"no-cursor",a[2])},m(c,u){A(c,e,u),w(e,n),w(n,t),w(e,i),f&&f.m(e,null),r=!0,s||(l=Z(n,"click",a[5]),s=!0)},p(c,[u]){(!r||u&2)&&o!==(o=c[1]?"Close":"F/K selection")&&pe(t,o),c[1]?f?(f.p(c,u),u&2&&_(f,1)):(f=Yt(c),f.c(),_(f,1),f.m(e,null)):f&&(oe(),k(f,1,1,()=>{f=null}),re()),(!r||u&4)&&Ie(e,"no-cursor",c[2])},i(c){r||(_(f),r=!0)},o(c){k(f),r=!1},d(c){c&&h(e),f&&f.d(),s=!1,l()}}}function Aa(a,e,n){const o=Ge();let t=He[0],i=!0;const r=[0,.12],s=[.03,.07],l=v=>{const{f:x,k:$}=v,L=d.map($,s[0],s[1],0,d.width),D=d.map(x,r[0],r[1],d.height,0);return{x:L,y:D}},f=v=>{const{x,y:$}=v,L=d.map($,d.height,0,r[0],r[1]),D=d.map(x,0,d.width,s[0],s[1]);return{f:L,k:D}},c=v=>{const x=v.mouseX,$=v.mouseY;if(x<0||$<0||x>v.width||$>v.height)return;const{f:L,k:D}=f({x:v.mouseX,y:v.mouseY});n(0,t={f:L,k:D,name:"custom",type:"manual"}),o("fkupdated",t)},u=v=>{v.noStroke();const x=v.textSize();for(const $ of He){const{x:L,y:D}=l({f:$.f,k:$.k}),b=$.f===t.f&&$.k===t.k;v.circle(L,D,3),v.textSize(b?x*2:x),v.fill(b?[240,240,150]:[255,255,255]),v.text($.name,L-v.textWidth($.name)/2,D-10)}},p=v=>{v.noFill(),v.stroke("red");const{x,y:$}=l(t);v.text("F",10,$>10?$-5:$+15),v.line(0,$,v.width,$),v.text("K",x<v.width-10?x+5:x-15,v.height-10),v.line(x,0,x,v.height),v.circle(x,$,10)},m=v=>{const{f:x,k:$}=t,L=`F: ${x.toFixed(4)}`,D=`K: ${$.toFixed(4)}`,b=v.textSize(),V=v.height*.05;v.textStyle(v.BOLD),v.textSize(V),v.fill("white"),v.stroke(0),v.strokeWeight(1),v.text(L,v.width*.05,v.textSize()),v.text(D,v.width*.05,v.textSize()+v.textSize()+6),v.textStyle(v.NORMAL),v.textSize(b)};let d,g=!1;const C=v=>{d=v;let x;v.preload=()=>{x=v.loadImage(Ze+"/parameters_map.png")},v.setup=()=>{v.createCanvas(400,400),v.frameRate(55)},v.draw=()=>{v.background(255),v.tint(150,190),v.image(x,0,0,v.width,v.height),u(v),p(v),m(v),n(2,g=!1),v.mouseIsPressed&&(c(v),n(2,g=!0))}},E=()=>{n(1,i=!i),i||d.remove()};ye(()=>d?.remove());function S(){t=at(this),n(0,t)}return[t,i,g,o,C,E,S,()=>o("fkupdated",t)]}class Da extends Q{constructor(e){super(),J(this,e,Aa,Ea,ee,{})}}const Ba=`precision mediump float;
attribute vec2 position;
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,za=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    gl_FragColor = vec4(A, B, 0.0, 1.0);
}

`,Ca=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float PI = 3.14159265359;
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = sin(iteration*PI/180.0);
    if (val < 0.0) {
        val = -1.0 * val;
    }
    gl_FragColor = vec4(A, B, val, 1.0);
}
`,Ta=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (A + B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}

`,Ia=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(1.0 - val, 1.0 - val, 1.0 - val, 1.0);
}
`,La=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}
`,Ra=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    // vec3 color1 = vec3(1.0, 0.0, 0.0);
    // vec3 color2 = vec3(0.0, 1.0, 0.0);
    // vec3 result = color1 * A + color2 * B;

    vec3 color1RGB = vec3(0.639, 0.941, 0.717);
    vec3 color2RGB = vec3(0.929, 0.082, 0.705);

    vec3 color1HSV = rgb2hsv(color1RGB);
    vec3 color2HSV = rgb2hsv(color2RGB);

    float color1Offset = (cos(iteration * 0.001) + 1.0) * 0.5;
    float color1newH = 0.5 * (color1HSV.x + color1Offset);
    vec3 color1newHSV = vec3(color1newH, color1HSV.g, color1HSV.b);

    float color2Offset = (cos(iteration * 0.002)) * 0.5;
    float color2newH = 0.5 * (color2HSV.x + color2Offset + 0.33);
    vec3 color2newHSV = vec3(color2newH, color2HSV.g, color2HSV.b);


    vec3 resultHSV = color1newHSV * A + color2newHSV * B;
    vec3 result = hsv2rgb(resultHSV);

    gl_FragColor = vec4(result, 1.0);
}
`,Pa=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float red = A; // The more A the redder
    float blue = 1.0 - A; // The less A the bleuer

    float green = max(A, B) - min(A, B);

    vec3 result = vec3(red, green, blue);

    gl_FragColor = vec4(result, 1.0);
}
`,Fa=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec3 color1 = vec3(0.0, 0.0, 1.0);
    vec3 color2 = vec3(1.0, 0.0, 0.0);
    vec3 result = vec3(A, 0.0, 1.0-A);

    gl_FragColor = vec4(result, 1.0);
}
`,Ma=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    if (A > 0.9) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else if (A > 0.4) {
        gl_FragColor = vec4(1.0 - A, 0.0, 0.0, 1.0);
    } else { 
        gl_FragColor = vec4(0.0, A, 0.0, 1.0);
    }
}
`,Na=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);
    vec4 color = mix(blue, red, A);

    vec4 softRed = vec4(0.8588, 0.2824, 0.3765, 1.0);
    vec4 softBlue = vec4(0.2824, 0.3882, 0.8588, 1.0);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.6);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.4);
    vec4 softColor = mix(softBlue, softRed, 1.0-A);


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(color);
    }

}
`,Ua=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/MATLAB_cool.frag
float colormap_red(float x) {
    return (1.0 + 1.0 / 63.0) * x - 1.0 / 63.0;
}

float colormap_green(float x) {
    return -(1.0 + 1.0 / 63.0) * x + (1.0 + 1.0 / 63.0);
}

vec4 colormap(float x) {
    float r = clamp(colormap_red(x), 0.0, 1.0);
    float g = clamp(colormap_green(x), 0.0, 1.0);
    float b = 1.0;
    return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Oa=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdBu.frag
float colormap_red(float x) {
	if (x < 0.09771832105856419) {
		return 7.60263247863246E+02 * x + 1.02931623931624E+02;
	} else if (x < 0.3017162107441106) {
		return (-2.54380938558548E+02 * x + 4.29911571188803E+02) * x + 1.37642085716717E+02;
	} else if (x < 0.4014205790737471) {
		return 8.67103448276151E+01 * x + 2.18034482758611E+02;
	} else if (x < 0.5019932233215039) {
		return -6.15461538461498E+01 * x + 2.77547692307680E+02;
	} else if (x < 0.5969483882550937) {
		return -3.77588522588624E+02 * x + 4.36198819698878E+02;
	} else if (x < 0.8046060096654594) {
		return (-6.51345897546620E+02 * x + 2.09780968434337E+02) * x + 3.17674951640855E+02;
	} else {
		return -3.08431855203590E+02 * x + 3.12956742081421E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09881640500975222) {
		return 2.41408547008547E+02 * x + 3.50427350427364E-01;
	} else if (x < 0.5000816285610199) {
		return ((((1.98531871433258E+04 * x - 2.64108262469187E+04) * x + 1.10991785969817E+04) * x - 1.92958444776211E+03) * x + 8.39569642882186E+02) * x - 4.82944517518776E+01;
	} else if (x < 0.8922355473041534) {
		return (((6.16712686949223E+03 * x - 1.59084026055125E+04) * x + 1.45172137257997E+04) * x - 5.80944127411621E+03) * x + 1.12477959061948E+03;
	} else {
		return -5.28313797313699E+02 * x + 5.78459299959206E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.1033699568661857) {
		return 1.30256410256410E+02 * x + 3.08518518518519E+01;
	} else if (x < 0.2037526071071625) {
		return 3.38458128078815E+02 * x + 9.33004926108412E+00;
	} else if (x < 0.2973267734050751) {
		return (-1.06345054944861E+02 * x + 5.93327252747168E+02) * x - 3.81852747252658E+01;
	} else if (x < 0.4029109179973602) {
		return 6.68959706959723E+02 * x - 7.00740740740798E+01;
	} else if (x < 0.5006715489526758) {
		return 4.87348695652202E+02 * x + 3.09898550724286E+00;
	} else if (x < 0.6004396902588283) {
		return -6.85799999999829E+01 * x + 2.81436666666663E+02;
	} else if (x < 0.702576607465744) {
		return -1.81331701891043E+02 * x + 3.49137263626287E+02;
	} else if (x < 0.9010407030582428) {
		return (2.06124143164576E+02 * x - 5.78166906665595E+02) * x + 5.26198653917172E+02;
	} else {
		return -7.36990769230737E+02 * x + 8.36652307692262E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Va=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Ha=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap(1.0 - (A-0.4)*(1.0/0.6));


    if (A > 0.6) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Ka=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/transform_seismic.frag
float colormap_f(float x) {
    return ((-2010.0 * x + 2502.5950459) * x - 481.763180924) / 255.0;
}

float colormap_red(float x) {
    if (x < 0.0) {
        return 3.0 / 255.0;
    } else if (x < 0.238) {
        return ((-1810.0 * x + 414.49) * x + 3.87702) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return (344441250.0 / 323659.0 * x - 23422005.0 / 92474.0) / 255.0;
    } else if (x < 25851.0 / 34402.0) {
        return 1.0;
    } else if (x <= 1.0) {
        return (-688.04 * x + 772.02) / 255.0;
    } else {
        return 83.0 / 255.0;
    }
}

float colormap_green(float x) {
    if (x < 0.0) {
        return 0.0;
    } else if (x < 0.238) {
        return 0.0;
    } else if (x < 51611.0 / 108060.0) {
        return colormap_f(x);
    } else if (x < 0.739376978894039) {
        float xx = x - 51611.0 / 108060.0;
        return ((-914.74 * xx - 734.72) * xx + 255.) / 255.0;
    } else {
        return 0.0;
    }
}

float colormap_blue(float x) {
    if (x < 0.0) {
        return 19.0 / 255.0;
    } else if (x < 0.238) {
        float xx = x - 0.238;
        return (((1624.6 * xx + 1191.4) * xx + 1180.2) * xx + 255.0) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return 1.0;
    } else if (x < 174.5 / 256.0) {
        return (-951.67322673866 * x + 709.532730938451) / 255.0;
    } else if (x < 0.745745353439206) {
        return (-705.250074130877 * x + 559.620050530617) / 255.0;
    } else if (x <= 1.0) {
        return ((-399.29 * x + 655.71) * x - 233.25) / 255.0;
    } else {
        return 23.0 / 255.0;
    }
}

vec4 colormap(float x) {
    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,qa=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((B-0.1)*(1.0/0.9));


    if (B < 0.1) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,ve={},Ya=a=>{const e={vert:Ba,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{iteration:a.prop("iteration"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}};ve.raw=a({frag:za,...e}),ve.A_transform_seismic=a({frag:Ka,...e}),ve.A_gradiant1=a({frag:Ma,...e}),ve.A_gradiant2=a({frag:Na,...e}),ve.A_MATLAB_cool=a({frag:Ua,...e}),ve.A_IDL_CB_RdBu=a({frag:Oa,...e}),ve.A_IDL_CB_RdYiBu=a({frag:Va,...e}),ve.A_IDL_CB_BuYiRd=a({frag:Ha,...e}),ve.B_IDL_CB_RdYiBu=a({frag:qa,...e}),ve.grayscale=a({frag:Ta,...e}),ve.blackwhite=a({frag:Ia,...e}),ve.whiteblack=a({frag:La,...e}),ve.timebasedblue=a({frag:Ca,...e}),ve.lerp=a({frag:Ra,...e}),ve.mrob=a({frag:Pa,...e}),ve.redblue=a({frag:Fa,...e})},Ga=a=>{const{colorMode:e,inputBuffer:n,iteration:o,outputBuffer:t,zoomState:i}=a;(ve[e]||ve.raw)({inputBuffer:n,iteration:o,outputBuffer:t,pan:[i.panX,i.panY],zoomLevel:i.zoomLevel})},Wa=`precision mediump float;

uniform float radius;
uniform sampler2D prevState;
uniform bool pauseSimulation;
uniform float Da;
uniform float Db;
uniform float f;
uniform float k;

uniform bool penIsActive;
uniform bool eraserIsActive;
uniform float penDensity;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

// https://thebookofshaders.com/10/
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
}

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(radius)).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(radius)).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(radius)).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(radius)).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(radius)).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(radius)).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(radius)).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(radius)).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(radius)).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));


    float rnd = random(uv);
    if (penIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(0.0, 1.0, 0, 1);
    } else if (eraserIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(1.0, 0.0, 0, 1);
    } else if (pauseSimulation) {
        gl_FragColor = vec4(A, B, 0, 1);
    } else {
        gl_FragColor = vec4(newA, newB, 0, 1);
    }
}
`,Xa=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
uniform float penRadius;

attribute vec2 position;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

void main() {
    uv = 0.5 * (position + 1.0);
    mouseUv = (mousePosition * zoomLevel) + pan * (1.0 - zoomLevel);
    scaledPenRadius = penRadius * zoomLevel;
    gl_Position = vec4(position, 0, 1);
}
`;let xn;const ja=(a,e)=>{xn=a({frag:Wa,vert:Xa,attributes:{position:[-4,-4,4,-4,0,4]},count:3,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),Da:1,Db:.5,f:a.prop("f"),k:a.prop("k"),radius:e,pauseSimulation:a.prop("pauseSimulation"),mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),penDensity:a.prop("penDensity"),penIsActive:a.prop("penIsActive"),eraserIsActive:a.prop("eraserIsActive"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},Za=a=>{const{inputBuffer:e,outputBuffer:n,pauseSimulation:o,mouseState:t,simulationParameters:i,worldSize:r}=a;xn({inputBuffer:e,outputBuffer:n,pauseSimulation:o,zoomLevel:t.zoomLevel,pan:[t.panX,t.panY],mousePosition:[t.x,t.y],penRadius:1/2**(r-t.penSize),penDensity:t.penDensity,penIsActive:t.pressedLeft,eraserIsActive:t.pressedRight,...i})},Qa=(a,e)=>a==="randomSpots"?tl(e,.001):a==="middleCircleAndRandomSpots"?Ja(e,.005,.05):a==="empty"?el(e):nl(e,.02),Ja=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},el=a=>Array(a*a).fill(0).map(()=>[0,0,0,1]).flat(),tl=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),nl=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),ol=`precision highp float;

attribute vec2 position;

uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,rl=`precision highp float;

uniform sampler2D prevState;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float division = 10.0;
    float column = mod(uv.x, 1.0 / division);
    float c = column * division;

    float row = mod(uv.y, 1.0 / division);
    float r = row * division;

    // I haven't found a way to compare the value to an exact value
    // Might be a precision issue, or just that I'm missing something
    if (c < 0.05 || r < 0.05) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
       gl_FragColor = color;
    }
}
`;let _n;const il=a=>{_n=a({vert:ol,frag:rl,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},al=a=>{const{inputBuffer:e,outputBuffer:n,zoomState:o}=a;_n({inputBuffer:e,outputBuffer:n,zoomLevel:o.zoomLevel,pan:[o.panX,o.panY]})},ll=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

attribute vec2 position;

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}
`,sl=`precision mediump float;

uniform sampler2D prevState;
uniform vec2 mousePosition;
uniform float penRadius;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float d = distance(uv, mousePosition);
    if (
        (d >= penRadius && d <= penRadius + 0.001) ||
        (uv.x >= mousePosition.x - 0.001 && uv.x <= mousePosition.x + 0.001 && uv.y >= mousePosition.y - 0.01 && uv.y <= mousePosition.y + 0.01) ||
        (uv.x >= mousePosition.x - 0.01 && uv.x <= mousePosition.x + 0.01 && uv.y >= mousePosition.y - 0.001 && uv.y <= mousePosition.y + 0.001))
    {
        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    } else {
        gl_FragColor = color;
    }
}
`;let bn;const fl=a=>{bn=a({frag:sl,vert:ll,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}})},cl=a=>{const{inputBuffer:e,mouseState:n,outputBuffer:o,worldSize:t}=a;bn({inputBuffer:e,outputBuffer:o,mousePosition:[n.x,n.y],penRadius:1/2**(t-n.penSize),zoomLevel:n.zoomLevel,pan:[n.panX,n.panY]})},ul=a=>{const{controls:e,info:n,mouseState:o,simulationParameters:t}=a,i=document.getElementById("canvas");if(!i)throw new Error("Canvas container not ready");const r=Le({extensions:["OES_texture_float"],canvas:i});n.iteration=0;const s=2**n.worldSize,l=Qa(e.initialConditions,s),f=()=>r.framebuffer({color:r.texture({radius:s,data:l,wrap:"repeat",type:"float"}),depthStencil:!1}),c=Array(2).fill(0).map(f),u=Array(2).fill(0).map(f);return ja(r,s),Ya(r),il(r),fl(r),r.frame(()=>{e.pause||n.iteration++;let p=c[(n.iteration+1)%2];for(let m=0;m<e.speed;m++){n.iteration++;const d=c[n.iteration%2];p=c[(n.iteration+1)%2],Za({inputBuffer:d,outputBuffer:p,worldSize:n.worldSize,pauseSimulation:e.pause,mouseState:o,simulationParameters:t})}pl({inputTexture:p,graphicsTextures:u,controls:e,info:n,mouseState:o})}),r},pl=a=>{const{inputTexture:e,graphicsTextures:n,controls:o,info:t,mouseState:i}=a;let r=0;r++;const s=e,l=n[r%2];if(Ga({colorMode:o.colors,inputBuffer:s,iteration:t.iteration,outputBuffer:l,zoomState:i}),o.grid){r++;const u=n[(r+1)%2],p=n[r%2];al({inputBuffer:u,outputBuffer:p,zoomState:i})}r++;const f=n[(r+1)%2],c=null;cl({mouseState:i,worldSize:t.worldSize,inputBuffer:f,outputBuffer:c})},Wt=a=>{if(!a.currentTarget)throw new Error("Event has no currentTarget");const e=a.currentTarget,n=e.getBoundingClientRect(),o=a.clientX-n.left,t=a.clientY-n.top,{width:i,height:r}=e,s=o/i,l=(r-t)/r;return{x:s,y:l}};const{window:ml}=je;function dl(a){let e,n,o,t,i,r,s,l,f,c,u,p,m,d=2**a[0].worldSize+"",g,C,E=2**a[0].worldSize+"",S,M,v=2**(a[0].worldSize+1)+"",x,$,L,D,b,V,X;return n=new Da({}),n.$on("fkupdated",a[7]),{c(){e=B("main"),N(n.$$.fragment),o=q(),t=B("div"),i=q(),r=B("div"),s=B("label"),l=R("World Size:"),f=q(),c=B("input"),u=q(),p=B("span"),m=R("("),g=R(d),C=R(" x "),S=R(E),M=R(" : "),x=R(v),$=R(")"),L=q(),D=B("canvas"),this.h()},l(I){e=z(I,"MAIN",{});var F=T(e);G(n.$$.fragment,F),o=Y(F),t=z(F,"DIV",{id:!0,class:!0}),T(t).forEach(h),i=Y(F),r=z(F,"DIV",{});var te=T(r);s=z(te,"LABEL",{for:!0});var xe=T(s);l=P(xe,"World Size:"),xe.forEach(h),f=Y(te),c=z(te,"INPUT",{id:!0,type:!0,step:!0}),u=Y(te),p=z(te,"SPAN",{});var ae=T(p);m=P(ae,"("),g=P(ae,d),C=P(ae," x "),S=P(ae,E),M=P(ae," : "),x=P(ae,v),$=P(ae,")"),ae.forEach(h),te.forEach(h),L=Y(F),D=z(F,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(D).forEach(h),F.forEach(h),this.h()},h(){y(t,"id","datgui-container"),y(t,"class","svelte-18zf5fr"),y(s,"for","worldSize"),y(c,"id","worldSize"),y(c,"type","number"),y(c,"step","1"),y(D,"id","canvas"),y(D,"width",a[1].width),y(D,"height",a[1].height),y(D,"class","svelte-18zf5fr")},m(I,F){A(I,e,F),U(n,e,null),w(e,o),w(e,t),w(e,i),w(e,r),w(r,s),w(s,l),w(r,f),w(r,c),Se(c,a[0].worldSize),w(r,u),w(r,p),w(p,m),w(p,g),w(p,C),w(p,S),w(p,M),w(p,x),w(p,$),w(e,L),w(e,D),b=!0,V||(X=[Z(ml,"keydown",a[2]),Z(c,"input",a[8]),Z(c,"change",a[6]),Z(D,"mousemove",a[4]),Z(D,"mousedown",we(a[5])),Z(D,"mouseup",a[5]),Z(D,"wheel",a[3]),Z(D,"keydown",we(a[2])),Z(D,"contextmenu",we(hl))],V=!0)},p(I,[F]){F&1&&Ae(c.value)!==I[0].worldSize&&Se(c,I[0].worldSize),(!b||F&1)&&d!==(d=2**I[0].worldSize+"")&&pe(g,d),(!b||F&1)&&E!==(E=2**I[0].worldSize+"")&&pe(S,E),(!b||F&1)&&v!==(v=2**(I[0].worldSize+1)+"")&&pe(x,v)},i(I){b||(_(n.$$.fragment,I),b=!0)},o(I){k(n.$$.fragment,I),b=!1},d(I){I&&h(e),O(n),V=!1,Be(X)}}}const hl=a=>a;function vl(a,e,n){const o={width:Math.min(window.innerWidth,window.innerHeight)*.9,height:Math.min(window.innerWidth,window.innerHeight)*.9},t={colors:"A_transform_seismic",initialConditions:"middleCircleAndRandomSpots",reset:()=>g(),pause:!1,grid:!1,speed:50},i={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:3,penDensity:.3,zoomLevel:1,panX:.5,panY:.5},r={iteration:0,worldSize:8},s={f:He[0].f,k:He[0].k};let l,f;const c=async()=>{const S=await Te(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);l=new S.GUI({autoPlace:!1,closeOnTop:!0}),l.domElement.id="datgui";const M=document.getElementById("datgui-container");if(!M)throw new Error("Gui container not ready");M.appendChild(l.domElement),l.add(t,"pause").name("Pause"),l.add(t,"grid").name("Debug grid"),l.add(t,"reset").name("Reset simulation"),l.add(t,"colors",["grayscale","blackwhite","whiteblack","raw","timebasedblue","lerp","mrob","redblue","A_gradiant1","A_gradiant2","A_MATLAB_cool","A_IDL_CB_RdBu","A_IDL_CB_RdYiBu","A_IDL_CB_BuYiRd","A_transform_seismic","B_IDL_CB_RdYiBu"]).name("Color scheme");const v={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots",Empty:"empty"};l.add(t,"initialConditions",v).onFinishChange(t.reset).name("Initial conditions");const x=l.add(r,"iteration").listen();x.domElement.style.pointerEvents="none",l.add(t,"speed",1,200).name("Simulation speed"),l.add(i,"penSize",0,r.worldSize).name("Pen size"),l.add(i,"penDensity",0,1).name("Pen density"),l.add(i,"zoomLevel",0,1).name("Zoom level").listen(),l.add(i,"panX",0,1).name("pan x").listen(),l.add(i,"panY",0,1).name("pan y").listen()},u=S=>{if(S.code==="Space"){t.pause=!t.pause,S.preventDefault();return}if(S.code==="KeyR"&&!S.getModifierState("Control")){g(),S.preventDefault();return}},p=S=>{if(!S.getModifierState("Control"))return;const M=Wt(S);i.panX=M.x,i.panY=M.y,S.deltaY>0?i.zoomLevel*=1+i.zoomLevel/2:i.zoomLevel*=1-i.zoomLevel/2,i.zoomLevel>1&&(i.zoomLevel=1),i.zoomLevel<0&&(i.zoomLevel=0),S.preventDefault()},m=S=>{const M=Wt(S);i.x=M.x,i.y=M.y},d=S=>{if(![0,2].includes(S.button)||!["mouseup","mousedown"].includes(S.type))return;let M=S.type==="mousedown";S.button===0&&(i.pressedLeft=M),S.button===2&&(i.pressedRight=M)},g=()=>{isNaN(r.worldSize)||(r.worldSize>11&&n(0,r.worldSize=11,r),r.worldSize<1&&n(0,r.worldSize=1,r),l&&(document.getElementById(l.domElement.id)?.remove(),l.destroy()),f?.destroy(),c(),f=ul({controls:t,info:r,mouseState:i,simulationParameters:s}))},C=S=>{s.f=S.detail.f,s.k=S.detail.k};$e(()=>{g()}),ye(()=>{l.destroy(),f.destroy()});function E(){r.worldSize=Ae(this.value),n(0,r)}return[r,o,u,p,m,d,g,C,E]}let gl=class extends Q{constructor(e){super(),J(this,e,vl,dl,ee,{})}};const Ke=[{name:"KarlSims",type:"Unknown",f:.055,k:.062},{name:"STX 1",type:"N.A",f:.0353,k:.0614},{name:"STX 2",type:"N.A",f:.0201,k:.0602},{name:"STX 2",type:"N.A",f:.0181,k:.0435},{name:"α 1",type:"alpha",f:.01,k:.047},{name:"α 2",type:"alpha",f:.014,k:.053},{name:"β 1",type:"beta",f:.014,k:.039},{name:"β 2",type:"beta",f:.026,k:.051},{name:"δ 1",type:"delta",f:.03,k:.055},{name:"δ 2",type:"delta",f:.042,k:.059},{name:"ε 1",type:"epsilon",f:.018,k:.055},{name:"ε 2",type:"epsilon",f:.022,k:.059},{name:"η 1",type:"eta",f:.034,k:.063},{name:"γ 1",type:"gamma",f:.022,k:.051},{name:"γ 2",type:"gamma",f:.026,k:.055},{name:"ι 1",type:"iota",f:.046,k:.0594},{name:"κ 1",type:"kappa",f:.082,k:.06},{name:"κ 2",type:"kappa",f:.058,k:.063},{name:"λ 1",type:"lambda",f:.026,k:.061},{name:"λ 2",type:"lambda",f:.034,k:.065},{name:"μ 1",type:"mu",f:.046,k:.065},{name:"μ 2",type:"mu",f:.058,k:.065},{name:"ν 2",type:"nu",f:.046,k:.067},{name:"π 1",type:"pi",f:.062,k:.061},{name:"ρ 1",type:"rho",f:.09,k:.059},{name:"ρ 2",type:"rho",f:.102,k:.055},{name:"σ 1",type:"sigma",f:.09,k:.057},{name:"θ 2",type:"sigma",f:.11,k:.0523},{name:"θ 1",type:"theta",f:.03,k:.057},{name:"θ 2",type:"theta",f:.038,k:.061},{name:"ξ 1",type:"xi",f:.01,k:.041},{name:"ξ 2",type:"xi",f:.014,k:.047},{name:"ζ 1",type:"zeta",f:.022,k:.061},{name:"ζ 2",type:"zeta",f:.026,k:.059}];function Xt(a,e,n){const o=a.slice();return o[18]=e[n],o}function jt(a){let e,n,o,t,i,r,s,l,f,c=Ke,u=[];for(let p=0;p<c.length;p+=1)u[p]=Zt(Xt(a,c,p));return r=new Fe({props:{sketch:a[3]}}),{c(){e=B("div"),n=R("Select f and k parameters on the map of use a preset"),o=q(),t=B("select");for(let p=0;p<u.length;p+=1)u[p].c();i=q(),N(r.$$.fragment),this.h()},l(p){e=z(p,"DIV",{});var m=T(e);n=P(m,"Select f and k parameters on the map of use a preset"),m.forEach(h),o=Y(p),t=z(p,"SELECT",{class:!0});var d=T(t);for(let g=0;g<u.length;g+=1)u[g].l(d);d.forEach(h),i=Y(p),G(r.$$.fragment,p),this.h()},h(){y(t,"class","full-width svelte-1qznlxf"),a[0]===void 0&&it(()=>a[5].call(t))},m(p,m){A(p,e,m),w(e,n),A(p,o,m),A(p,t,m);for(let d=0;d<u.length;d+=1)u[d].m(t,null);Ve(t,a[0]),A(p,i,m),U(r,p,m),s=!0,l||(f=[Z(t,"change",a[5]),Z(t,"change",a[6])],l=!0)},p(p,m){if(m&0){c=Ke;let d;for(d=0;d<c.length;d+=1){const g=Xt(p,c,d);u[d]?u[d].p(g,m):(u[d]=Zt(g),u[d].c(),u[d].m(t,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}m&1&&Ve(t,p[0])},i(p){s||(_(r.$$.fragment,p),s=!0)},o(p){k(r.$$.fragment,p),s=!1},d(p){p&&h(e),p&&h(o),p&&h(t),ke(u,p),p&&h(i),O(r,p),l=!1,Be(f)}}}function Zt(a){let e,n=a[18].type+"",o,t,i=a[18].name+"",r,s,l=a[18].f+"",f,c,u=a[18].k+"",p,m;return{c(){e=B("option"),o=R(n),t=R(" - "),r=R(i),s=R(" (f/k "),f=R(l),c=R(" / "),p=R(u),m=R(`)
                `),this.h()},l(d){e=z(d,"OPTION",{});var g=T(e);o=P(g,n),t=P(g," - "),r=P(g,i),s=P(g," (f/k "),f=P(g,l),c=P(g," / "),p=P(g,u),m=P(g,`)
                `),g.forEach(h),this.h()},h(){e.__value=a[18],e.value=e.__value},m(d,g){A(d,e,g),w(e,o),w(e,t),w(e,r),w(e,s),w(e,f),w(e,c),w(e,p),w(e,m)},p:ne,d(d){d&&h(e)}}}function xl(a){let e,n,o=a[1]?"Close":"F/K selection",t,i,r,s,l,f=a[1]&&jt(a);return{c(){e=B("div"),n=B("button"),t=R(o),i=q(),f&&f.c(),this.h()},l(c){e=z(c,"DIV",{id:!0,class:!0});var u=T(e);n=z(u,"BUTTON",{class:!0,id:!0});var p=T(n);t=P(p,o),p.forEach(h),i=Y(u),f&&f.l(u),u.forEach(h),this.h()},h(){y(n,"class","full-width svelte-1qznlxf"),y(n,"id","toggleButton"),y(e,"id","container"),y(e,"class","svelte-1qznlxf"),Ie(e,"no-cursor",_l)},m(c,u){A(c,e,u),w(e,n),w(n,t),w(e,i),f&&f.m(e,null),r=!0,s||(l=Z(n,"click",a[4]),s=!0)},p(c,[u]){(!r||u&2)&&o!==(o=c[1]?"Close":"F/K selection")&&pe(t,o),c[1]?f?(f.p(c,u),u&2&&_(f,1)):(f=jt(c),f.c(),_(f,1),f.m(e,null)):f&&(oe(),k(f,1,1,()=>{f=null}),re())},i(c){r||(_(f),r=!0)},o(c){k(f),r=!1},d(c){c&&h(e),f&&f.d(),s=!1,l()}}}let _l=!1;function bl(a,e){let n=!1,o=1/0,t=null;for(let i=0;i<e.length;i++){const r=e[i],s=e[(i+1)%e.length];if(a[0]===r[0]&&a[1]===r[1])return a;r[1]>a[1]!=s[1]>a[1]&&a[0]<(s[0]-r[0])*(a[1]-r[1])/(s[1]-r[1])+r[0]&&(n=!n);const f=wl(a,r,s);f<o&&(o=f,t=$l(a,r,s))}if(n)return a;if(!t)throw new Error("Now closest point found");return t}function wl(a,e,n){const o=[n[0]-e[0],n[1]-e[1]],t=[a[0]-e[0],a[1]-e[1]],i=o[0]*t[0]+o[1]*t[1],r=o[0]*o[0]+o[1]*o[1],s=i/r;let l;return s<0?l=e:s>1?l=n:l=[e[0]+s*o[0],e[1]+s*o[1]],Math.sqrt((a[0]-l[0])**2+(a[1]-l[1])**2)}function $l(a,e,n){const o=[n[0]-e[0],n[1]-e[1]],t=[a[0]-e[0],a[1]-e[1]],i=o[0]*t[0]+o[1]*t[1],r=o[0]*o[0]+o[1]*o[1],s=i/r;let l;return s<0?l=e:s>1?l=n:l=[e[0]+s*o[0],e[1]+s*o[1]],l}function kl(a,e,n){const o=Ge();let t=Ke[0],i=!0;const r=[0,.12],s=[.03,.07],l=[{f:.1045,k:.0553},{f:.0829,k:.0582},{f:.0664,k:.0595},{f:.0511,k:.0594},{f:.0307,k:.0549},{f:.017,k:.0467},{f:.005,k:.0335},{f:.0076,k:.0472},{f:.0166,k:.0594},{f:.0277,k:.0657},{f:.046,k:.0675},{f:.0757,k:.0643},{f:.0949,k:.0594}],f=x=>{const{f:$,k:L}=x,D=C.map(L,s[0],s[1],0,C.width),b=C.map($,r[0],r[1],C.height,0);return{x:D,y:b}},c=x=>{x.noStroke();const $=x.textSize();for(const L of Ke){const{x:D,y:b}=f({f:L.f,k:L.k}),V=L.f===t.f&&L.k===t.k;x.circle(D,b,3),x.textSize(V?$*2:$),x.fill(V?[240,240,150]:[255,255,255]),x.text(L.name,D-x.textWidth(L.name)/2,b-10)}},u=x=>{x.noFill(),x.stroke("red"),x.strokeWeight(1);const{x:$,y:L}=f(t);x.text("F",10,L>10?L-5:L+15),x.line(0,L,x.width,L),x.text("K",$<x.width-10?$+5:$-15,x.height-10),x.line($,0,$,x.height),x.circle($,L,10)},p=x=>{const{f:$,k:L}=t,D=`F: ${$.toFixed(4)}`,b=`K: ${L.toFixed(4)}`,V=x.textSize(),X=x.height*.05;x.textStyle(x.BOLD),x.textSize(X),x.fill("white"),x.stroke(0),x.strokeWeight(1),x.text(D,x.width*.05,x.textSize()),x.text(b,x.width*.05,x.textSize()+x.textSize()+6),x.textStyle(x.NORMAL),x.textSize(V)},m=x=>{for(let $=0;$<l.length;$++){const{x:L,y:D}=f(l[$]),{x:b,y:V}=f(l[($+1)%l.length]);x.fill("white"),x.stroke("white"),x.strokeWeight(1),x.circle(L,D,3),x.circle(b,V,3),x.line(L,D,b,V)}},d=()=>{const x=[t.f,t.k],$=l.map(D=>[D.f,D.k]),L=bl(x,$);n(0,t.f=L[0],t),n(0,t.k=L[1],t)},g=()=>{let{f:x,k:$}=t;const L=C.noise(C.frameCount*.01),D=C.noise(5321+C.frameCount*.01),V=Math.random()<.97?.001:.01;x=x+(D*2-1)*(r[1]-r[0])*V,$=$+(L*2-1)*(s[1]-s[0])*V,n(0,t={f:x,k:$,name:"custom",type:"manual"}),d(),o("fkupdated",t)};let C;const E=x=>{C=x;let $;x.preload=()=>{$=x.loadImage(Ze+"/parameters_map.png")},x.setup=()=>{x.createCanvas(400,400),x.frameRate(55)},x.draw=()=>{x.background(255),x.tint(150,190),x.image($,0,0,x.width,x.height),c(x),m(x),u(x),p(x),g()}},S=()=>{n(1,i=!i),i||C.remove()};ye(()=>C?.remove());function M(){t=at(this),n(0,t)}return[t,i,o,E,S,M,()=>o("fkupdated",t)]}class yl extends Q{constructor(e){super(),J(this,e,kl,xl,ee,{})}}const Sl=`precision mediump float;
attribute vec2 position;
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,El=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    gl_FragColor = vec4(A, B, 0.0, 1.0);
}

`,Al=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float PI = 3.14159265359;
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = sin(iteration*PI/180.0);
    if (val < 0.0) {
        val = -1.0 * val;
    }
    gl_FragColor = vec4(A, B, val, 1.0);
}
`,Dl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (A + B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}

`,Bl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(1.0 - val, 1.0 - val, 1.0 - val, 1.0);
}
`,zl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float val = (1.0 + A - B) / 2.0;

    gl_FragColor = vec4(val, val, val, 1.0);
}
`,Cl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// All components are in the range [0...1], including hue. (https://stackoverflow.com/a/17897228)
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    // vec3 color1 = vec3(1.0, 0.0, 0.0);
    // vec3 color2 = vec3(0.0, 1.0, 0.0);
    // vec3 result = color1 * A + color2 * B;

    vec3 color1RGB = vec3(0.639, 0.941, 0.717);
    vec3 color2RGB = vec3(0.929, 0.082, 0.705);

    vec3 color1HSV = rgb2hsv(color1RGB);
    vec3 color2HSV = rgb2hsv(color2RGB);

    float color1Offset = (cos(iteration * 0.001) + 1.0) * 0.5;
    float color1newH = 0.5 * (color1HSV.x + color1Offset);
    vec3 color1newHSV = vec3(color1newH, color1HSV.g, color1HSV.b);

    float color2Offset = (cos(iteration * 0.002)) * 0.5;
    float color2newH = 0.5 * (color2HSV.x + color2Offset + 0.33);
    vec3 color2newHSV = vec3(color2newH, color2HSV.g, color2HSV.b);


    vec3 resultHSV = color1newHSV * A + color2newHSV * B;
    vec3 result = hsv2rgb(resultHSV);

    gl_FragColor = vec4(result, 1.0);
}
`,Tl=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    float red = A; // The more A the redder
    float blue = 1.0 - A; // The less A the bleuer

    float green = max(A, B) - min(A, B);

    vec3 result = vec3(red, green, blue);

    gl_FragColor = vec4(result, 1.0);
}
`,Il=`// Colors scheme inspired by Robert Munafo described here:
// https://www.mrob.com/pub/comp/xmorphia/index.html
// 
// A is blue
// B is red

precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec3 color1 = vec3(0.0, 0.0, 1.0);
    vec3 color2 = vec3(1.0, 0.0, 0.0);
    vec3 result = vec3(A, 0.0, 1.0-A);

    gl_FragColor = vec4(result, 1.0);
}
`,Ll=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    if (A > 0.9) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else if (A > 0.4) {
        gl_FragColor = vec4(1.0 - A, 0.0, 0.0, 1.0);
    } else { 
        gl_FragColor = vec4(0.0, A, 0.0, 1.0);
    }
}
`,Rl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);
    vec4 color = mix(blue, red, A);

    vec4 softRed = vec4(0.8588, 0.2824, 0.3765, 1.0);
    vec4 softBlue = vec4(0.2824, 0.3882, 0.8588, 1.0);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.6);
    // vec4 softColor = mix(blue, red, (A-0.4)/0.4);
    vec4 softColor = mix(softBlue, softRed, 1.0-A);


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(color);
    }

}
`,Pl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/MATLAB_cool.frag
float colormap_red(float x) {
    return (1.0 + 1.0 / 63.0) * x - 1.0 / 63.0;
}

float colormap_green(float x) {
    return -(1.0 + 1.0 / 63.0) * x + (1.0 + 1.0 / 63.0);
}

vec4 colormap(float x) {
    float r = clamp(colormap_red(x), 0.0, 1.0);
    float g = clamp(colormap_green(x), 0.0, 1.0);
    float b = 1.0;
    return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Fl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdBu.frag
float colormap_red(float x) {
	if (x < 0.09771832105856419) {
		return 7.60263247863246E+02 * x + 1.02931623931624E+02;
	} else if (x < 0.3017162107441106) {
		return (-2.54380938558548E+02 * x + 4.29911571188803E+02) * x + 1.37642085716717E+02;
	} else if (x < 0.4014205790737471) {
		return 8.67103448276151E+01 * x + 2.18034482758611E+02;
	} else if (x < 0.5019932233215039) {
		return -6.15461538461498E+01 * x + 2.77547692307680E+02;
	} else if (x < 0.5969483882550937) {
		return -3.77588522588624E+02 * x + 4.36198819698878E+02;
	} else if (x < 0.8046060096654594) {
		return (-6.51345897546620E+02 * x + 2.09780968434337E+02) * x + 3.17674951640855E+02;
	} else {
		return -3.08431855203590E+02 * x + 3.12956742081421E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09881640500975222) {
		return 2.41408547008547E+02 * x + 3.50427350427364E-01;
	} else if (x < 0.5000816285610199) {
		return ((((1.98531871433258E+04 * x - 2.64108262469187E+04) * x + 1.10991785969817E+04) * x - 1.92958444776211E+03) * x + 8.39569642882186E+02) * x - 4.82944517518776E+01;
	} else if (x < 0.8922355473041534) {
		return (((6.16712686949223E+03 * x - 1.59084026055125E+04) * x + 1.45172137257997E+04) * x - 5.80944127411621E+03) * x + 1.12477959061948E+03;
	} else {
		return -5.28313797313699E+02 * x + 5.78459299959206E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.1033699568661857) {
		return 1.30256410256410E+02 * x + 3.08518518518519E+01;
	} else if (x < 0.2037526071071625) {
		return 3.38458128078815E+02 * x + 9.33004926108412E+00;
	} else if (x < 0.2973267734050751) {
		return (-1.06345054944861E+02 * x + 5.93327252747168E+02) * x - 3.81852747252658E+01;
	} else if (x < 0.4029109179973602) {
		return 6.68959706959723E+02 * x - 7.00740740740798E+01;
	} else if (x < 0.5006715489526758) {
		return 4.87348695652202E+02 * x + 3.09898550724286E+00;
	} else if (x < 0.6004396902588283) {
		return -6.85799999999829E+01 * x + 2.81436666666663E+02;
	} else if (x < 0.702576607465744) {
		return -1.81331701891043E+02 * x + 3.49137263626287E+02;
	} else if (x < 0.9010407030582428) {
		return (2.06124143164576E+02 * x - 5.78166906665595E+02) * x + 5.26198653917172E+02;
	} else {
		return -7.36990769230737E+02 * x + 8.36652307692262E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Ml=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Nl=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap(1.0 - (A-0.4)*(1.0/0.6));


    if (A > 0.6) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Ul=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/transform_seismic.frag
float colormap_f(float x) {
    return ((-2010.0 * x + 2502.5950459) * x - 481.763180924) / 255.0;
}

float colormap_red(float x) {
    if (x < 0.0) {
        return 3.0 / 255.0;
    } else if (x < 0.238) {
        return ((-1810.0 * x + 414.49) * x + 3.87702) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return (344441250.0 / 323659.0 * x - 23422005.0 / 92474.0) / 255.0;
    } else if (x < 25851.0 / 34402.0) {
        return 1.0;
    } else if (x <= 1.0) {
        return (-688.04 * x + 772.02) / 255.0;
    } else {
        return 83.0 / 255.0;
    }
}

float colormap_green(float x) {
    if (x < 0.0) {
        return 0.0;
    } else if (x < 0.238) {
        return 0.0;
    } else if (x < 51611.0 / 108060.0) {
        return colormap_f(x);
    } else if (x < 0.739376978894039) {
        float xx = x - 51611.0 / 108060.0;
        return ((-914.74 * xx - 734.72) * xx + 255.) / 255.0;
    } else {
        return 0.0;
    }
}

float colormap_blue(float x) {
    if (x < 0.0) {
        return 19.0 / 255.0;
    } else if (x < 0.238) {
        float xx = x - 0.238;
        return (((1624.6 * xx + 1191.4) * xx + 1180.2) * xx + 255.0) / 255.0;
    } else if (x < 51611.0 / 108060.0) {
        return 1.0;
    } else if (x < 174.5 / 256.0) {
        return (-951.67322673866 * x + 709.532730938451) / 255.0;
    } else if (x < 0.745745353439206) {
        return (-705.250074130877 * x + 559.620050530617) / 255.0;
    } else if (x <= 1.0) {
        return ((-399.29 * x + 655.71) * x - 233.25) / 255.0;
    } else {
        return 23.0 / 255.0;
    }
}

vec4 colormap(float x) {
    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((A-0.4)*(1.0/0.6));


    if (A < 0.4) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,Ol=`precision mediump float;

uniform sampler2D prevState;
uniform float iteration;
varying vec2 uv;

// https://github.com/Polymole/glsl-colormap/blob/master/shaders/IDL_CB-RdYiBu.frag
float colormap_red(float x) {
	if (x < 0.09790863520700754) {
		return 5.14512820512820E+02 * x + 1.64641025641026E+02;
	} else if (x < 0.2001887081633112) {
		return 2.83195402298854E+02 * x + 1.87288998357964E+02;
	} else if (x < 0.3190117539655621) {
		return 9.27301587301214E+01 * x + 2.25417989417999E+02;
	} else if (x < 0.500517389125164) {
		return 255.0;
	} else if (x < 0.6068377196788788) {
		return -3.04674876847379E+02 * x + 4.07495073891681E+02;
	} else if (x < 0.9017468988895416) {
		return (1.55336390191951E+02 * x - 7.56394659038288E+02) * x + 6.24412733169483E+02;
	} else {
		return -1.88350769230735E+02 * x + 2.38492307692292E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09638568758964539) {
		return 4.81427692307692E+02 * x + 4.61538461538488E-01;
	} else if (x < 0.4987066686153412) {
		return ((((3.25545903568267E+04 * x - 4.24067109461319E+04) * x + 1.83751375886345E+04) * x - 3.19145329617892E+03) * x + 8.08315127034676E+02) * x - 1.44611527812961E+01;
	} else if (x < 0.6047312345537269) {
		return -1.18449917898218E+02 * x + 3.14234811165860E+02;
	} else if (x < 0.7067635953426361) {
		return -2.70822112753102E+02 * x + 4.06379036672115E+02;
	} else {
		return (-4.62308723214883E+02 * x + 2.42936159122279E+02) * x + 2.74203431802418E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.09982818011951204) {
		return 1.64123076923076E+01 * x + 3.72646153846154E+01;
	} else if (x < 0.2958717460833126) {
		return 2.87014675052409E+02 * x + 1.02508735150248E+01;
	} else if (x < 0.4900527540014758) {
		return 4.65475113122167E+02 * x - 4.25505279034673E+01;
	} else if (x < 0.6017014681258838) {
		return 5.61032967032998E+02 * x - 8.93789173789407E+01;
	} else if (x < 0.7015737100463595) {
		return -1.51655677655728E+02 * x + 3.39446886446912E+02;
	} else if (x < 0.8237156500567735) {
		return -2.43405347593559E+02 * x + 4.03816042780725E+02;
	} else {
		return -3.00296889157305E+02 * x + 4.50678495922638E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);

    vec4 softColor = colormap((B-0.1)*(1.0/0.9));


    if (B < 0.1) {
        gl_FragColor = vec4(black);
    } else {
        gl_FragColor = vec4(softColor);
    }

}
`,ge={},Vl=a=>{const e={vert:Sl,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{iteration:a.prop("iteration"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}};ge.raw=a({frag:El,...e}),ge.A_transform_seismic=a({frag:Ul,...e}),ge.A_gradiant1=a({frag:Ll,...e}),ge.A_gradiant2=a({frag:Rl,...e}),ge.A_MATLAB_cool=a({frag:Pl,...e}),ge.A_IDL_CB_RdBu=a({frag:Fl,...e}),ge.A_IDL_CB_RdYiBu=a({frag:Ml,...e}),ge.A_IDL_CB_BuYiRd=a({frag:Nl,...e}),ge.B_IDL_CB_RdYiBu=a({frag:Ol,...e}),ge.grayscale=a({frag:Dl,...e}),ge.blackwhite=a({frag:Bl,...e}),ge.whiteblack=a({frag:zl,...e}),ge.timebasedblue=a({frag:Al,...e}),ge.lerp=a({frag:Cl,...e}),ge.mrob=a({frag:Tl,...e}),ge.redblue=a({frag:Il,...e})},Hl=a=>{const{colorMode:e,inputBuffer:n,iteration:o,outputBuffer:t,zoomState:i}=a;(ge[e]||ge.raw)({inputBuffer:n,iteration:o,outputBuffer:t,pan:[i.panX,i.panY],zoomLevel:i.zoomLevel})},Kl=`precision mediump float;

uniform float radius;
uniform sampler2D prevState;
uniform bool pauseSimulation;
uniform float Da;
uniform float Db;
uniform float f;
uniform float k;

uniform bool penIsActive;
uniform bool eraserIsActive;
uniform float penDensity;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

// https://thebookofshaders.com/10/
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
}

vec2 laplacianDiff() {
    vec2 r = vec2(0.0, 0.0);

    // top left
    r += texture2D(prevState, uv+vec2(-1,-1)/float(radius)).rg * 0.05;
    // top
    r += texture2D(prevState, uv+vec2(0,-1)/float(radius)).rg * 0.2;
    // top right
    r += texture2D(prevState, uv+vec2(1,-1)/float(radius)).rg * 0.05;

    // left
    r += texture2D(prevState, uv+vec2(-1,0)/float(radius)).rg * 0.2;
    // middle
    r += texture2D(prevState, uv+vec2(0,0)/float(radius)).rg * -1.0;
    // right
    r += texture2D(prevState, uv+vec2(1,0)/float(radius)).rg * 0.2;

    // bottom left
    r += texture2D(prevState, uv+vec2(-1,1)/float(radius)).rg * 0.05;
    // bottom
    r += texture2D(prevState, uv+vec2(0,1)/float(radius)).rg * 0.2;
    // bottom right
    r += texture2D(prevState, uv+vec2(1,1)/float(radius)).rg * 0.05;

    return r;
}

void main() {
    float A = texture2D(prevState, uv).r;
    float B = texture2D(prevState, uv).g;

    vec2 L = laplacianDiff();
    float La = L.r;
    float Lb = L.g;

    float newA = A + ((Da * La) - (A * B * B) + (f * (1.0 - A)));
    float newB = B + ((Db * Lb) + (A * B * B) - ((k + f) * B));


    float rnd = random(uv);
    if (penIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(0.0, 1.0, 0, 1);
    } else if (eraserIsActive && rnd < penDensity && distance(uv, mouseUv) < scaledPenRadius) {
        gl_FragColor = vec4(1.0, 0.0, 0, 1);
    } else if (pauseSimulation) {
        gl_FragColor = vec4(A, B, 0, 1);
    } else {
        gl_FragColor = vec4(newA, newB, 0, 1);
    }
}
`,ql=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right
uniform float penRadius;

attribute vec2 position;

varying vec2 uv;
varying vec2 mouseUv;
varying float scaledPenRadius;

void main() {
    uv = 0.5 * (position + 1.0);
    mouseUv = (mousePosition * zoomLevel) + pan * (1.0 - zoomLevel);
    scaledPenRadius = penRadius * zoomLevel;
    gl_Position = vec4(position, 0, 1);
}
`;let wn;const Yl=(a,e)=>{wn=a({frag:Kl,vert:ql,attributes:{position:[-4,-4,4,-4,0,4]},count:3,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),Da:1,Db:.5,f:a.prop("f"),k:a.prop("k"),radius:e,pauseSimulation:a.prop("pauseSimulation"),mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),penDensity:a.prop("penDensity"),penIsActive:a.prop("penIsActive"),eraserIsActive:a.prop("eraserIsActive"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},Gl=a=>{const{inputBuffer:e,outputBuffer:n,pauseSimulation:o,mouseState:t,simulationParameters:i,worldSize:r}=a;wn({inputBuffer:e,outputBuffer:n,pauseSimulation:o,zoomLevel:t.zoomLevel,pan:[t.panX,t.panY],mousePosition:[t.x,t.y],penRadius:1/2**(r-t.penSize),penDensity:t.penDensity,penIsActive:t.pressedLeft,eraserIsActive:t.pressedRight,...i})},Wl=(a,e)=>a==="randomSpots"?Zl(e,.001):a==="middleCircleAndRandomSpots"?Xl(e,.005,.05):a==="empty"?jl(e):Ql(e,.02),Xl=(a,e,n)=>{const o=a*n;return Array(a*a).fill(0).map((t,i)=>{const r=Math.floor(i/a),s=i%a;return Math.hypot(a/2-s,a/2-r)<o?[0,1,0,1]:Math.random()<e?[0,1,0,1]:[1,0,0,1]}).flat()},jl=a=>Array(a*a).fill(0).map(()=>[0,0,0,1]).flat(),Zl=(a,e)=>Array(a*a).fill(0).map(()=>Math.random()<e?[0,1,0,1]:[1,0,0,1]).flat(),Ql=(a,e)=>Array(a*a).fill(0).map((n,o)=>{const t=Math.floor(o/a),i=o%a;return Math.hypot(a/2-i,a/2-t)<e*a?[0,1,0,1]:[1,0,0,1]}).flat(),Jl=`precision highp float;

attribute vec2 position;

uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0) * zoomLevel + pan * (1.0 - zoomLevel);
    gl_Position = vec4(position, 0, 1);
}
`,es=`precision highp float;

uniform sampler2D prevState;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float division = 10.0;
    float column = mod(uv.x, 1.0 / division);
    float c = column * division;

    float row = mod(uv.y, 1.0 / division);
    float r = row * division;

    // I haven't found a way to compare the value to an exact value
    // Might be a precision issue, or just that I'm missing something
    if (c < 0.05 || r < 0.05) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
       gl_FragColor = color;
    }
}
`;let $n;const ts=a=>{$n=a({vert:Jl,frag:es,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{prevState:a.prop("inputBuffer"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan")}})},ns=a=>{const{inputBuffer:e,outputBuffer:n,zoomState:o}=a;$n({inputBuffer:e,outputBuffer:n,zoomLevel:o.zoomLevel,pan:[o.panX,o.panY]})},os=`precision mediump float;

uniform vec2 mousePosition; // in range [0, 1] on the zoomed screen
uniform float zoomLevel;    // 1 full size, 0 max zoom
uniform vec2 pan;   // in range [0, 1], [0, 0]  is bottom left, [1, 1] top right

attribute vec2 position;

varying vec2 uv;

void main() {
    uv = 0.5 * (position + 1.0);
    gl_Position = vec4(position, 0, 1);
}
`,rs=`precision mediump float;

uniform sampler2D prevState;
uniform vec2 mousePosition;
uniform float penRadius;

varying vec2 uv;

void main() {
    vec4 color = texture2D(prevState, uv);

    float d = distance(uv, mousePosition);
    if (
        (d >= penRadius && d <= penRadius + 0.001) ||
        (uv.x >= mousePosition.x - 0.001 && uv.x <= mousePosition.x + 0.001 && uv.y >= mousePosition.y - 0.01 && uv.y <= mousePosition.y + 0.01) ||
        (uv.x >= mousePosition.x - 0.01 && uv.x <= mousePosition.x + 0.01 && uv.y >= mousePosition.y - 0.001 && uv.y <= mousePosition.y + 0.001))
    {
        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    } else {
        gl_FragColor = color;
    }
}
`;let kn;const is=a=>{kn=a({frag:rs,vert:os,attributes:{position:[[1,-1],[-1,-1],[1,1],[1,1],[-1,-1],[-1,1]]},count:6,framebuffer:a.prop("outputBuffer"),uniforms:{mousePosition:a.prop("mousePosition"),penRadius:a.prop("penRadius"),zoomLevel:a.prop("zoomLevel"),pan:a.prop("pan"),prevState:a.prop("inputBuffer")}})},as=a=>{const{inputBuffer:e,mouseState:n,outputBuffer:o,worldSize:t}=a;kn({inputBuffer:e,outputBuffer:o,mousePosition:[n.x,n.y],penRadius:1/2**(t-n.penSize),zoomLevel:n.zoomLevel,pan:[n.panX,n.panY]})},ls=a=>{const{controls:e,info:n,mouseState:o,simulationParameters:t}=a,i=document.getElementById("canvas");if(!i)throw new Error("Canvas container not ready");const r=Le({extensions:["OES_texture_float"],canvas:i});n.iteration=0;const s=2**n.worldSize,l=Wl(e.initialConditions,s),f=()=>r.framebuffer({color:r.texture({radius:s,data:l,wrap:"repeat",type:"float"}),depthStencil:!1}),c=Array(2).fill(0).map(f),u=Array(2).fill(0).map(f);return Yl(r,s),Vl(r),ts(r),is(r),r.frame(()=>{e.pause||n.iteration++;let p=c[(n.iteration+1)%2];for(let m=0;m<e.speed;m++){n.iteration++;const d=c[n.iteration%2];p=c[(n.iteration+1)%2],Gl({inputBuffer:d,outputBuffer:p,worldSize:n.worldSize,pauseSimulation:e.pause,mouseState:o,simulationParameters:t})}ss({inputTexture:p,graphicsTextures:u,controls:e,info:n,mouseState:o})}),r},ss=a=>{const{inputTexture:e,graphicsTextures:n,controls:o,info:t,mouseState:i}=a;let r=0;r++;const s=e;let l=n[r%2];if(!o.grid&&!o.pen&&(l=null),Hl({colorMode:o.colors,inputBuffer:s,iteration:t.iteration,outputBuffer:l,zoomState:i}),o.grid){r++;const f=n[(r+1)%2];let c=n[r%2];o.pen||(c=null),ns({inputBuffer:f,outputBuffer:c,zoomState:i})}if(o.pen){r++;const f=n[(r+1)%2],c=null;as({mouseState:i,worldSize:t.worldSize,inputBuffer:f,outputBuffer:c})}};const{window:fs}=je;function cs(a){let e,n,o,t,i,r,s,l,f,c,u,p,m,d=2**a[0].worldSize+"",g,C,E=2**a[0].worldSize+"",S,M,v=2**(a[0].worldSize+1)+"",x,$,L,D,b,V,X;return n=new yl({}),n.$on("fkupdated",a[4]),{c(){e=B("main"),N(n.$$.fragment),o=q(),t=B("div"),i=q(),r=B("div"),s=B("label"),l=R("World Size:"),f=q(),c=B("input"),u=q(),p=B("span"),m=R("("),g=R(d),C=R(" x "),S=R(E),M=R(" : "),x=R(v),$=R(")"),L=q(),D=B("canvas"),this.h()},l(I){e=z(I,"MAIN",{});var F=T(e);G(n.$$.fragment,F),o=Y(F),t=z(F,"DIV",{id:!0,class:!0}),T(t).forEach(h),i=Y(F),r=z(F,"DIV",{});var te=T(r);s=z(te,"LABEL",{for:!0});var xe=T(s);l=P(xe,"World Size:"),xe.forEach(h),f=Y(te),c=z(te,"INPUT",{id:!0,type:!0,step:!0}),u=Y(te),p=z(te,"SPAN",{});var ae=T(p);m=P(ae,"("),g=P(ae,d),C=P(ae," x "),S=P(ae,E),M=P(ae," : "),x=P(ae,v),$=P(ae,")"),ae.forEach(h),te.forEach(h),L=Y(F),D=z(F,"CANVAS",{id:!0,width:!0,height:!0,class:!0}),T(D).forEach(h),F.forEach(h),this.h()},h(){y(t,"id","datgui-container"),y(t,"class","svelte-18zf5fr"),y(s,"for","worldSize"),y(c,"id","worldSize"),y(c,"type","number"),y(c,"step","1"),y(D,"id","canvas"),y(D,"width",a[1].width),y(D,"height",a[1].height),y(D,"class","svelte-18zf5fr")},m(I,F){A(I,e,F),U(n,e,null),w(e,o),w(e,t),w(e,i),w(e,r),w(r,s),w(s,l),w(r,f),w(r,c),Se(c,a[0].worldSize),w(r,u),w(r,p),w(p,m),w(p,g),w(p,C),w(p,S),w(p,M),w(p,x),w(p,$),w(e,L),w(e,D),b=!0,V||(X=[Z(fs,"keydown",a[2]),Z(c,"input",a[5]),Z(c,"change",a[3]),Z(D,"contextmenu",we(us))],V=!0)},p(I,[F]){F&1&&Ae(c.value)!==I[0].worldSize&&Se(c,I[0].worldSize),(!b||F&1)&&d!==(d=2**I[0].worldSize+"")&&pe(g,d),(!b||F&1)&&E!==(E=2**I[0].worldSize+"")&&pe(S,E),(!b||F&1)&&v!==(v=2**(I[0].worldSize+1)+"")&&pe(x,v)},i(I){b||(_(n.$$.fragment,I),b=!0)},o(I){k(n.$$.fragment,I),b=!1},d(I){I&&h(e),O(n),V=!1,Be(X)}}}const us=a=>a;function ps(a,e,n){const o={width:Math.min(window.innerWidth,window.innerHeight)*.9,height:Math.min(window.innerWidth,window.innerHeight)*.9},t={colors:"A_transform_seismic",initialConditions:"middleCircleAndRandomSpots",reset:()=>d(),pause:!1,grid:!1,pen:!1,speed:50},i={pressedLeft:!1,pressedRight:!1,x:0,y:0,penSize:3,penDensity:.3,zoomLevel:1,panX:.5,panY:.5},r={iteration:0,worldSize:8},s={f:Ke[0].f,k:Ke[0].k};let l,f;const c=async()=>{const E=await Te(()=>import("../../../chunks/dat.gui.module-69d90d27.js"),[],import.meta.url);l=new E.GUI({autoPlace:!1,closeOnTop:!0}),l.domElement.id="datgui";const S=document.getElementById("datgui-container");if(!S)throw new Error("Gui container not ready");S.appendChild(l.domElement),l.add(t,"pause").name("Pause"),l.add(t,"grid").name("Debug grid"),l.add(t,"pen").name("Show pen"),l.add(t,"reset").name("Reset simulation"),l.add(t,"colors",["grayscale","blackwhite","whiteblack","raw","timebasedblue","lerp","mrob","redblue","A_gradiant1","A_gradiant2","A_MATLAB_cool","A_IDL_CB_RdBu","A_IDL_CB_RdYiBu","A_IDL_CB_BuYiRd","A_transform_seismic","B_IDL_CB_RdYiBu"]).name("Color scheme");const M={"Random spots":"randomSpots","Middle spot":"middleSpot","Middle + random":"middleCircleAndRandomSpots",Empty:"empty"};l.add(t,"initialConditions",M).onFinishChange(t.reset).name("Initial conditions");const v=l.add(r,"iteration").listen();v.domElement.style.pointerEvents="none",l.add(t,"speed",1,200).name("Simulation speed").listen(),l.add(i,"penSize",0,r.worldSize).name("Pen size").listen(),l.add(i,"penDensity",0,1).name("Pen density"),l.add(i,"zoomLevel",0,1).name("Zoom level").listen(),l.add(i,"panX",0,1).name("pan x").listen(),l.add(i,"panY",0,1).name("pan y").listen()},u=E=>{if(E.code==="Space"){t.pause=!t.pause,E.preventDefault();return}if(E.code==="KeyR"&&!E.getModifierState("Control")){d(),E.preventDefault();return}};let p;const m=()=>{i.x=Math.random(),i.y=Math.random(),i.penSize=Math.random()*3,i.pressedLeft=!0,setTimeout(()=>i.pressedLeft=!1,500),p=setTimeout(m,Math.random()*5e3)},d=()=>{isNaN(r.worldSize)||(r.worldSize>11&&n(0,r.worldSize=11,r),r.worldSize<1&&n(0,r.worldSize=1,r),l&&(document.getElementById(l.domElement.id)?.remove(),l.destroy()),f?.destroy(),c(),f=ls({controls:t,info:r,mouseState:i,simulationParameters:s}),p&&clearTimeout(p),m())},g=E=>{s.f=E.detail.f,s.k=E.detail.k,s.f>.03?t.speed=50:t.speed=2};$e(()=>{d()}),ye(()=>{l.destroy(),f.destroy()});function C(){r.worldSize=Ae(this.value),n(0,r)}return[r,o,u,d,g,C]}let ms=class extends Q{constructor(e){super(),J(this,e,ps,cs,ee,{})}};function Qt(a,e,n){const o=a.slice();return o[1]=e[n],o}function Jt(a,e,n){const o=a.slice();return o[1]=e[n],o}function ds(a){let e=a[1].title+"",n;return{c(){n=R(e)},l(o){n=P(o,e)},m(o,t){A(o,n,t)},p:ne,d(o){o&&h(n)}}}function en(a){let e,n;return e=new Ne({props:{$$slots:{default:[ds]},$$scope:{ctx:a}}}),{c(){N(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){U(e,o,t),n=!0},p(o,t){const i={};t&64&&(i.$$scope={dirty:t,ctx:o}),e.$set(i)},i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){O(e,o)}}}function hs(a){let e,n,o=a[0],t=[];for(let r=0;r<o.length;r+=1)t[r]=en(Jt(a,o,r));const i=r=>k(t[r],1,1,()=>{t[r]=null});return{c(){for(let r=0;r<t.length;r+=1)t[r].c();e=K()},l(r){for(let s=0;s<t.length;s+=1)t[s].l(r);e=K()},m(r,s){for(let l=0;l<t.length;l+=1)t[l].m(r,s);A(r,e,s),n=!0},p(r,s){if(s&1){o=r[0];let l;for(l=0;l<o.length;l+=1){const f=Jt(r,o,l);t[l]?(t[l].p(f,s),_(t[l],1)):(t[l]=en(f),t[l].c(),_(t[l],1),t[l].m(e.parentNode,e))}for(oe(),l=o.length;l<t.length;l+=1)i(l);re()}},i(r){if(!n){for(let s=0;s<o.length;s+=1)_(t[s]);n=!0}},o(r){t=t.filter(Boolean);for(let s=0;s<t.length;s+=1)k(t[s]);n=!1},d(r){ke(t,r),r&&h(e)}}}function vs(a){let e,n,o;var t=a[1].component;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&N(e.$$.fragment),n=q()},l(r){e&&G(e.$$.fragment,r),n=Y(r)},m(r,s){e&&U(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=r[1].component)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{O(l,1)}),re()}t?(e=ie(t,i()),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){e&&O(e,r),r&&h(n)}}}function tn(a){let e,n;return e=new Me({props:{$$slots:{default:[vs]},$$scope:{ctx:a}}}),{c(){N(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){U(e,o,t),n=!0},p(o,t){const i={};t&64&&(i.$$scope={dirty:t,ctx:o}),e.$set(i)},i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){O(e,o)}}}function gs(a){let e,n,o,t;e=new rn({props:{$$slots:{default:[hs]},$$scope:{ctx:a}}});let i=a[0],r=[];for(let l=0;l<i.length;l+=1)r[l]=tn(Qt(a,i,l));const s=l=>k(r[l],1,1,()=>{r[l]=null});return{c(){N(e.$$.fragment),n=q();for(let l=0;l<r.length;l+=1)r[l].c();o=K()},l(l){G(e.$$.fragment,l),n=Y(l);for(let f=0;f<r.length;f+=1)r[f].l(l);o=K()},m(l,f){U(e,l,f),A(l,n,f);for(let c=0;c<r.length;c+=1)r[c].m(l,f);A(l,o,f),t=!0},p(l,f){const c={};if(f&64&&(c.$$scope={dirty:f,ctx:l}),e.$set(c),f&1){i=l[0];let u;for(u=0;u<i.length;u+=1){const p=Qt(l,i,u);r[u]?(r[u].p(p,f),_(r[u],1)):(r[u]=tn(p),r[u].c(),_(r[u],1),r[u].m(o.parentNode,o))}for(oe(),u=i.length;u<r.length;u+=1)s(u);re()}},i(l){if(!t){_(e.$$.fragment,l);for(let f=0;f<i.length;f+=1)_(r[f]);t=!0}},o(l){k(e.$$.fragment,l),r=r.filter(Boolean);for(let f=0;f<r.length;f+=1)k(r[f]);t=!1},d(l){O(e,l),l&&h(n),ke(r,l),l&&h(o)}}}function xs(a){let e,n,o,t,i,r,s,l,f,c,u,p,m;return p=new on({props:{$$slots:{default:[gs]},$$scope:{ctx:a}}}),{c(){e=B("p"),n=R(`Here is a list of the various iterations I have made before I got the final version of this
    project.`),o=q(),t=B("div"),i=B("p"),r=R(`Some of the previous versions have a bug and the code is not cleaned up properly when the
        page unload. Which make that when navigating between different versions it is possible to
        end up in a state where several simulation are running in parallel.`),s=q(),l=B("p"),f=R(`To avoid this kind of issues make sure the refresh the page each time you select a new
        version`),c=q(),u=B("div"),N(p.$$.fragment),this.h()},l(d){e=z(d,"P",{});var g=T(e);n=P(g,`Here is a list of the various iterations I have made before I got the final version of this
    project.`),g.forEach(h),o=Y(d),t=z(d,"DIV",{class:!0});var C=T(t);i=z(C,"P",{});var E=T(i);r=P(E,`Some of the previous versions have a bug and the code is not cleaned up properly when the
        page unload. Which make that when navigating between different versions it is possible to
        end up in a state where several simulation are running in parallel.`),E.forEach(h),s=Y(C),l=z(C,"P",{});var S=T(l);f=P(S,`To avoid this kind of issues make sure the refresh the page each time you select a new
        version`),S.forEach(h),C.forEach(h),c=Y(d),u=z(d,"DIV",{});var M=T(u);G(p.$$.fragment,M),M.forEach(h),this.h()},h(){y(t,"class","warning")},m(d,g){A(d,e,g),w(e,n),A(d,o,g),A(d,t,g),w(t,i),w(i,r),w(t,s),w(t,l),w(l,f),A(d,c,g),A(d,u,g),U(p,u,null),m=!0},p(d,[g]){const C={};g&64&&(C.$$scope={dirty:g,ctx:d}),p.$set(C)},i(d){m||(_(p.$$.fragment,d),m=!0)},o(d){k(p.$$.fragment,d),m=!1},d(d){d&&h(e),d&&h(o),d&&h(t),d&&h(c),d&&h(u),O(p)}}}function _s(a){return[[{title:"Auto visualizer",component:ms},{title:"V7",component:gl},{title:"Parameters map",component:rt},{title:"V6",component:Sa},{title:"V5",component:ha},{title:"V4",component:fa},{title:"V3",component:aa},{title:"V2",component:ji},{title:"V1",component:Ui}]]}class nn extends Q{constructor(e){super(),J(this,e,_s,xs,ee,{})}}function bs(a){let e;return{c(){e=R("About")},l(n){e=P(n,"About")},m(n,o){A(n,e,o)},d(n){n&&h(e)}}}function ws(a){let e;return{c(){e=R("Auto")},l(n){e=P(n,"Auto")},m(n,o){A(n,e,o)},d(n){n&&h(e)}}}function $s(a){let e;return{c(){e=R("Manual")},l(n){e=P(n,"Manual")},m(n,o){A(n,e,o)},d(n){n&&h(e)}}}function ks(a){let e;return{c(){e=R("Parameters map")},l(n){e=P(n,"Parameters map")},m(n,o){A(n,e,o)},d(n){n&&h(e)}}}function ys(a){let e;return{c(){e=R("Previous versions")},l(n){e=P(n,"Previous versions")},m(n,o){A(n,e,o)},d(n){n&&h(e)}}}function Ss(a){let e,n,o,t,i,r,s,l,f,c;return e=new Ne({props:{$$slots:{default:[bs]},$$scope:{ctx:a}}}),o=new Ne({props:{$$slots:{default:[ws]},$$scope:{ctx:a}}}),i=new Ne({props:{$$slots:{default:[$s]},$$scope:{ctx:a}}}),s=new Ne({props:{$$slots:{default:[ks]},$$scope:{ctx:a}}}),f=new Ne({props:{$$slots:{default:[ys]},$$scope:{ctx:a}}}),{c(){N(e.$$.fragment),n=q(),N(o.$$.fragment),t=q(),N(i.$$.fragment),r=q(),N(s.$$.fragment),l=q(),N(f.$$.fragment)},l(u){G(e.$$.fragment,u),n=Y(u),G(o.$$.fragment,u),t=Y(u),G(i.$$.fragment,u),r=Y(u),G(s.$$.fragment,u),l=Y(u),G(f.$$.fragment,u)},m(u,p){U(e,u,p),A(u,n,p),U(o,u,p),A(u,t,p),U(i,u,p),A(u,r,p),U(s,u,p),A(u,l,p),U(f,u,p),c=!0},p(u,p){const m={};p&1&&(m.$$scope={dirty:p,ctx:u}),e.$set(m);const d={};p&1&&(d.$$scope={dirty:p,ctx:u}),o.$set(d);const g={};p&1&&(g.$$scope={dirty:p,ctx:u}),i.$set(g);const C={};p&1&&(C.$$scope={dirty:p,ctx:u}),s.$set(C);const E={};p&1&&(E.$$scope={dirty:p,ctx:u}),f.$set(E)},i(u){c||(_(e.$$.fragment,u),_(o.$$.fragment,u),_(i.$$.fragment,u),_(s.$$.fragment,u),_(f.$$.fragment,u),c=!0)},o(u){k(e.$$.fragment,u),k(o.$$.fragment,u),k(i.$$.fragment,u),k(s.$$.fragment,u),k(f.$$.fragment,u),c=!1},d(u){O(e,u),u&&h(n),O(o,u),u&&h(t),O(i,u),u&&h(r),O(s,u),u&&h(l),O(f,u)}}}function Es(a){let e,n,o;var t=Bt;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&N(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&U(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=Bt)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{O(l,1)}),re()}t?(e=ie(t,i()),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&O(e,r)}}}function As(a){let e,n,o;var t=Ct;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&N(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&U(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=Ct)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{O(l,1)}),re()}t?(e=ie(t,i()),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&O(e,r)}}}function Ds(a){let e,n,o;var t=Pt;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&N(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&U(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=Pt)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{O(l,1)}),re()}t?(e=ie(t,i()),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&O(e,r)}}}function Bs(a){let e,n,o;var t=rt;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&N(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&U(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=rt)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{O(l,1)}),re()}t?(e=ie(t,i()),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&O(e,r)}}}function zs(a){let e,n,o;var t=nn;function i(r){return{}}return t&&(e=ie(t,i())),{c(){e&&N(e.$$.fragment),n=K()},l(r){e&&G(e.$$.fragment,r),n=K()},m(r,s){e&&U(e,r,s),A(r,n,s),o=!0},p(r,s){if(t!==(t=nn)){if(e){oe();const l=e;k(l.$$.fragment,1,0,()=>{O(l,1)}),re()}t?(e=ie(t,i()),N(e.$$.fragment),_(e.$$.fragment,1),U(e,n.parentNode,n)):e=null}},i(r){o||(e&&_(e.$$.fragment,r),o=!0)},o(r){e&&k(e.$$.fragment,r),o=!1},d(r){r&&h(n),e&&O(e,r)}}}function Cs(a){let e,n,o,t,i,r,s,l,f,c,u,p;return e=new rn({props:{$$slots:{default:[Ss]},$$scope:{ctx:a}}}),o=new Me({props:{$$slots:{default:[Es]},$$scope:{ctx:a}}}),i=new Me({props:{$$slots:{default:[As]},$$scope:{ctx:a}}}),s=new Me({props:{$$slots:{default:[Ds]},$$scope:{ctx:a}}}),f=new Me({props:{$$slots:{default:[Bs]},$$scope:{ctx:a}}}),u=new Me({props:{$$slots:{default:[zs]},$$scope:{ctx:a}}}),{c(){N(e.$$.fragment),n=q(),N(o.$$.fragment),t=q(),N(i.$$.fragment),r=q(),N(s.$$.fragment),l=q(),N(f.$$.fragment),c=q(),N(u.$$.fragment)},l(m){G(e.$$.fragment,m),n=Y(m),G(o.$$.fragment,m),t=Y(m),G(i.$$.fragment,m),r=Y(m),G(s.$$.fragment,m),l=Y(m),G(f.$$.fragment,m),c=Y(m),G(u.$$.fragment,m)},m(m,d){U(e,m,d),A(m,n,d),U(o,m,d),A(m,t,d),U(i,m,d),A(m,r,d),U(s,m,d),A(m,l,d),U(f,m,d),A(m,c,d),U(u,m,d),p=!0},p(m,d){const g={};d&1&&(g.$$scope={dirty:d,ctx:m}),e.$set(g);const C={};d&1&&(C.$$scope={dirty:d,ctx:m}),o.$set(C);const E={};d&1&&(E.$$scope={dirty:d,ctx:m}),i.$set(E);const S={};d&1&&(S.$$scope={dirty:d,ctx:m}),s.$set(S);const M={};d&1&&(M.$$scope={dirty:d,ctx:m}),f.$set(M);const v={};d&1&&(v.$$scope={dirty:d,ctx:m}),u.$set(v)},i(m){p||(_(e.$$.fragment,m),_(o.$$.fragment,m),_(i.$$.fragment,m),_(s.$$.fragment,m),_(f.$$.fragment,m),_(u.$$.fragment,m),p=!0)},o(m){k(e.$$.fragment,m),k(o.$$.fragment,m),k(i.$$.fragment,m),k(s.$$.fragment,m),k(f.$$.fragment,m),k(u.$$.fragment,m),p=!1},d(m){O(e,m),m&&h(n),O(o,m),m&&h(t),O(i,m),m&&h(r),O(s,m),m&&h(l),O(f,m),m&&h(c),O(u,m)}}}function Ts(a){let e,n,o;return n=new on({props:{$$slots:{default:[Cs]},$$scope:{ctx:a}}}),{c(){e=B("div"),N(n.$$.fragment)},l(t){e=z(t,"DIV",{});var i=T(e);G(n.$$.fragment,i),i.forEach(h)},m(t,i){A(t,e,i),U(n,e,null),o=!0},p(t,[i]){const r={};i&1&&(r.$$scope={dirty:i,ctx:t}),n.$set(r)},i(t){o||(_(n.$$.fragment,t),o=!0)},o(t){k(n.$$.fragment,t),o=!1},d(t){t&&h(e),O(n)}}}class Is extends Q{constructor(e){super(),J(this,e,null,Ts,ee,{})}}function Ls(a){let e,n;return e=new Is({}),{c(){N(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){U(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){O(e,o)}}}class Rs extends Q{constructor(e){super(),J(this,e,null,Ls,ee,{})}}function Ps(a){let e,n;return e=new Rs({}),{c(){N(e.$$.fragment)},l(o){G(e.$$.fragment,o)},m(o,t){U(e,o,t),n=!0},p:ne,i(o){n||(_(e.$$.fragment,o),n=!0)},o(o){k(e.$$.fragment,o),n=!1},d(o){O(e,o)}}}class e1 extends Q{constructor(e){super(),J(this,e,null,Ps,ee,{})}}export{e1 as default};
